{"version":3,"sources":["../src/evals/reporter.ts","../src/evals/reporter.console-utils.ts","../src/config/resolver.ts","../src/evals/instrument.ts"],"sourcesContent":["import type { SerializedError } from 'vitest';\nimport type { Reporter, TestCase, TestModule, TestRunEndReason, TestSuite } from 'vitest/node';\n\nimport { getAxiomConfig } from './context/storage';\nimport type { EvaluationReport, MetaWithCase, MetaWithEval, Case } from './eval.types';\nimport {\n  printBaselineNameAndVersion,\n  printEvalNameAndFileName,\n  printFinalReport,\n  printGlobalFlagOverrides,\n  printTestCaseCountStartDuration,\n  type SuiteData,\n  printOrphanedBaselineCases,\n  getCaseFingerprint,\n  printCaseResult,\n} from './reporter.console-utils';\nimport { resolveAxiomConnection, type AxiomConnectionResolvedConfig } from '../config/resolver';\nimport { getConsoleUrl } from '../cli/commands/eval.command';\nimport { dotNotationToNested, flattenObject } from '../util/dot-path';\n\n/**\n * Custom Vitest reporter for Axiom AI evaluations.\n *\n * This reporter collects evaluation results and scores from tests\n * and processes them for further analysis and reporting.\n *\n */\nexport class AxiomReporter implements Reporter {\n  startTime: number = 0;\n  start: number = 0;\n  private _endOfRunConfigEnd: EvaluationReport['configEnd'] | undefined;\n  private _suiteData: SuiteData[] = [];\n  private _printedFlagOverrides = false;\n  private _config: AxiomConnectionResolvedConfig | undefined;\n\n  onTestRunStart() {\n    this.start = performance.now();\n    this.startTime = new Date().getTime();\n\n    // Store resourcesUrl from config\n    const config = getAxiomConfig();\n    if (config) {\n      this._config = resolveAxiomConnection(config, getConsoleUrl());\n    }\n  }\n\n  async onTestSuiteReady(_testSuite: TestSuite) {\n    const meta = _testSuite.meta() as MetaWithEval;\n    if (_testSuite.state() === 'skipped' || !meta?.evaluation) {\n      return;\n    }\n\n    // Print flag overrides once when defaults become available\n    // (we don't have them in `onTestRunStart`)\n    if (!this._printedFlagOverrides) {\n      const defaultsFromConfigEnd = meta.evaluation.configEnd?.flags ?? {};\n      const overridesFromConfigEnd = meta.evaluation.configEnd?.overrides ?? {};\n\n      if (Object.keys(overridesFromConfigEnd).length > 0) {\n        printGlobalFlagOverrides(overridesFromConfigEnd, defaultsFromConfigEnd);\n      }\n      this._printedFlagOverrides = true;\n    }\n\n    // capture end-of-run config snapshot (first non-empty wins)\n    if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {\n      this._endOfRunConfigEnd = meta.evaluation.configEnd;\n    }\n  }\n\n  onTestCaseReady(test: TestCase) {\n    const meta = test.meta() as MetaWithCase;\n\n    // TODO: there seem to be some cases where `meta` is undefined\n    // maybe we get here to early?\n    if (!meta.case) return;\n  }\n\n  async onTestSuiteResult(testSuite: TestSuite) {\n    const meta = testSuite.meta() as MetaWithEval;\n    // test suite won't have any meta because its skipped or failed before setup\n    if (testSuite.state() === 'skipped' || !meta?.evaluation) {\n      return;\n    }\n\n    // capture end-of-run config snapshot (first non-empty wins)\n    if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {\n      this._endOfRunConfigEnd = meta.evaluation.configEnd;\n    }\n\n    const durationSeconds = Number((performance.now() - this.start) / 1000).toFixed(2);\n\n    const cases: SuiteData['cases'] = [];\n    for (const test of testSuite.children) {\n      if (test.type !== 'test') continue;\n\n      const testMeta = test.meta() as MetaWithCase;\n      if (!testMeta?.case) continue;\n\n      cases.push({\n        index: testMeta.case.index,\n        scores: testMeta.case.scores,\n        outOfScopeFlags: testMeta.case.outOfScopeFlags,\n        errors: testMeta.case.errors,\n        runtimeFlags: testMeta.case.runtimeFlags,\n      });\n    }\n\n    const cwd = process.cwd();\n    const relativePath = testSuite.module.moduleId.replace(cwd, '').replace(/^\\//, '');\n\n    // Collect suite data for final report\n    let suiteBaseline = meta.evaluation.baseline;\n\n    let flagConfig = meta.evaluation.flagConfig;\n    if (meta.evaluation.configEnd) {\n      const defaults = meta.evaluation.configEnd.flags ?? {};\n      const overrides = meta.evaluation.configEnd.overrides ?? {};\n      const defaultsFlat = flattenObject(defaults);\n      const overridesFlat = flattenObject(overrides);\n      flagConfig = dotNotationToNested({ ...defaultsFlat, ...overridesFlat });\n    }\n\n    const defaultFlagConfig = meta.evaluation.configEnd?.flags;\n\n    this._suiteData.push({\n      version: meta.evaluation.version,\n      name: meta.evaluation.name,\n      file: relativePath,\n      duration: durationSeconds + 's',\n      baseline: suiteBaseline || null,\n      configFlags: meta.evaluation.configFlags,\n      flagConfig,\n      defaultFlagConfig,\n      runId: meta.evaluation.runId,\n      orgId: meta.evaluation.orgId,\n      cases,\n      outOfScopeFlags: meta.evaluation.outOfScopeFlags,\n      registrationStatus: meta.evaluation.registrationStatus,\n    });\n\n    printEvalNameAndFileName(testSuite, meta);\n    printBaselineNameAndVersion(meta);\n\n    printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);\n\n    const matchedBaselineIndices = new Set<number>();\n    const baselineCasesByFingerprint = new Map<string, Case[]>();\n\n    if (suiteBaseline) {\n      for (const c of suiteBaseline.cases) {\n        const fp = getCaseFingerprint(c.input, c.expected);\n        const cases = baselineCasesByFingerprint.get(fp) || [];\n        cases.push(c);\n        baselineCasesByFingerprint.set(fp, cases);\n      }\n    }\n\n    for (const test of testSuite.children) {\n      if (test.type !== 'test') continue;\n      printCaseResult(test, baselineCasesByFingerprint, matchedBaselineIndices);\n    }\n\n    if (suiteBaseline) {\n      printOrphanedBaselineCases(suiteBaseline, matchedBaselineIndices);\n    }\n\n    console.log('');\n  }\n\n  async onTestRunEnd(\n    _testModules: ReadonlyArray<TestModule>,\n    _errors: ReadonlyArray<SerializedError>,\n    _reason: TestRunEndReason,\n  ) {\n    const shouldClear = !process.env.CI && process.stdout.isTTY !== false;\n\n    if (shouldClear) {\n      process.stdout.write('\\x1b[2J\\x1b[0f'); // Clear screen and move cursor to top\n    }\n\n    const registrationStatus = this._suiteData.map((suite) => ({\n      name: suite.name,\n      registered: suite.registrationStatus?.status === 'success',\n      error:\n        suite.registrationStatus?.status === 'failed' ? suite.registrationStatus.error : undefined,\n    }));\n\n    const isDebug = process.env.AXIOM_DEBUG === 'true';\n\n    printFinalReport({\n      suiteData: this._suiteData,\n      config: this._config,\n      registrationStatus,\n      isDebug,\n    });\n  }\n}\n","import c from 'tinyrainbow';\n\nimport type {\n  Case,\n  Evaluation,\n  FlagDiff,\n  MetaWithCase,\n  MetaWithEval,\n  OutOfScopeFlag,\n  RegistrationStatus,\n  OutOfScopeFlagAccess,\n} from './eval.types';\nimport type { TestSuite, TestCase } from 'vitest/node';\nimport type { Score } from './scorers';\nimport { flattenObject } from '../util/dot-path';\nimport type { AxiomConnectionResolvedConfig } from '../config/resolver';\n\nexport type SuiteData = {\n  version: string;\n  name: string;\n  file: string;\n  duration: string;\n  baseline: Evaluation | undefined | null;\n  configFlags?: string[];\n  flagConfig?: Record<string, any>;\n  defaultFlagConfig?: Record<string, any>;\n  runId: string;\n  orgId?: string;\n  cases: Array<{\n    index: number;\n    scores: Record<string, Score>;\n    outOfScopeFlags?: OutOfScopeFlagAccess[];\n    errors?: Error[] | null;\n    runtimeFlags?: any;\n  }>;\n  outOfScopeFlags?: OutOfScopeFlag[];\n  registrationStatus?: RegistrationStatus;\n};\n\nexport type Logger = (message?: string, ...optionalParams: any[]) => void;\n\nexport function formatPercentage(value: number): string {\n  if (!Number.isFinite(value)) {\n    return 'N/A';\n  }\n  return Number(value * 100).toFixed(2) + '%';\n}\n\nexport function formatDiff(current: number, baseline: number) {\n  if (!Number.isFinite(current) || !Number.isFinite(baseline)) {\n    return { text: 'N/A', color: c.dim };\n  }\n  const diff = current - baseline;\n  const diffText = (diff >= 0 ? '+' : '') + formatPercentage(diff);\n  const color = diff > 0 ? c.green : diff < 0 ? c.red : c.dim;\n  return { text: diffText, color };\n}\n\nexport function truncate(str: string, max: number): string {\n  return str.length > max ? str.slice(0, max) + '…' : str;\n}\n\nexport function stringify(value: any): string {\n  try {\n    if (typeof value === 'string') return value;\n    return JSON.stringify(value);\n  } catch {\n    return String(value);\n  }\n}\n\nexport function getCaseFingerprint(\n  input: string | Record<string, any>,\n  expected: string | Record<string, any>,\n): string {\n  const inputStr = typeof input === 'string' ? input : JSON.stringify(input);\n  const expectedStr = typeof expected === 'string' ? expected : JSON.stringify(expected);\n  return JSON.stringify({ input: inputStr, expected: expectedStr });\n}\n\nexport function printEvalNameAndFileName(\n  testSuite: TestSuite,\n  meta: MetaWithEval,\n  logger: Logger = console.log,\n) {\n  const cwd = process.cwd();\n\n  logger(\n    ' ',\n    c.bgCyan(c.black(` ${testSuite.project.name} `)),\n    c.bgBlue(c.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),\n    c.dim(`(${testSuite.children.size} cases)`),\n  );\n\n  logger(' ', c.dim(testSuite.module.moduleId.replace(cwd, '')));\n}\n\nexport function printBaselineNameAndVersion(testMeta: MetaWithEval, logger: Logger = console.log) {\n  if (testMeta.evaluation.baseline) {\n    logger(\n      ' ',\n      ' baseline ',\n      c.bgMagenta(\n        c.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `),\n      ),\n    );\n  } else {\n    logger(' ', c.bgWhite(c.blackBright(' baseline: ')), 'none');\n  }\n\n  logger('');\n}\n\nexport function printRuntimeFlags(testMeta: MetaWithCase, logger: Logger = console.log) {\n  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {\n    const entries = Object.entries(testMeta.case.runtimeFlags);\n    logger('   ', c.dim('runtime flags'));\n    for (const [k, v] of entries) {\n      switch (v.kind) {\n        case 'replaced': {\n          const valText = truncate(stringify(v.value), 80);\n          const defText = truncate(stringify(v.default), 80);\n          logger('     ', `${k}: ${valText} (default: ${defText})`);\n          break;\n        }\n        case 'introduced': {\n          const valText = truncate(stringify(v.value), 80);\n          logger('     ', `${k}: ${valText} (no default)`);\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function printTestCaseCountStartDuration(\n  testSuite: TestSuite,\n  startTime: number,\n  duration: string,\n  logger: Logger = console.log,\n) {\n  logger(' ');\n  logger(' ', c.dim('Cases'), testSuite.children.size);\n  logger(' ', c.dim('Start at'), new Date(startTime).toTimeString());\n  logger(' ', c.dim('Duration'), `${duration}s`);\n}\n\nexport function printTestCaseSuccessOrFailed(\n  testMeta: MetaWithCase,\n  ok: boolean,\n  logger: Logger = console.log,\n) {\n  const index = testMeta.case.index;\n\n  if (ok) {\n    logger(' ', c.yellow(` \\u2714 case ${index}:`));\n  } else {\n    logger(' ', c.red(` \\u2716 case ${index}: failed`));\n    for (const e of testMeta.case.errors ?? []) {\n      logger('', e.message);\n    }\n  }\n}\n\nexport function printTestCaseScores(\n  testMeta: MetaWithCase,\n  baselineCase: Case | null | undefined,\n  logger: Logger = console.log,\n) {\n  const scores = testMeta.case.scores;\n  const keys = Object.keys(scores);\n\n  if (keys.length === 0) {\n    return;\n  }\n\n  const maxNameLength = Math.max(...keys.map((k) => k.length));\n\n  keys.forEach((k) => {\n    const scoreData = scores[k];\n    const hasError = scoreData.metadata?.error;\n    const v = scoreData.score ? scoreData.score : 0;\n\n    const rawCurrent = hasError ? 'N/A' : formatPercentage(v);\n    const paddedCurrent = rawCurrent.padStart(7);\n    const coloredCurrent = hasError ? c.dim(paddedCurrent) : c.magentaBright(paddedCurrent);\n\n    const paddedName = k.padEnd(maxNameLength);\n\n    if (baselineCase?.scores[k]) {\n      const baselineScoreValue = baselineCase.scores[k].value;\n      const rawBaseline = formatPercentage(baselineScoreValue);\n      const paddedBaseline = rawBaseline.padStart(7);\n      const coloredBaseline = c.blueBright(paddedBaseline);\n\n      const { text: diffText, color: diffColor } = formatDiff(v, baselineScoreValue);\n      const paddedDiff = diffText.padStart(8);\n\n      logger(\n        `    ${paddedName}  ${coloredBaseline} → ${coloredCurrent}  ${\n          hasError ? c.dim('(scorer not run)') : c.dim('(') + diffColor(paddedDiff) + c.dim(')')\n        }`,\n      );\n    } else {\n      logger(`    ${paddedName}  ${coloredCurrent} ${hasError ? c.dim('(scorer not run)') : ''}`);\n    }\n  });\n}\n\nexport function printOutOfScopeFlags(testMeta: MetaWithCase, logger: Logger = console.log) {\n  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {\n    const pickedFlagsText = testMeta.case.pickedFlags\n      ? `(picked: ${testMeta.case.pickedFlags.map((f) => `'${f}'`).join(', ')})`\n      : '(none)';\n    logger('   ', c.yellow(`⚠ Out-of-scope flags: ${pickedFlagsText}`));\n    testMeta.case.outOfScopeFlags.forEach((flag) => {\n      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();\n      logger('     ', `${flag.flagPath} (at ${timeStr})`);\n\n      // Show top stack trace frames\n      if (flag.stackTrace && flag.stackTrace.length > 0) {\n        flag.stackTrace.forEach((frame, i) => {\n          const prefix = i === flag.stackTrace.length - 1 ? ' └─' : ' ├─';\n          logger('     ', c.dim(`${prefix} ${frame}`));\n        });\n      }\n    });\n  }\n}\n\nexport function printCaseResult(\n  test: TestCase,\n  baselineCasesByFingerprint: Map<string, Case[]>,\n  matchedIndices: Set<number>,\n  logger: Logger = console.log,\n) {\n  const ok = test.ok();\n  const testMeta = test.meta() as MetaWithCase;\n\n  if (!testMeta?.case) {\n    return;\n  }\n\n  printTestCaseSuccessOrFailed(testMeta, ok, logger);\n\n  const fingerprint = getCaseFingerprint(testMeta.case.input, testMeta.case.expected);\n  const baselineCases = baselineCasesByFingerprint.get(fingerprint);\n  const baselineCase = baselineCases?.shift();\n\n  if (baselineCase) {\n    matchedIndices.add(baselineCase.index);\n  }\n\n  printTestCaseScores(testMeta, baselineCase, logger);\n\n  printRuntimeFlags(testMeta, logger);\n\n  printOutOfScopeFlags(testMeta, logger);\n}\n\nexport function printOrphanedBaselineCases(\n  baseline: Evaluation,\n  matchedIndices: Set<number>,\n  logger: Logger = console.log,\n) {\n  const orphanedCases = baseline.cases.filter((c) => !matchedIndices.has(c.index));\n\n  if (orphanedCases.length === 0) {\n    return;\n  }\n\n  logger('');\n  logger(' ', c.yellow('Orphaned baseline cases:'));\n\n  for (const orphanedCase of orphanedCases) {\n    logger(\n      ' ',\n      c.dim(\n        `case ${orphanedCase.index}: ${truncate(orphanedCase.input, 50)} (score: ${truncate(\n          JSON.stringify(orphanedCase.scores),\n          50,\n        )})`,\n      ),\n    );\n    // We could print detailed scores here if we want, similar to printTestCaseScores\n    // But just listing them is probably enough for now, or using a simplified format\n    const keys = Object.keys(orphanedCase.scores);\n    if (keys.length > 0) {\n      const maxNameLength = Math.max(...keys.map((k) => k.length));\n\n      keys.forEach((k) => {\n        const scoreData = orphanedCase.scores[k];\n        const rawScore = formatPercentage(scoreData.value);\n        const paddedName = k.padEnd(maxNameLength);\n        const paddedScore = rawScore.padStart(7);\n\n        logger(`    ${paddedName}  ${c.blueBright(paddedScore)}`);\n      });\n    }\n  }\n}\n\nexport function printConfigHeader(logger: Logger = console.log) {\n  logger('');\n  logger(' ', c.bgWhite(c.blackBright(' Config ')));\n}\n\nexport function printResultLink(\n  testMeta: MetaWithCase,\n  axiomUrl: string,\n  logger: Logger = console.log,\n) {\n  const url = `${axiomUrl}/evaluations/${testMeta.evaluation.name}/${testMeta.evaluation.id}`;\n  logger(\n    ' ',\n    `see results for ${testMeta.evaluation.name}-${testMeta.evaluation.version} at ${url}`,\n  );\n}\n\nexport const reporterDate = (d: Date) => {\n  const date = d.toISOString().slice(0, 10); // \"2025-10-03\"\n  const hours = d.getUTCHours().toString().padStart(2, '0');\n  const minutes = d.getUTCMinutes().toString().padStart(2, '0');\n  return `${date}, ${hours}:${minutes} UTC`;\n};\n\nexport function printGlobalFlagOverrides(\n  overrides: Record<string, any>,\n  defaults: Record<string, any>,\n  logger: Logger = console.log,\n) {\n  if (Object.keys(overrides).length === 0) {\n    logger('');\n    logger(c.dim('Flag overrides: (none)'));\n    logger('');\n    return;\n  }\n\n  logger('');\n  logger('Flag overrides:');\n  for (const [key, value] of Object.entries(overrides)) {\n    const defaultValue = defaults[key];\n    const valueStr = JSON.stringify(value);\n    const defaultStr = defaultValue !== undefined ? JSON.stringify(defaultValue) : 'none';\n    logger(`  • ${key}: ${valueStr} ${c.dim(`(default: ${defaultStr})`)}`);\n  }\n  logger('');\n}\n\nexport function printSuiteBox({\n  suite,\n  scorerAverages,\n  calculateBaselineScorerAverage,\n  flagDiff,\n  logger = console.log,\n}: {\n  suite: SuiteData;\n  scorerAverages: Record<string, number>;\n  calculateBaselineScorerAverage: (baseline: Evaluation, scorerName: string) => number | null;\n  flagDiff: Array<FlagDiff>;\n  logger?: Logger;\n}) {\n  const filename = suite.file.split('/').pop();\n\n  logger('┌─');\n  logger(`│  ${c.blue(suite.name)} ${c.gray(`(${filename})`)}`);\n  logger('├─');\n\n  const scorerNames = Object.keys(scorerAverages);\n  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));\n\n  const allCasesErrored = (scorerName: string) => {\n    return suite.cases.every((caseData) => caseData.scores[scorerName]?.metadata?.error);\n  };\n\n  for (const scorerName of scorerNames) {\n    const avg = scorerAverages[scorerName];\n    const paddedName = scorerName.padEnd(maxNameLength);\n    const hasAllErrors = allCasesErrored(scorerName);\n\n    const baselineAvg = suite.baseline\n      ? calculateBaselineScorerAverage(suite.baseline, scorerName)\n      : null;\n\n    if (baselineAvg !== null) {\n      const currentPercent = hasAllErrors ? c.dim('N/A') : formatPercentage(avg);\n      const baselinePercent = formatPercentage(baselineAvg);\n      const { text: diffText, color: diffColor } = formatDiff(avg, baselineAvg);\n\n      const paddedBaseline = baselinePercent.padStart(7);\n      const paddedCurrent = hasAllErrors ? currentPercent : currentPercent.padStart(7);\n      const diffDisplay = hasAllErrors\n        ? c.dim('all cases failed')\n        : diffColor(diffText.padStart(8));\n\n      logger(\n        `│  ${paddedName}  ${c.blueBright(paddedBaseline)} → ${hasAllErrors ? paddedCurrent : c.magentaBright(paddedCurrent)}  (${diffDisplay})`,\n      );\n    } else {\n      const currentPercent = hasAllErrors ? c.red('N/A (all cases failed)') : formatPercentage(avg);\n      logger(`│   • ${paddedName}  ${currentPercent}`);\n    }\n  }\n\n  logger('├─');\n\n  if (suite.baseline) {\n    const baselineTimestamp = suite.baseline.runAt\n      ? reporterDate(new Date(suite.baseline.runAt))\n      : 'unknown time';\n    logger(\n      `│  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${c.gray(`(${baselineTimestamp})`)}`,\n    );\n  } else {\n    logger(`│  Baseline: ${c.gray('(none)')}`);\n  }\n\n  const hasConfigChanges = flagDiff.length > 0;\n\n  logger('│  Config changes:', hasConfigChanges ? '' : c.gray('(none)'));\n  if (hasConfigChanges) {\n    for (const { flag, current, baseline, default: defaultVal } of flagDiff) {\n      logger(`│   • ${flag}: ${current ?? '<not set>'}`);\n      if (defaultVal !== undefined) {\n        logger(`│       ${c.gray(`default: ${defaultVal}`)}`);\n      }\n      if (suite.baseline) {\n        logger(`│       ${c.gray(`baseline: ${baseline ?? '<not set>'}`)}`);\n      }\n    }\n  }\n\n  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {\n    const pickedFlagsText =\n      suite.configFlags && suite.configFlags.length > 0\n        ? suite.configFlags.map((f) => `'${f}'`).join(', ')\n        : 'none';\n    logger('│');\n    logger(`│  ${c.yellow('⚠ Out-of-scope flags')} ${c.gray(`(picked: ${pickedFlagsText})`)}:`);\n    for (const flag of suite.outOfScopeFlags) {\n      const lastStackTraceFrame = flag.stackTrace[0];\n      const lastStackTraceFnName = lastStackTraceFrame.split(' ').shift();\n      const lastStackTraceFile = lastStackTraceFrame.split('/').pop()?.slice(0, -1);\n      logger(\n        `│   • ${flag.flagPath} ${c.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`,\n      );\n    }\n  }\n\n  logger('└─');\n}\n\n/**\n * Calculate average scores per scorer for a suite\n */\nexport function calculateScorerAverages(suite: SuiteData): Record<string, number> {\n  const scorerTotals: Record<string, { sum: number; count: number }> = {};\n\n  for (const caseData of suite.cases) {\n    for (const [scorerName, score] of Object.entries(caseData.scores)) {\n      if (!scorerTotals[scorerName]) {\n        scorerTotals[scorerName] = { sum: 0, count: 0 };\n      }\n      if (!score.metadata?.error) {\n        scorerTotals[scorerName].sum += score.score || 0;\n        scorerTotals[scorerName].count += 1;\n      }\n    }\n  }\n\n  const averages: Record<string, number> = {};\n  for (const [scorerName, totals] of Object.entries(scorerTotals)) {\n    averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;\n  }\n\n  return averages;\n}\n\n/**\n * Calculate average score for a specific scorer from baseline data\n */\nexport function calculateBaselineScorerAverage(\n  baseline: Evaluation,\n  scorerName: string,\n): number | null {\n  const scores: number[] = [];\n\n  for (const caseData of baseline.cases) {\n    if (caseData.scores[scorerName]) {\n      scores.push(caseData.scores[scorerName].value);\n    }\n  }\n\n  if (scores.length === 0) return null;\n\n  const sum = scores.reduce((acc, val) => acc + val, 0);\n  return sum / scores.length;\n}\n\n/**\n * Calculate flag diff between current run vs baseline and defaults (filtered by configFlags).\n * Shows a diff if current differs from at least one of baseline or default.\n */\nexport function calculateFlagDiff(suite: SuiteData): Array<FlagDiff> {\n  if (!suite.configFlags || suite.configFlags.length === 0) {\n    return [];\n  }\n\n  const diffs: Array<FlagDiff> = [];\n\n  const currentConfig = suite.flagConfig || {};\n  const baselineConfig = suite.baseline?.flagConfig || {};\n  const defaultConfig = suite.defaultFlagConfig || {};\n\n  const currentFlat = flattenObject(currentConfig);\n  const baselineFlat = flattenObject(baselineConfig);\n  const defaultFlat = flattenObject(defaultConfig);\n\n  const allKeys = new Set([\n    ...Object.keys(currentFlat),\n    ...Object.keys(baselineFlat),\n    ...Object.keys(defaultFlat),\n  ]);\n\n  for (const key of allKeys) {\n    const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));\n    if (!isInScope) continue;\n\n    const currentValue = currentFlat[key];\n    const baselineValue = baselineFlat[key];\n    const defaultValue = defaultFlat[key];\n\n    const currentStr = currentValue !== undefined ? JSON.stringify(currentValue) : undefined;\n    const baselineStr = baselineValue !== undefined ? JSON.stringify(baselineValue) : undefined;\n    const defaultStr = defaultValue !== undefined ? JSON.stringify(defaultValue) : undefined;\n\n    const diffFromBaseline = suite.baseline && currentStr !== baselineStr;\n    const diffFromDefault = currentStr !== defaultStr;\n\n    if (diffFromBaseline || diffFromDefault) {\n      diffs.push({\n        flag: key,\n        current: currentStr,\n        baseline: suite.baseline ? baselineStr : undefined,\n        default: defaultStr,\n      });\n    }\n  }\n\n  return diffs;\n}\n\nexport function printFinalReport({\n  suiteData,\n  config,\n  registrationStatus,\n  isDebug,\n  logger = console.log,\n}: {\n  suiteData: SuiteData[];\n  config?: AxiomConnectionResolvedConfig;\n  registrationStatus: Array<{ name: string; registered: boolean; error?: string }>;\n  isDebug?: boolean;\n  logger?: Logger;\n}) {\n  logger('');\n  logger(c.bgBlue(c.white(' FINAL EVALUATION REPORT ')));\n  logger('');\n\n  for (const suite of suiteData) {\n    const scorerAverages = calculateScorerAverages(suite);\n    const flagDiff = calculateFlagDiff(suite);\n    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff, logger });\n    logger('');\n  }\n\n  const runId = suiteData[0]?.runId;\n  const orgId = suiteData[0]?.orgId;\n\n  const anyRegistered = registrationStatus.some((s) => s.registered);\n  const anyFailed = registrationStatus.some((s) => !s.registered);\n\n  if (anyRegistered && orgId && config?.consoleEndpointUrl) {\n    if (suiteData.length === 1) {\n      const suite = suiteData[0];\n      const baselineParam = suite.baseline?.traceId ? `?baselineId=${suite.baseline.traceId}` : '';\n      logger('View eval result:');\n      logger(\n        `${config.consoleEndpointUrl}/${orgId}/ai-engineering/evaluations/${suite.name}/${suite.version}${baselineParam}`,\n      );\n    } else {\n      logger('View full report:');\n      logger(`${config.consoleEndpointUrl}/${orgId}/ai-engineering/evaluations?runId=${runId}`);\n    }\n  } else if (isDebug) {\n    logger(c.dim('Results not uploaded to Axiom (debug mode)'));\n  } else {\n    logger('Results not available in Axiom UI (registration failed)');\n  }\n\n  if (anyFailed) {\n    logger('');\n    for (const status of registrationStatus) {\n      if (!status.registered) {\n        logger(c.yellow(`⚠️  Warning: Failed to register \"${status.name}\" with Axiom`));\n        if (status.error) {\n          logger(c.dim(`   Error: ${status.error}`));\n        }\n        logger(c.dim(`   Results for this evaluation will not be available in the Axiom UI.`));\n      }\n    }\n  }\n}\n","import type { AxiomEvalInstrumentationOptions, ResolvedAxiomConfig } from './index';\n\n/**\n * Builds a resources URL under the assumption that the API URL is in the format of https://api.axiom.co by replacing the subdomain with app.\n * @param urlString - The API URL\n * @returns The resources URL\n */\nconst buildConsoleUrl = (urlString: string) => {\n  const url = new URL(urlString);\n\n  return `${url.protocol}//app.${url.host.split('api.').at(-1)}`;\n};\n\n/**\n * Resolve Axiom connection settings from resolved config.\n *\n * Since the config is already resolved with defaults merged, we can directly\n * access the properties without fallback chains.\n *\n * @param config - The resolved configuration\n * @returns Resolved connection settings\n */\nexport function resolveAxiomConnection(\n  config: ResolvedAxiomConfig,\n  consoleUrlOverride?: string,\n): AxiomEvalInstrumentationOptions & { consoleEndpointUrl: string } {\n  const consoleEndpointUrl = consoleUrlOverride ?? buildConsoleUrl(config.eval.url);\n\n  return {\n    url: config.eval.url,\n    consoleEndpointUrl: consoleEndpointUrl,\n    token: config.eval.token,\n    dataset: config.eval.dataset,\n    orgId: config.eval.orgId,\n  };\n}\n\nexport type AxiomConnectionResolvedConfig = ReturnType<typeof resolveAxiomConnection>;\n","import { BatchSpanProcessor, NodeTracerProvider } from '@opentelemetry/sdk-trace-node';\nimport { resourceFromAttributes } from '@opentelemetry/resources';\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';\nimport {\n  context,\n  trace,\n  type Context,\n  type Span,\n  type SpanOptions,\n  SpanStatusCode,\n  type Tracer,\n  type TracerProvider,\n} from '@opentelemetry/api';\nimport { initAxiomAI } from '../../src/otel/initAxiomAI';\nimport type {\n  AxiomEvalInstrumentationHook,\n  AxiomEvalInstrumentationOptions,\n  AxiomEvalInstrumentationResult,\n  ResolvedAxiomConfig,\n} from '../config/index';\nimport { resolveAxiomConnection } from '../config/resolver';\nimport { AxiomCLIError, errorToString } from '../util/errors';\nimport { loadConfig } from '../config/loader';\n\n// Lazily initialized tracer provider and exporter\nlet axiomProvider: NodeTracerProvider | undefined;\nlet axiomTracer: Tracer | undefined;\nlet userProvider: TracerProvider | undefined;\n\nlet initializationPromise: Promise<void> | null = null;\nlet initialized = false;\n\nasync function resolveInstrumentationHook(\n  config: ResolvedAxiomConfig,\n): Promise<AxiomEvalInstrumentationHook | null> {\n  if (config.eval.instrumentation) {\n    return config.eval.instrumentation;\n  }\n\n  try {\n    const { config: loadedConfig } = await loadConfig(process.cwd());\n    return (loadedConfig.eval.instrumentation ?? null) as AxiomEvalInstrumentationHook | null;\n  } catch (error) {\n    throw new AxiomCLIError(\n      `Failed to reload instrumentation from config: ${errorToString(error)}`,\n    );\n  }\n}\n\nasync function runInstrumentationHook(\n  hook: AxiomEvalInstrumentationHook,\n  options: AxiomEvalInstrumentationOptions,\n): Promise<AxiomEvalInstrumentationResult | void> {\n  try {\n    return await hook(options);\n  } catch (error) {\n    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);\n  }\n}\n\nfunction setupEvalProvider(connection: ReturnType<typeof resolveAxiomConnection>) {\n  const headers: Record<string, string> = {\n    'X-Axiom-Dataset': connection.dataset,\n    ...(connection.orgId ? { 'X-AXIOM-ORG-ID': connection.orgId } : {}),\n  };\n\n  if (connection.token) {\n    headers.Authorization = `Bearer ${connection.token}`;\n  }\n\n  const collectorOptions = {\n    url: `${connection.url}/v1/traces`,\n    headers,\n    concurrencyLimit: 10,\n  };\n\n  const exporter = new OTLPTraceExporter(collectorOptions);\n\n  const processor = new BatchSpanProcessor(exporter, {\n    maxQueueSize: 2048,\n    maxExportBatchSize: 512,\n    scheduledDelayMillis: 5000,\n    exportTimeoutMillis: 30000,\n  });\n\n  axiomProvider = new NodeTracerProvider({\n    resource: resourceFromAttributes({\n      ['service.name']: 'axiom',\n      ['service.version']: __SDK_VERSION__,\n    }),\n    spanProcessors: [processor],\n  });\n\n  axiomTracer = axiomProvider.getTracer('axiom', __SDK_VERSION__);\n}\n\nexport async function initInstrumentation(config: {\n  enabled: boolean;\n  config: ResolvedAxiomConfig;\n}): Promise<void> {\n  if (initialized) {\n    return;\n  }\n\n  if (initializationPromise) {\n    await initializationPromise;\n    return;\n  }\n\n  initializationPromise = (async () => {\n    if (!config.enabled) {\n      axiomTracer = trace.getTracer('axiom', __SDK_VERSION__);\n      initialized = true;\n      return;\n    }\n\n    const connection = resolveAxiomConnection(config.config);\n    const hook = await resolveInstrumentationHook(config.config);\n    let hookResult: AxiomEvalInstrumentationResult | void = undefined;\n\n    if (hook) {\n      config.config.eval.instrumentation = hook;\n      hookResult = await runInstrumentationHook(hook, {\n        dataset: connection.dataset,\n        token: connection.token,\n        url: connection.url,\n        orgId: connection.orgId,\n      });\n\n      userProvider = hookResult?.provider ?? userProvider;\n    }\n\n    setupEvalProvider(connection);\n\n    if (!hook) {\n      // Fall back to default behaviour by registering our provider globally\n      axiomProvider?.register();\n      if (axiomTracer) {\n        initAxiomAI({ tracer: axiomTracer });\n      }\n    }\n\n    initialized = true;\n  })();\n\n  try {\n    await initializationPromise;\n  } finally {\n    initializationPromise = null;\n  }\n}\n\nexport const flush = async () => {\n  if (initializationPromise) {\n    await initializationPromise;\n  }\n\n  const tasks: Array<Promise<unknown>> = [];\n\n  if (axiomProvider) {\n    tasks.push(axiomProvider.forceFlush());\n  }\n\n  const candidateProviders = new Set<TracerProvider>();\n  if (userProvider) {\n    candidateProviders.add(userProvider);\n  }\n\n  const globalProvider = trace.getTracerProvider();\n  if (globalProvider) {\n    candidateProviders.add(globalProvider);\n  }\n\n  for (const provider of candidateProviders) {\n    const flushFn = (provider as any).forceFlush;\n    if (typeof flushFn === 'function') {\n      tasks.push(\n        flushFn.call(provider).catch((error: unknown) => {\n          console.warn('[AxiomAI] Failed to flush tracer provider:', errorToString(error));\n        }),\n      );\n    }\n  }\n\n  if (tasks.length > 0) {\n    await Promise.all(tasks);\n  }\n};\n\n/**\n * Ensure instrumentation is initialized with the given config.\n * Call this from within test context before using startSpan.\n */\nexport async function ensureInstrumentationInitialized(\n  config: ResolvedAxiomConfig,\n  options: { enabled?: boolean } = {},\n): Promise<void> {\n  if (initialized) {\n    return;\n  }\n\n  const enabled = options.enabled ?? true;\n  await initInstrumentation({ enabled, config });\n}\n\nconst getEvalTracer = (): Tracer => {\n  if (!axiomTracer) {\n    throw new Error(\n      'Eval tracer not initialized. Ensure ensureInstrumentationInitialized() was awaited before starting spans.',\n    );\n  }\n\n  return axiomTracer;\n};\n\nexport const startSpan = (name: string, opts: SpanOptions, context?: Context) => {\n  if (!initialized || !axiomTracer) {\n    throw new Error(\n      'Instrumentation not initialized. This is likely a bug - instrumentation should be initialized before startSpan is called.',\n    );\n  }\n  return getEvalTracer().startSpan(name, opts, context);\n};\n\nexport const startActiveSpan = async <T>(\n  name: string,\n  options: SpanOptions,\n  fn: (span: Span) => Promise<T>,\n  parentContext?: Context,\n): Promise<T> => {\n  const span = startSpan(name, options, parentContext);\n\n  return context.with(trace.setSpan(context.active(), span), async () => {\n    try {\n      const result = await fn(span);\n      span.setStatus({ code: SpanStatusCode.OK });\n      return result;\n    } catch (error) {\n      span.recordException(error as Error);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    } finally {\n      span.end();\n    }\n  });\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;;;ACAA;AAyCO,SAAS,iBAAiB,OAAuB;AACtD,MAAI,CAAC,OAAO,SAAS,KAAK,GAAG;AAC3B,WAAO;AAAA,EACT;AACA,SAAO,OAAO,QAAQ,GAAG,EAAE,QAAQ,CAAC,IAAI;AAC1C;AAEO,SAAS,WAAW,SAAiB,UAAkB;AAC5D,MAAI,CAAC,OAAO,SAAS,OAAO,KAAK,CAAC,OAAO,SAAS,QAAQ,GAAG;AAC3D,WAAO,EAAE,MAAM,OAAO,OAAO,EAAE,IAAI;AAAA,EACrC;AACA,QAAM,OAAO,UAAU;AACvB,QAAM,YAAY,QAAQ,IAAI,MAAM,MAAM,iBAAiB,IAAI;AAC/D,QAAM,QAAQ,OAAO,IAAI,EAAE,QAAQ,OAAO,IAAI,EAAE,MAAM,EAAE;AACxD,SAAO,EAAE,MAAM,UAAU,MAAM;AACjC;AAEO,SAAS,SAAS,KAAa,KAAqB;AACzD,SAAO,IAAI,SAAS,MAAM,IAAI,MAAM,GAAG,GAAG,IAAI,WAAM;AACtD;AAEO,SAAS,UAAU,OAAoB;AAC5C,MAAI;AACF,QAAI,OAAO,UAAU,SAAU,QAAO;AACtC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC7B,QAAQ;AACN,WAAO,OAAO,KAAK;AAAA,EACrB;AACF;AAEO,SAAS,mBACd,OACA,UACQ;AACR,QAAM,WAAW,OAAO,UAAU,WAAW,QAAQ,KAAK,UAAU,KAAK;AACzE,QAAM,cAAc,OAAO,aAAa,WAAW,WAAW,KAAK,UAAU,QAAQ;AACrF,SAAO,KAAK,UAAU,EAAE,OAAO,UAAU,UAAU,YAAY,CAAC;AAClE;AAEO,SAAS,yBACd,WACA,MACA,SAAiB,QAAQ,KACzB;AACA,QAAM,MAAM,QAAQ,IAAI;AAExB;AAAA,IACE;AAAA,IACA,EAAE,OAAO,EAAE,MAAM,IAAI,UAAU,QAAQ,IAAI,GAAG,CAAC;AAAA,IAC/C,EAAE,OAAO,EAAE,MAAM,IAAI,KAAK,WAAW,IAAI,IAAI,KAAK,WAAW,OAAO,GAAG,CAAC;AAAA,IACxE,EAAE,IAAI,IAAI,UAAU,SAAS,IAAI,SAAS;AAAA,EAC5C;AAEA,SAAO,KAAK,EAAE,IAAI,UAAU,OAAO,SAAS,QAAQ,KAAK,EAAE,CAAC,CAAC;AAC/D;AAEO,SAAS,4BAA4B,UAAwB,SAAiB,QAAQ,KAAK;AAChG,MAAI,SAAS,WAAW,UAAU;AAChC;AAAA,MACE;AAAA,MACA;AAAA,MACA,EAAE;AAAA,QACA,EAAE,MAAM,IAAI,SAAS,WAAW,SAAS,IAAI,IAAI,SAAS,WAAW,SAAS,OAAO,GAAG;AAAA,MAC1F;AAAA,IACF;AAAA,EACF,OAAO;AACL,WAAO,KAAK,EAAE,QAAQ,EAAE,YAAY,aAAa,CAAC,GAAG,MAAM;AAAA,EAC7D;AAEA,SAAO,EAAE;AACX;AAEO,SAAS,kBAAkB,UAAwB,SAAiB,QAAQ,KAAK;AACtF,MAAI,SAAS,KAAK,gBAAgB,OAAO,KAAK,SAAS,KAAK,YAAY,EAAE,SAAS,GAAG;AACpF,UAAM,UAAU,OAAO,QAAQ,SAAS,KAAK,YAAY;AACzD,WAAO,OAAO,EAAE,IAAI,eAAe,CAAC;AACpC,eAAW,CAAC,GAAG,CAAC,KAAK,SAAS;AAC5B,cAAQ,EAAE,MAAM;AAAA,QACd,KAAK,YAAY;AACf,gBAAM,UAAU,SAAS,UAAU,EAAE,KAAK,GAAG,EAAE;AAC/C,gBAAM,UAAU,SAAS,UAAU,EAAE,OAAO,GAAG,EAAE;AACjD,iBAAO,SAAS,GAAG,CAAC,KAAK,OAAO,cAAc,OAAO,GAAG;AACxD;AAAA,QACF;AAAA,QACA,KAAK,cAAc;AACjB,gBAAM,UAAU,SAAS,UAAU,EAAE,KAAK,GAAG,EAAE;AAC/C,iBAAO,SAAS,GAAG,CAAC,KAAK,OAAO,eAAe;AAC/C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEO,SAAS,gCACd,WACA,WACA,UACA,SAAiB,QAAQ,KACzB;AACA,SAAO,GAAG;AACV,SAAO,KAAK,EAAE,IAAI,OAAO,GAAG,UAAU,SAAS,IAAI;AACnD,SAAO,KAAK,EAAE,IAAI,UAAU,GAAG,IAAI,KAAK,SAAS,EAAE,aAAa,CAAC;AACjE,SAAO,KAAK,EAAE,IAAI,UAAU,GAAG,GAAG,QAAQ,GAAG;AAC/C;AAEO,SAAS,6BACd,UACA,IACA,SAAiB,QAAQ,KACzB;AACA,QAAM,QAAQ,SAAS,KAAK;AAE5B,MAAI,IAAI;AACN,WAAO,KAAK,EAAE,OAAO,gBAAgB,KAAK,GAAG,CAAC;AAAA,EAChD,OAAO;AACL,WAAO,KAAK,EAAE,IAAI,gBAAgB,KAAK,UAAU,CAAC;AAClD,eAAW,KAAK,SAAS,KAAK,UAAU,CAAC,GAAG;AAC1C,aAAO,IAAI,EAAE,OAAO;AAAA,IACtB;AAAA,EACF;AACF;AAEO,SAAS,oBACd,UACA,cACA,SAAiB,QAAQ,KACzB;AACA,QAAM,SAAS,SAAS,KAAK;AAC7B,QAAM,OAAO,OAAO,KAAK,MAAM;AAE/B,MAAI,KAAK,WAAW,GAAG;AACrB;AAAA,EACF;AAEA,QAAM,gBAAgB,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;AAE3D,OAAK,QAAQ,CAAC,MAAM;AAClB,UAAM,YAAY,OAAO,CAAC;AAC1B,UAAM,WAAW,UAAU,UAAU;AACrC,UAAM,IAAI,UAAU,QAAQ,UAAU,QAAQ;AAE9C,UAAM,aAAa,WAAW,QAAQ,iBAAiB,CAAC;AACxD,UAAM,gBAAgB,WAAW,SAAS,CAAC;AAC3C,UAAM,iBAAiB,WAAW,EAAE,IAAI,aAAa,IAAI,EAAE,cAAc,aAAa;AAEtF,UAAM,aAAa,EAAE,OAAO,aAAa;AAEzC,QAAI,cAAc,OAAO,CAAC,GAAG;AAC3B,YAAM,qBAAqB,aAAa,OAAO,CAAC,EAAE;AAClD,YAAM,cAAc,iBAAiB,kBAAkB;AACvD,YAAM,iBAAiB,YAAY,SAAS,CAAC;AAC7C,YAAM,kBAAkB,EAAE,WAAW,cAAc;AAEnD,YAAM,EAAE,MAAM,UAAU,OAAO,UAAU,IAAI,WAAW,GAAG,kBAAkB;AAC7E,YAAM,aAAa,SAAS,SAAS,CAAC;AAEtC;AAAA,QACE,OAAO,UAAU,KAAK,eAAe,WAAM,cAAc,KACvD,WAAW,EAAE,IAAI,kBAAkB,IAAI,EAAE,IAAI,GAAG,IAAI,UAAU,UAAU,IAAI,EAAE,IAAI,GAAG,CACvF;AAAA,MACF;AAAA,IACF,OAAO;AACL,aAAO,OAAO,UAAU,KAAK,cAAc,IAAI,WAAW,EAAE,IAAI,kBAAkB,IAAI,EAAE,EAAE;AAAA,IAC5F;AAAA,EACF,CAAC;AACH;AAEO,SAAS,qBAAqB,UAAwB,SAAiB,QAAQ,KAAK;AACzF,MAAI,SAAS,KAAK,mBAAmB,SAAS,KAAK,gBAAgB,SAAS,GAAG;AAC7E,UAAM,kBAAkB,SAAS,KAAK,cAClC,YAAY,SAAS,KAAK,YAAY,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,CAAC,MACrE;AACJ,WAAO,OAAO,EAAE,OAAO,8BAAyB,eAAe,EAAE,CAAC;AAClE,aAAS,KAAK,gBAAgB,QAAQ,CAAC,SAAS;AAC9C,YAAM,UAAU,IAAI,KAAK,KAAK,UAAU,EAAE,mBAAmB;AAC7D,aAAO,SAAS,GAAG,KAAK,QAAQ,QAAQ,OAAO,GAAG;AAGlD,UAAI,KAAK,cAAc,KAAK,WAAW,SAAS,GAAG;AACjD,aAAK,WAAW,QAAQ,CAAC,OAAO,MAAM;AACpC,gBAAM,SAAS,MAAM,KAAK,WAAW,SAAS,IAAI,kBAAQ;AAC1D,iBAAO,SAAS,EAAE,IAAI,GAAG,MAAM,IAAI,KAAK,EAAE,CAAC;AAAA,QAC7C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,SAAS,gBACd,MACA,4BACA,gBACA,SAAiB,QAAQ,KACzB;AACA,QAAM,KAAK,KAAK,GAAG;AACnB,QAAM,WAAW,KAAK,KAAK;AAE3B,MAAI,CAAC,UAAU,MAAM;AACnB;AAAA,EACF;AAEA,+BAA6B,UAAU,IAAI,MAAM;AAEjD,QAAM,cAAc,mBAAmB,SAAS,KAAK,OAAO,SAAS,KAAK,QAAQ;AAClF,QAAM,gBAAgB,2BAA2B,IAAI,WAAW;AAChE,QAAM,eAAe,eAAe,MAAM;AAE1C,MAAI,cAAc;AAChB,mBAAe,IAAI,aAAa,KAAK;AAAA,EACvC;AAEA,sBAAoB,UAAU,cAAc,MAAM;AAElD,oBAAkB,UAAU,MAAM;AAElC,uBAAqB,UAAU,MAAM;AACvC;AAEO,SAAS,2BACd,UACA,gBACA,SAAiB,QAAQ,KACzB;AACA,QAAM,gBAAgB,SAAS,MAAM,OAAO,CAAC,MAAM,CAAC,eAAe,IAAI,EAAE,KAAK,CAAC;AAE/E,MAAI,cAAc,WAAW,GAAG;AAC9B;AAAA,EACF;AAEA,SAAO,EAAE;AACT,SAAO,KAAK,EAAE,OAAO,0BAA0B,CAAC;AAEhD,aAAW,gBAAgB,eAAe;AACxC;AAAA,MACE;AAAA,MACA,EAAE;AAAA,QACA,QAAQ,aAAa,KAAK,KAAK,SAAS,aAAa,OAAO,EAAE,CAAC,YAAY;AAAA,UACzE,KAAK,UAAU,aAAa,MAAM;AAAA,UAClC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAGA,UAAM,OAAO,OAAO,KAAK,aAAa,MAAM;AAC5C,QAAI,KAAK,SAAS,GAAG;AACnB,YAAM,gBAAgB,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;AAE3D,WAAK,QAAQ,CAAC,MAAM;AAClB,cAAM,YAAY,aAAa,OAAO,CAAC;AACvC,cAAM,WAAW,iBAAiB,UAAU,KAAK;AACjD,cAAM,aAAa,EAAE,OAAO,aAAa;AACzC,cAAM,cAAc,SAAS,SAAS,CAAC;AAEvC,eAAO,OAAO,UAAU,KAAK,EAAE,WAAW,WAAW,CAAC,EAAE;AAAA,MAC1D,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAmBO,IAAM,eAAe,CAAC,MAAY;AACvC,QAAM,OAAO,EAAE,YAAY,EAAE,MAAM,GAAG,EAAE;AACxC,QAAM,QAAQ,EAAE,YAAY,EAAE,SAAS,EAAE,SAAS,GAAG,GAAG;AACxD,QAAM,UAAU,EAAE,cAAc,EAAE,SAAS,EAAE,SAAS,GAAG,GAAG;AAC5D,SAAO,GAAG,IAAI,KAAK,KAAK,IAAI,OAAO;AACrC;AAEO,SAAS,yBACd,WACA,UACA,SAAiB,QAAQ,KACzB;AACA,MAAI,OAAO,KAAK,SAAS,EAAE,WAAW,GAAG;AACvC,WAAO,EAAE;AACT,WAAO,EAAE,IAAI,wBAAwB,CAAC;AACtC,WAAO,EAAE;AACT;AAAA,EACF;AAEA,SAAO,EAAE;AACT,SAAO,iBAAiB;AACxB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACpD,UAAM,eAAe,SAAS,GAAG;AACjC,UAAM,WAAW,KAAK,UAAU,KAAK;AACrC,UAAM,aAAa,iBAAiB,SAAY,KAAK,UAAU,YAAY,IAAI;AAC/E,WAAO,YAAO,GAAG,KAAK,QAAQ,IAAI,EAAE,IAAI,aAAa,UAAU,GAAG,CAAC,EAAE;AAAA,EACvE;AACA,SAAO,EAAE;AACX;AAEO,SAAS,cAAc;AAAA,EAC5B;AAAA,EACA;AAAA,EACA,gCAAAA;AAAA,EACA;AAAA,EACA,SAAS,QAAQ;AACnB,GAMG;AACD,QAAM,WAAW,MAAM,KAAK,MAAM,GAAG,EAAE,IAAI;AAE3C,SAAO,cAAI;AACX,SAAO,WAAM,EAAE,KAAK,MAAM,IAAI,CAAC,IAAI,EAAE,KAAK,IAAI,QAAQ,GAAG,CAAC,EAAE;AAC5D,SAAO,cAAI;AAEX,QAAM,cAAc,OAAO,KAAK,cAAc;AAC9C,QAAM,gBAAgB,KAAK,IAAI,GAAG,YAAY,IAAI,CAAC,SAAS,KAAK,MAAM,CAAC;AAExE,QAAM,kBAAkB,CAAC,eAAuB;AAC9C,WAAO,MAAM,MAAM,MAAM,CAAC,aAAa,SAAS,OAAO,UAAU,GAAG,UAAU,KAAK;AAAA,EACrF;AAEA,aAAW,cAAc,aAAa;AACpC,UAAM,MAAM,eAAe,UAAU;AACrC,UAAM,aAAa,WAAW,OAAO,aAAa;AAClD,UAAM,eAAe,gBAAgB,UAAU;AAE/C,UAAM,cAAc,MAAM,WACtBA,gCAA+B,MAAM,UAAU,UAAU,IACzD;AAEJ,QAAI,gBAAgB,MAAM;AACxB,YAAM,iBAAiB,eAAe,EAAE,IAAI,KAAK,IAAI,iBAAiB,GAAG;AACzE,YAAM,kBAAkB,iBAAiB,WAAW;AACpD,YAAM,EAAE,MAAM,UAAU,OAAO,UAAU,IAAI,WAAW,KAAK,WAAW;AAExE,YAAM,iBAAiB,gBAAgB,SAAS,CAAC;AACjD,YAAM,gBAAgB,eAAe,iBAAiB,eAAe,SAAS,CAAC;AAC/E,YAAM,cAAc,eAChB,EAAE,IAAI,kBAAkB,IACxB,UAAU,SAAS,SAAS,CAAC,CAAC;AAElC;AAAA,QACE,WAAM,UAAU,KAAK,EAAE,WAAW,cAAc,CAAC,WAAM,eAAe,gBAAgB,EAAE,cAAc,aAAa,CAAC,MAAM,WAAW;AAAA,MACvI;AAAA,IACF,OAAO;AACL,YAAM,iBAAiB,eAAe,EAAE,IAAI,wBAAwB,IAAI,iBAAiB,GAAG;AAC5F,aAAO,mBAAS,UAAU,KAAK,cAAc,EAAE;AAAA,IACjD;AAAA,EACF;AAEA,SAAO,cAAI;AAEX,MAAI,MAAM,UAAU;AAClB,UAAM,oBAAoB,MAAM,SAAS,QACrC,aAAa,IAAI,KAAK,MAAM,SAAS,KAAK,CAAC,IAC3C;AACJ;AAAA,MACE,qBAAgB,MAAM,SAAS,IAAI,IAAI,MAAM,SAAS,OAAO,IAAI,EAAE,KAAK,IAAI,iBAAiB,GAAG,CAAC;AAAA,IACnG;AAAA,EACF,OAAO;AACL,WAAO,qBAAgB,EAAE,KAAK,QAAQ,CAAC,EAAE;AAAA,EAC3C;AAEA,QAAM,mBAAmB,SAAS,SAAS;AAE3C,SAAO,2BAAsB,mBAAmB,KAAK,EAAE,KAAK,QAAQ,CAAC;AACrE,MAAI,kBAAkB;AACpB,eAAW,EAAE,MAAM,SAAS,UAAU,SAAS,WAAW,KAAK,UAAU;AACvE,aAAO,mBAAS,IAAI,KAAK,WAAW,WAAW,EAAE;AACjD,UAAI,eAAe,QAAW;AAC5B,eAAO,gBAAW,EAAE,KAAK,YAAY,UAAU,EAAE,CAAC,EAAE;AAAA,MACtD;AACA,UAAI,MAAM,UAAU;AAClB,eAAO,gBAAW,EAAE,KAAK,aAAa,YAAY,WAAW,EAAE,CAAC,EAAE;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AAEA,MAAI,MAAM,mBAAmB,MAAM,gBAAgB,SAAS,GAAG;AAC7D,UAAM,kBACJ,MAAM,eAAe,MAAM,YAAY,SAAS,IAC5C,MAAM,YAAY,IAAI,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,IAChD;AACN,WAAO,QAAG;AACV,WAAO,WAAM,EAAE,OAAO,2BAAsB,CAAC,IAAI,EAAE,KAAK,YAAY,eAAe,GAAG,CAAC,GAAG;AAC1F,eAAW,QAAQ,MAAM,iBAAiB;AACxC,YAAM,sBAAsB,KAAK,WAAW,CAAC;AAC7C,YAAM,uBAAuB,oBAAoB,MAAM,GAAG,EAAE,MAAM;AAClE,YAAM,qBAAqB,oBAAoB,MAAM,GAAG,EAAE,IAAI,GAAG,MAAM,GAAG,EAAE;AAC5E;AAAA,QACE,mBAAS,KAAK,QAAQ,IAAI,EAAE,KAAK,MAAM,oBAAoB,KAAK,kBAAkB,GAAG,CAAC;AAAA,MACxF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,cAAI;AACb;AAKO,SAAS,wBAAwB,OAA0C;AAChF,QAAM,eAA+D,CAAC;AAEtE,aAAW,YAAY,MAAM,OAAO;AAClC,eAAW,CAAC,YAAY,KAAK,KAAK,OAAO,QAAQ,SAAS,MAAM,GAAG;AACjE,UAAI,CAAC,aAAa,UAAU,GAAG;AAC7B,qBAAa,UAAU,IAAI,EAAE,KAAK,GAAG,OAAO,EAAE;AAAA,MAChD;AACA,UAAI,CAAC,MAAM,UAAU,OAAO;AAC1B,qBAAa,UAAU,EAAE,OAAO,MAAM,SAAS;AAC/C,qBAAa,UAAU,EAAE,SAAS;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAmC,CAAC;AAC1C,aAAW,CAAC,YAAY,MAAM,KAAK,OAAO,QAAQ,YAAY,GAAG;AAC/D,aAAS,UAAU,IAAI,OAAO,QAAQ,IAAI,OAAO,MAAM,OAAO,QAAQ;AAAA,EACxE;AAEA,SAAO;AACT;AAKO,SAAS,+BACd,UACA,YACe;AACf,QAAM,SAAmB,CAAC;AAE1B,aAAW,YAAY,SAAS,OAAO;AACrC,QAAI,SAAS,OAAO,UAAU,GAAG;AAC/B,aAAO,KAAK,SAAS,OAAO,UAAU,EAAE,KAAK;AAAA,IAC/C;AAAA,EACF;AAEA,MAAI,OAAO,WAAW,EAAG,QAAO;AAEhC,QAAM,MAAM,OAAO,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC;AACpD,SAAO,MAAM,OAAO;AACtB;AAMO,SAAS,kBAAkB,OAAmC;AACnE,MAAI,CAAC,MAAM,eAAe,MAAM,YAAY,WAAW,GAAG;AACxD,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,QAAyB,CAAC;AAEhC,QAAM,gBAAgB,MAAM,cAAc,CAAC;AAC3C,QAAM,iBAAiB,MAAM,UAAU,cAAc,CAAC;AACtD,QAAM,gBAAgB,MAAM,qBAAqB,CAAC;AAElD,QAAM,cAAc,cAAc,aAAa;AAC/C,QAAM,eAAe,cAAc,cAAc;AACjD,QAAM,cAAc,cAAc,aAAa;AAE/C,QAAM,UAAU,oBAAI,IAAI;AAAA,IACtB,GAAG,OAAO,KAAK,WAAW;AAAA,IAC1B,GAAG,OAAO,KAAK,YAAY;AAAA,IAC3B,GAAG,OAAO,KAAK,WAAW;AAAA,EAC5B,CAAC;AAED,aAAW,OAAO,SAAS;AACzB,UAAM,YAAY,MAAM,YAAY,KAAK,CAAC,YAAY,IAAI,WAAW,OAAO,CAAC;AAC7E,QAAI,CAAC,UAAW;AAEhB,UAAM,eAAe,YAAY,GAAG;AACpC,UAAM,gBAAgB,aAAa,GAAG;AACtC,UAAM,eAAe,YAAY,GAAG;AAEpC,UAAM,aAAa,iBAAiB,SAAY,KAAK,UAAU,YAAY,IAAI;AAC/E,UAAM,cAAc,kBAAkB,SAAY,KAAK,UAAU,aAAa,IAAI;AAClF,UAAM,aAAa,iBAAiB,SAAY,KAAK,UAAU,YAAY,IAAI;AAE/E,UAAM,mBAAmB,MAAM,YAAY,eAAe;AAC1D,UAAM,kBAAkB,eAAe;AAEvC,QAAI,oBAAoB,iBAAiB;AACvC,YAAM,KAAK;AAAA,QACT,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU,MAAM,WAAW,cAAc;AAAA,QACzC,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS,QAAQ;AACnB,GAMG;AACD,SAAO,EAAE;AACT,SAAO,EAAE,OAAO,EAAE,MAAM,2BAA2B,CAAC,CAAC;AACrD,SAAO,EAAE;AAET,aAAW,SAAS,WAAW;AAC7B,UAAM,iBAAiB,wBAAwB,KAAK;AACpD,UAAM,WAAW,kBAAkB,KAAK;AACxC,kBAAc,EAAE,OAAO,gBAAgB,gCAAgC,UAAU,OAAO,CAAC;AACzF,WAAO,EAAE;AAAA,EACX;AAEA,QAAM,QAAQ,UAAU,CAAC,GAAG;AAC5B,QAAM,QAAQ,UAAU,CAAC,GAAG;AAE5B,QAAM,gBAAgB,mBAAmB,KAAK,CAAC,MAAM,EAAE,UAAU;AACjE,QAAM,YAAY,mBAAmB,KAAK,CAAC,MAAM,CAAC,EAAE,UAAU;AAE9D,MAAI,iBAAiB,SAAS,QAAQ,oBAAoB;AACxD,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,QAAQ,UAAU,CAAC;AACzB,YAAM,gBAAgB,MAAM,UAAU,UAAU,eAAe,MAAM,SAAS,OAAO,KAAK;AAC1F,aAAO,mBAAmB;AAC1B;AAAA,QACE,GAAG,OAAO,kBAAkB,IAAI,KAAK,+BAA+B,MAAM,IAAI,IAAI,MAAM,OAAO,GAAG,aAAa;AAAA,MACjH;AAAA,IACF,OAAO;AACL,aAAO,mBAAmB;AAC1B,aAAO,GAAG,OAAO,kBAAkB,IAAI,KAAK,qCAAqC,KAAK,EAAE;AAAA,IAC1F;AAAA,EACF,WAAW,SAAS;AAClB,WAAO,EAAE,IAAI,4CAA4C,CAAC;AAAA,EAC5D,OAAO;AACL,WAAO,yDAAyD;AAAA,EAClE;AAEA,MAAI,WAAW;AACb,WAAO,EAAE;AACT,eAAW,UAAU,oBAAoB;AACvC,UAAI,CAAC,OAAO,YAAY;AACtB,eAAO,EAAE,OAAO,8CAAoC,OAAO,IAAI,cAAc,CAAC;AAC9E,YAAI,OAAO,OAAO;AAChB,iBAAO,EAAE,IAAI,aAAa,OAAO,KAAK,EAAE,CAAC;AAAA,QAC3C;AACA,eAAO,EAAE,IAAI,uEAAuE,CAAC;AAAA,MACvF;AAAA,IACF;AAAA,EACF;AACF;;;ACpmBA;AAOA,IAAM,kBAAkB,CAAC,cAAsB;AAC7C,QAAM,MAAM,IAAI,IAAI,SAAS;AAE7B,SAAO,GAAG,IAAI,QAAQ,SAAS,IAAI,KAAK,MAAM,MAAM,EAAE,GAAG,EAAE,CAAC;AAC9D;AAWO,SAAS,uBACd,QACA,oBACkE;AAClE,QAAM,qBAAqB,sBAAsB,gBAAgB,OAAO,KAAK,GAAG;AAEhF,SAAO;AAAA,IACL,KAAK,OAAO,KAAK;AAAA,IACjB;AAAA,IACA,OAAO,OAAO,KAAK;AAAA,IACnB,SAAS,OAAO,KAAK;AAAA,IACrB,OAAO,OAAO,KAAK;AAAA,EACrB;AACF;;;AFRO,IAAM,gBAAN,MAAwC;AAAA,EAAxC;AACL,qCAAoB;AACpB,iCAAgB;AAChB,wBAAQ;AACR,wBAAQ,cAA0B,CAAC;AACnC,wBAAQ,yBAAwB;AAChC,wBAAQ;AAAA;AAAA,EAER,iBAAiB;AACf,SAAK,QAAQ,YAAY,IAAI;AAC7B,SAAK,aAAY,oBAAI,KAAK,GAAE,QAAQ;AAGpC,UAAM,SAAS,eAAe;AAC9B,QAAI,QAAQ;AACV,WAAK,UAAU,uBAAuB,QAAQ,cAAc,CAAC;AAAA,IAC/D;AAAA,EACF;AAAA,EAEA,MAAM,iBAAiB,YAAuB;AAC5C,UAAM,OAAO,WAAW,KAAK;AAC7B,QAAI,WAAW,MAAM,MAAM,aAAa,CAAC,MAAM,YAAY;AACzD;AAAA,IACF;AAIA,QAAI,CAAC,KAAK,uBAAuB;AAC/B,YAAM,wBAAwB,KAAK,WAAW,WAAW,SAAS,CAAC;AACnE,YAAM,yBAAyB,KAAK,WAAW,WAAW,aAAa,CAAC;AAExE,UAAI,OAAO,KAAK,sBAAsB,EAAE,SAAS,GAAG;AAClD,iCAAyB,wBAAwB,qBAAqB;AAAA,MACxE;AACA,WAAK,wBAAwB;AAAA,IAC/B;AAGA,QAAI,KAAK,WAAW,aAAa,CAAC,KAAK,oBAAoB;AACzD,WAAK,qBAAqB,KAAK,WAAW;AAAA,IAC5C;AAAA,EACF;AAAA,EAEA,gBAAgB,MAAgB;AAC9B,UAAM,OAAO,KAAK,KAAK;AAIvB,QAAI,CAAC,KAAK,KAAM;AAAA,EAClB;AAAA,EAEA,MAAM,kBAAkB,WAAsB;AAC5C,UAAM,OAAO,UAAU,KAAK;AAE5B,QAAI,UAAU,MAAM,MAAM,aAAa,CAAC,MAAM,YAAY;AACxD;AAAA,IACF;AAGA,QAAI,KAAK,WAAW,aAAa,CAAC,KAAK,oBAAoB;AACzD,WAAK,qBAAqB,KAAK,WAAW;AAAA,IAC5C;AAEA,UAAM,kBAAkB,QAAQ,YAAY,IAAI,IAAI,KAAK,SAAS,GAAI,EAAE,QAAQ,CAAC;AAEjF,UAAM,QAA4B,CAAC;AACnC,eAAW,QAAQ,UAAU,UAAU;AACrC,UAAI,KAAK,SAAS,OAAQ;AAE1B,YAAM,WAAW,KAAK,KAAK;AAC3B,UAAI,CAAC,UAAU,KAAM;AAErB,YAAM,KAAK;AAAA,QACT,OAAO,SAAS,KAAK;AAAA,QACrB,QAAQ,SAAS,KAAK;AAAA,QACtB,iBAAiB,SAAS,KAAK;AAAA,QAC/B,QAAQ,SAAS,KAAK;AAAA,QACtB,cAAc,SAAS,KAAK;AAAA,MAC9B,CAAC;AAAA,IACH;AAEA,UAAM,MAAM,QAAQ,IAAI;AACxB,UAAM,eAAe,UAAU,OAAO,SAAS,QAAQ,KAAK,EAAE,EAAE,QAAQ,OAAO,EAAE;AAGjF,QAAI,gBAAgB,KAAK,WAAW;AAEpC,QAAI,aAAa,KAAK,WAAW;AACjC,QAAI,KAAK,WAAW,WAAW;AAC7B,YAAM,WAAW,KAAK,WAAW,UAAU,SAAS,CAAC;AACrD,YAAM,YAAY,KAAK,WAAW,UAAU,aAAa,CAAC;AAC1D,YAAM,eAAe,cAAc,QAAQ;AAC3C,YAAM,gBAAgB,cAAc,SAAS;AAC7C,mBAAa,oBAAoB,EAAE,GAAG,cAAc,GAAG,cAAc,CAAC;AAAA,IACxE;AAEA,UAAM,oBAAoB,KAAK,WAAW,WAAW;AAErD,SAAK,WAAW,KAAK;AAAA,MACnB,SAAS,KAAK,WAAW;AAAA,MACzB,MAAM,KAAK,WAAW;AAAA,MACtB,MAAM;AAAA,MACN,UAAU,kBAAkB;AAAA,MAC5B,UAAU,iBAAiB;AAAA,MAC3B,aAAa,KAAK,WAAW;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,OAAO,KAAK,WAAW;AAAA,MACvB,OAAO,KAAK,WAAW;AAAA,MACvB;AAAA,MACA,iBAAiB,KAAK,WAAW;AAAA,MACjC,oBAAoB,KAAK,WAAW;AAAA,IACtC,CAAC;AAED,6BAAyB,WAAW,IAAI;AACxC,gCAA4B,IAAI;AAEhC,oCAAgC,WAAW,KAAK,WAAW,eAAe;AAE1E,UAAM,yBAAyB,oBAAI,IAAY;AAC/C,UAAM,6BAA6B,oBAAI,IAAoB;AAE3D,QAAI,eAAe;AACjB,iBAAW,KAAK,cAAc,OAAO;AACnC,cAAM,KAAK,mBAAmB,EAAE,OAAO,EAAE,QAAQ;AACjD,cAAMC,SAAQ,2BAA2B,IAAI,EAAE,KAAK,CAAC;AACrD,QAAAA,OAAM,KAAK,CAAC;AACZ,mCAA2B,IAAI,IAAIA,MAAK;AAAA,MAC1C;AAAA,IACF;AAEA,eAAW,QAAQ,UAAU,UAAU;AACrC,UAAI,KAAK,SAAS,OAAQ;AAC1B,sBAAgB,MAAM,4BAA4B,sBAAsB;AAAA,IAC1E;AAEA,QAAI,eAAe;AACjB,iCAA2B,eAAe,sBAAsB;AAAA,IAClE;AAEA,YAAQ,IAAI,EAAE;AAAA,EAChB;AAAA,EAEA,MAAM,aACJ,cACA,SACA,SACA;AACA,UAAM,cAAc,CAAC,QAAQ,IAAI,MAAM,QAAQ,OAAO,UAAU;AAEhE,QAAI,aAAa;AACf,cAAQ,OAAO,MAAM,gBAAgB;AAAA,IACvC;AAEA,UAAM,qBAAqB,KAAK,WAAW,IAAI,CAAC,WAAW;AAAA,MACzD,MAAM,MAAM;AAAA,MACZ,YAAY,MAAM,oBAAoB,WAAW;AAAA,MACjD,OACE,MAAM,oBAAoB,WAAW,WAAW,MAAM,mBAAmB,QAAQ;AAAA,IACrF,EAAE;AAEF,UAAM,UAAU,QAAQ,IAAI,gBAAgB;AAE5C,qBAAiB;AAAA,MACf,WAAW,KAAK;AAAA,MAChB,QAAQ,KAAK;AAAA,MACb;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AGrMA;AAAA,SAAS,oBAAoB,0BAA0B;AACvD,SAAS,8BAA8B;AACvC,SAAS,yBAAyB;AAClC;AAAA,EACE;AAAA,EACA;AAAA,EAIA;AAAA,OAGK;AAaP,IAAI;AACJ,IAAI;AACJ,IAAI;AAEJ,IAAI,wBAA8C;AAClD,IAAI,cAAc;AAElB,eAAe,2BACb,QAC8C;AAC9C,MAAI,OAAO,KAAK,iBAAiB;AAC/B,WAAO,OAAO,KAAK;AAAA,EACrB;AAEA,MAAI;AACF,UAAM,EAAE,QAAQ,aAAa,IAAI,MAAM,WAAW,QAAQ,IAAI,CAAC;AAC/D,WAAQ,aAAa,KAAK,mBAAmB;AAAA,EAC/C,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,iDAAiD,cAAc,KAAK,CAAC;AAAA,IACvE;AAAA,EACF;AACF;AAEA,eAAe,uBACb,MACA,SACgD;AAChD,MAAI;AACF,WAAO,MAAM,KAAK,OAAO;AAAA,EAC3B,SAAS,OAAO;AACd,UAAM,IAAI,cAAc,2CAA2C,cAAc,KAAK,CAAC,EAAE;AAAA,EAC3F;AACF;AAEA,SAAS,kBAAkB,YAAuD;AAChF,QAAM,UAAkC;AAAA,IACtC,mBAAmB,WAAW;AAAA,IAC9B,GAAI,WAAW,QAAQ,EAAE,kBAAkB,WAAW,MAAM,IAAI,CAAC;AAAA,EACnE;AAEA,MAAI,WAAW,OAAO;AACpB,YAAQ,gBAAgB,UAAU,WAAW,KAAK;AAAA,EACpD;AAEA,QAAM,mBAAmB;AAAA,IACvB,KAAK,GAAG,WAAW,GAAG;AAAA,IACtB;AAAA,IACA,kBAAkB;AAAA,EACpB;AAEA,QAAM,WAAW,IAAI,kBAAkB,gBAAgB;AAEvD,QAAM,YAAY,IAAI,mBAAmB,UAAU;AAAA,IACjD,cAAc;AAAA,IACd,oBAAoB;AAAA,IACpB,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,EACvB,CAAC;AAED,kBAAgB,IAAI,mBAAmB;AAAA,IACrC,UAAU,uBAAuB;AAAA,MAC/B,CAAC,cAAc,GAAG;AAAA,MAClB,CAAC,iBAAiB,GAAG;AAAA,IACvB,CAAC;AAAA,IACD,gBAAgB,CAAC,SAAS;AAAA,EAC5B,CAAC;AAED,gBAAc,cAAc,UAAU,SAAS,QAAe;AAChE;AAEA,eAAsB,oBAAoB,QAGxB;AAChB,MAAI,aAAa;AACf;AAAA,EACF;AAEA,MAAI,uBAAuB;AACzB,UAAM;AACN;AAAA,EACF;AAEA,2BAAyB,YAAY;AACnC,QAAI,CAAC,OAAO,SAAS;AACnB,oBAAc,MAAM,UAAU,SAAS,QAAe;AACtD,oBAAc;AACd;AAAA,IACF;AAEA,UAAM,aAAa,uBAAuB,OAAO,MAAM;AACvD,UAAM,OAAO,MAAM,2BAA2B,OAAO,MAAM;AAC3D,QAAI,aAAoD;AAExD,QAAI,MAAM;AACR,aAAO,OAAO,KAAK,kBAAkB;AACrC,mBAAa,MAAM,uBAAuB,MAAM;AAAA,QAC9C,SAAS,WAAW;AAAA,QACpB,OAAO,WAAW;AAAA,QAClB,KAAK,WAAW;AAAA,QAChB,OAAO,WAAW;AAAA,MACpB,CAAC;AAED,qBAAe,YAAY,YAAY;AAAA,IACzC;AAEA,sBAAkB,UAAU;AAE5B,QAAI,CAAC,MAAM;AAET,qBAAe,SAAS;AACxB,UAAI,aAAa;AACf,oBAAY,EAAE,QAAQ,YAAY,CAAC;AAAA,MACrC;AAAA,IACF;AAEA,kBAAc;AAAA,EAChB,GAAG;AAEH,MAAI;AACF,UAAM;AAAA,EACR,UAAE;AACA,4BAAwB;AAAA,EAC1B;AACF;AAEO,IAAM,QAAQ,YAAY;AAC/B,MAAI,uBAAuB;AACzB,UAAM;AAAA,EACR;AAEA,QAAM,QAAiC,CAAC;AAExC,MAAI,eAAe;AACjB,UAAM,KAAK,cAAc,WAAW,CAAC;AAAA,EACvC;AAEA,QAAM,qBAAqB,oBAAI,IAAoB;AACnD,MAAI,cAAc;AAChB,uBAAmB,IAAI,YAAY;AAAA,EACrC;AAEA,QAAM,iBAAiB,MAAM,kBAAkB;AAC/C,MAAI,gBAAgB;AAClB,uBAAmB,IAAI,cAAc;AAAA,EACvC;AAEA,aAAW,YAAY,oBAAoB;AACzC,UAAM,UAAW,SAAiB;AAClC,QAAI,OAAO,YAAY,YAAY;AACjC,YAAM;AAAA,QACJ,QAAQ,KAAK,QAAQ,EAAE,MAAM,CAAC,UAAmB;AAC/C,kBAAQ,KAAK,8CAA8C,cAAc,KAAK,CAAC;AAAA,QACjF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,MAAI,MAAM,SAAS,GAAG;AACpB,UAAM,QAAQ,IAAI,KAAK;AAAA,EACzB;AACF;AAMA,eAAsB,iCACpB,QACA,UAAiC,CAAC,GACnB;AACf,MAAI,aAAa;AACf;AAAA,EACF;AAEA,QAAM,UAAU,QAAQ,WAAW;AACnC,QAAM,oBAAoB,EAAE,SAAS,OAAO,CAAC;AAC/C;AAEA,IAAM,gBAAgB,MAAc;AAClC,MAAI,CAAC,aAAa;AAChB,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,YAAY,CAAC,MAAc,MAAmBC,aAAsB;AAC/E,MAAI,CAAC,eAAe,CAAC,aAAa;AAChC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO,cAAc,EAAE,UAAU,MAAM,MAAMA,QAAO;AACtD;AAEO,IAAM,kBAAkB,OAC7B,MACA,SACA,IACA,kBACe;AACf,QAAM,OAAO,UAAU,MAAM,SAAS,aAAa;AAEnD,SAAO,QAAQ,KAAK,MAAM,QAAQ,QAAQ,OAAO,GAAG,IAAI,GAAG,YAAY;AACrE,QAAI;AACF,YAAM,SAAS,MAAM,GAAG,IAAI;AAC5B,WAAK,UAAU,EAAE,MAAM,eAAe,GAAG,CAAC;AAC1C,aAAO;AAAA,IACT,SAAS,OAAO;AACd,WAAK,gBAAgB,KAAc;AACnC,WAAK,UAAU;AAAA,QACb,MAAM,eAAe;AAAA,QACrB,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAChE,CAAC;AACD,YAAM;AAAA,IACR,UAAE;AACA,WAAK,IAAI;AAAA,IACX;AAAA,EACF,CAAC;AACH;","names":["calculateBaselineScorerAverage","cases","context"]}
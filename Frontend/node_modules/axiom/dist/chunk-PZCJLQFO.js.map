{"version":3,"sources":["../src/otel/utils/redaction.ts","../src/otel/withSpanBaggageKey.ts","../src/otel/initAxiomAI.ts","../package.json","../src/otel/withSpan.ts","../src/otel/utils/wrapperUtils.ts","../src/otel/semconv/attributes.ts","../src/otel/semconv/eval_proposal.ts","../src/schema.ts","../src/otel/startActiveSpan.ts","../src/otel/middleware.ts","../src/otel/completionUtils.ts","../src/otel/utils/contentSanitizer.ts","../src/util/promptUtils.ts","../src/otel/utils/normalized.ts","../src/otel/streaming/aggregators.ts","../src/util/currentUnixTime.ts","../src/otel/vercel.ts","../src/otel/AxiomWrappedLanguageModelV1.ts","../src/otel/AxiomWrappedLanguageModelV2.ts","../src/app-scope.ts","../src/evals/context/global-flags.ts","../src/evals/context/storage.ts","../src/evals/context/manager.ts","../src/validate-flags.ts","../src/cli/utils/format-zod-errors.ts","../src/util/dot-path.ts","../src/util/zod-internals.ts","../src/util/deep-partial-schema.ts","../src/otel/utils/to-otel-attribute.ts","../src/otel/index.ts"],"sourcesContent":["import { context, propagation, type Baggage, type Span } from '@opentelemetry/api';\nimport { WITHSPAN_REDACTION_POLICY_KEY } from '../withSpanBaggageKey';\n\ntype CaptureMessageContent = 'full' | 'off';\n\nexport type AxiomAIRedactionPolicy = {\n  captureMessageContent?: CaptureMessageContent;\n  mirrorToolPayloadOnToolSpan?: boolean;\n};\n\nexport const RedactionPolicy = {\n  /**\n   * Includes message content on chat spans, and mirrors tool\n   * payload on tool spans for more convenient querying.\n   */\n  AxiomDefault: {\n    captureMessageContent: 'full',\n    mirrorToolPayloadOnToolSpan: true,\n  },\n  /**\n   * Redacts message content on chat spans, and does not put\n   * tool payload on tool spans.\n   */\n  OpenTelemetryDefault: {\n    captureMessageContent: 'off',\n    mirrorToolPayloadOnToolSpan: false,\n  },\n} as const satisfies Record<string, AxiomAIRedactionPolicy>;\n\n// Global key to store redaction policy across all execution contexts\nexport const AXIOM_AI_REDACTION_KEY = Symbol.for('__axiom_ai_redaction__');\n\n/**\n * Get the globally stored redaction policy\n * @returns The global redaction policy or undefined if not set\n */\nfunction getGlobalRedactionPolicy(): AxiomAIRedactionPolicy | undefined {\n  return (globalThis as any)[AXIOM_AI_REDACTION_KEY];\n}\n\n/**\n * Resolves the effective redaction policy by merging global and per-call policies.\n * Per-call policies take precedence over global policies.\n *\n * @param globalPolicy - The global redaction policy from initAxiomAI\n * @param localPolicy - The per-call redaction policy from withSpan or middleware\n * @returns The effective redaction policy with all fields resolved\n */\nfunction getEffectiveRedactionPolicy(\n  globalPolicy?: AxiomAIRedactionPolicy,\n  localPolicy?: AxiomAIRedactionPolicy,\n): AxiomAIRedactionPolicy {\n  // Per-call policy overrides global policy, with defaults\n  return {\n    captureMessageContent:\n      localPolicy?.captureMessageContent ??\n      globalPolicy?.captureMessageContent ??\n      RedactionPolicy.AxiomDefault.captureMessageContent,\n    mirrorToolPayloadOnToolSpan:\n      localPolicy?.mirrorToolPayloadOnToolSpan ??\n      globalPolicy?.mirrorToolPayloadOnToolSpan ??\n      RedactionPolicy.AxiomDefault.mirrorToolPayloadOnToolSpan,\n  };\n}\n\n/**\n * Get the active redaction policy\n */\nexport function getRedactionPolicy() {\n  return getEffectiveRedactionPolicy(getGlobalRedactionPolicy(), getPerCallRedactionPolicy());\n}\n\n/**\n * Conditionally sets a span attribute based on the capture message content policy.\n * When policy is 'off', the attribute is not set at all.\n *\n * @param span - The OpenTelemetry span to set the attribute on\n * @param attribute - The attribute name/key\n * @param value - The attribute value\n * @param captureMessageContent - The capture policy ('full' sets attribute, 'off' skips it)\n */\nexport function handleMaybeRedactedAttribute(\n  span: Span,\n  attribute: string,\n  value: any,\n  captureMessageContent?: CaptureMessageContent,\n): void {\n  if (captureMessageContent === 'full') {\n    span.setAttribute(attribute, value);\n  }\n\n  // For 'off', don't set the attribute at all\n  // Future: Could add callback-based redaction here\n}\n\n/**\n * Extracts the per-call redaction policy from OpenTelemetry baggage context.\n * This allows middleware and tools to access redaction policies passed via withSpan.\n *\n * @returns The per-call redaction policy or undefined if not set\n */\nfunction getPerCallRedactionPolicy(): AxiomAIRedactionPolicy | undefined {\n  const baggage: Baggage = propagation.getBaggage(context.active()) || propagation.createBaggage();\n  const serializedPolicy = baggage.getEntry(WITHSPAN_REDACTION_POLICY_KEY)?.value;\n\n  if (!serializedPolicy) {\n    return undefined;\n  }\n\n  try {\n    return JSON.parse(serializedPolicy) as AxiomAIRedactionPolicy;\n  } catch (error) {\n    console.warn('[AxiomAI] Failed to parse redaction policy from baggage:', error);\n    return undefined;\n  }\n}\n","/**\n * We need a way to know that we're inside `withSpan`\n * Because we don't own `generateText` and similar functions,\n * we use OTel Baggage to propagate this information. Another\n * consideration might be to use AsyncLocalStorage in Node and\n * some kind of KV in workerd.\n */\nexport const WITHSPAN_BAGGAGE_KEY = '__withspan_gen_ai_call';\nexport const WITHSPAN_REDACTION_POLICY_KEY = '__withspan_redaction_policy';\n","import type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport packageJson from '../../package.json';\nimport { AXIOM_AI_REDACTION_KEY, type AxiomAIRedactionPolicy } from './utils/redaction';\n\n// Global key to store tracer scope information across all execution contexts\nconst AXIOM_AI_SCOPE_KEY = Symbol.for('__axiom_ai_scope__');\n\ninterface TracerScope {\n  name: string;\n  version?: string;\n}\n\n/**\n * Extract scope information from a tracer, with fallback to package.json\n */\nfunction extractTracerScope(tracer: Tracer): TracerScope {\n  const tracerAny = tracer as any;\n\n  // Guard access to private fields with optional chaining\n  // Note: These are internal OTEL fields that may change in future versions\n  // _instrumentationScope is modern, instrumentationLibrary is legacy (<1.16)\n  const name =\n    tracerAny._instrumentationScope?.name ||\n    tracerAny.instrumentationLibrary?.name ||\n    packageJson.name;\n\n  const version =\n    tracerAny._instrumentationScope?.version ||\n    tracerAny.instrumentationLibrary?.version ||\n    packageJson.version;\n\n  return { name, version };\n}\n\n/**\n * Register this in your `instrumentation.ts` to set up axiom.\n * This function stores the tracer's scope information globally to enable Context Propagation\n * and Instrumentation Scope. The tracer will be available across all execution contexts including Next.js.\n *\n * This function is idempotent - calling it multiple times with the same scope has no additional cost.\n *\n * @param config\n * @param config.tracer - The tracer that you are using in your application.\n * @param config.redactionPolicy - Optional redaction policy to control what data is captured in spans.\n */\nexport function initAxiomAI(config: { tracer: Tracer; redactionPolicy?: AxiomAIRedactionPolicy }) {\n  const newScope = extractTracerScope(config.tracer);\n  const existingScope = (globalThis as any)[AXIOM_AI_SCOPE_KEY] as TracerScope | undefined;\n\n  // Check if already initialized with same scope (idempotent behavior)\n  if (\n    existingScope &&\n    existingScope.name === newScope.name &&\n    existingScope.version === newScope.version\n  ) {\n    return;\n  }\n\n  // Warn about double initialization with different scopes\n  if (existingScope) {\n    console.warn(\n      '[AxiomAI] initAxiomAI() called multiple times with different scopes. ' +\n        `Previous: ${existingScope.name}@${existingScope.version}, ` +\n        `New: ${newScope.name}@${newScope.version}`,\n    );\n  }\n\n  // Store scope information globally (works across Next.js contexts)\n  (globalThis as any)[AXIOM_AI_SCOPE_KEY] = newScope;\n\n  // Store redaction policy globally if provided\n  if (config.redactionPolicy) {\n    (globalThis as any)[AXIOM_AI_REDACTION_KEY] = config.redactionPolicy;\n  }\n}\n\n/**\n * Get a tracer using the globally stored scope information\n * Fall back to package.json defaults if not set\n */\nexport function getGlobalTracer(): Tracer {\n  // Get stored scope information or fall back to package defaults\n  const scope = (globalThis as any)[AXIOM_AI_SCOPE_KEY] as TracerScope | undefined;\n\n  // Warn if initAxiomAI was never called\n  if (!scope) {\n    const isDebug = process.env.AXIOM_DEBUG === 'true';\n    if (!isDebug) {\n      console.warn(\n        '[AxiomAI] AXIOM_AI_SCOPE_KEY is undefined. This probably means that ' +\n          'initAxiomAI() was never called. ' +\n          'Make sure to call initAxiomAI({ tracer }) in your instrumentation setup.',\n      );\n    }\n  }\n\n  let { name, version } = scope || { name: packageJson.name, version: packageJson.version };\n\n  if (!name || !version) {\n    name = packageJson.name;\n    version = packageJson.version;\n    if (!name || !version) {\n      name = 'axiom';\n      version = 'unknown';\n    }\n  }\n\n  // Use OpenTelemetry's standard global provider mechanism\n  return trace.getTracer(name, version);\n}\n\n/**\n * Reset AxiomAI configuration (useful for testing)\n */\nexport function resetAxiomAI() {\n  (globalThis as any)[AXIOM_AI_SCOPE_KEY] = undefined;\n  (globalThis as any)[AXIOM_AI_REDACTION_KEY] = undefined;\n}\n","{\n  \"name\": \"axiom\",\n  \"version\": \"0.37.0\",\n  \"type\": \"module\",\n  \"author\": \"Axiom, Inc.\",\n  \"contributors\": [\n    \"Islam Shehata <islam@axiom.co>\",\n    \"Chris Ehrlich <chris@axiom.co>\",\n    \"Gabriel de Andrade <gabriel@axiom.co>\"\n  ],\n  \"scripts\": {\n    \"dev\": \"tsup --watch\",\n    \"build\": \"tsup && chmod +x dist/bin.js\",\n    \"format\": \"prettier --write .\",\n    \"format:check\": \"prettier --check .\",\n    \"lint\": \"eslint './**/*.{js,ts}'\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest --watch\",\n    \"publint\": \"npx publint\"\n  },\n  \"types\": \"./dist/index.d.ts\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"bin\": {\n    \"axiom\": \"./dist/bin.js\"\n  },\n  \"exports\": {\n    \"./ai\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.ts\",\n        \"default\": \"./dist/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/index.d.cts\",\n        \"default\": \"./dist/index.cjs\"\n      }\n    },\n    \"./ai/evals\": {\n      \"import\": {\n        \"types\": \"./dist/evals.d.ts\",\n        \"default\": \"./dist/evals.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/evals.d.cts\",\n        \"default\": \"./dist/evals.cjs\"\n      }\n    },\n    \"./ai/config\": {\n      \"import\": {\n        \"types\": \"./dist/config.d.ts\",\n        \"default\": \"./dist/config.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/config.d.cts\",\n        \"default\": \"./dist/config.cjs\"\n      }\n    },\n    \"./ai/feedback\": {\n      \"import\": {\n        \"types\": \"./dist/feedback.d.ts\",\n        \"default\": \"./dist/feedback.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/feedback.d.cts\",\n        \"default\": \"./dist/feedback.cjs\"\n      }\n    }\n  },\n  \"keywords\": [\n    \"axiom\",\n    \"logging\",\n    \"ai\",\n    \"otel\",\n    \"opentelemetry\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/axiomhq/ai.git\",\n    \"directory\": \"packages/ai\"\n  },\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@next/env\": \"^15.4.2\",\n    \"@opentelemetry/auto-instrumentations-node\": \"^0.60.1\",\n    \"@opentelemetry/context-async-hooks\": \"^2.0.1\",\n    \"@opentelemetry/exporter-trace-otlp-http\": \"^0.202.0\",\n    \"@opentelemetry/resources\": \"^2.0.1\",\n    \"@opentelemetry/sdk-trace-node\": \"^2.0.1\",\n    \"@opentelemetry/semantic-conventions\": \"^1.37.0\",\n    \"@sinclair/typebox\": \"^0.34.37\",\n    \"c12\": \"^2.0.4\",\n    \"commander\": \"^14.0.0\",\n    \"defu\": \"^6.1.4\",\n    \"handlebars\": \"^4.7.8\",\n    \"nanoid\": \"^5.1.5\",\n    \"open\": \"^10.1.0\",\n    \"vite-tsconfig-paths\": \"^5.1.4\",\n    \"vitest\": \"^4.0.0\"\n  },\n  \"peerDependencies\": {\n    \"@opentelemetry/api\": \"^1.9.0\",\n    \"zod\": \"^3.25.0 || ^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@ai-sdk/anthropicv1\": \"npm:@ai-sdk/anthropic@^1.2.12\",\n    \"@ai-sdk/anthropicv2\": \"npm:@ai-sdk/anthropic@^2.0.44\",\n    \"@ai-sdk/openaiv1\": \"npm:@ai-sdk/openai@^1.3.24\",\n    \"@ai-sdk/openaiv2\": \"npm:@ai-sdk/openai@^2.0.67\",\n    \"@ai-sdk/providerv1\": \"npm:@ai-sdk/provider@^1.1.3\",\n    \"@ai-sdk/providerv2\": \"npm:@ai-sdk/provider@^2.0.0\",\n    \"@opentelemetry/api\": \"^1.9.0\",\n    \"@opentelemetry/core\": \"^2.0.1\",\n    \"@opentelemetry/sdk-trace-base\": \"^2.0.1\",\n    \"@opentelemetry/sdk-trace-node\": \"^2.0.1\",\n    \"@repo/eslint-config\": \"workspace:*\",\n    \"@types/node\": \"^22.15.29\",\n    \"@vitest/coverage-v8\": \"^4.0.0\",\n    \"aiv4\": \"npm:ai@^4.3.19\",\n    \"aiv5\": \"npm:ai@^5.0.93\",\n    \"esbuild\": \"^0.25.8\",\n    \"eslint\": \"catalog:\",\n    \"msw\": \"^2.12.2\",\n    \"prettier\": \"catalog:\",\n    \"tinyrainbow\": \"^2.0.0\",\n    \"tsup\": \"catalog:\",\n    \"typescript\": \"catalog:\",\n    \"vitest\": \"catalog:\",\n    \"zod\": \"catalog:\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"packageManager\": \"pnpm@10.16.1\"\n}\n","import {\n  context,\n  propagation,\n  trace,\n  SpanStatusCode,\n  type Span,\n  type Baggage,\n  type Tracer,\n} from '@opentelemetry/api';\n\nimport { WITHSPAN_BAGGAGE_KEY, WITHSPAN_REDACTION_POLICY_KEY } from './withSpanBaggageKey';\nimport { getTracer } from './utils/wrapperUtils';\nimport type { AxiomAIRedactionPolicy } from './utils/redaction';\nimport type { ValidateName } from '../util/name-validation';\nimport { isValidName } from '../util/name-validation-runtime';\n\n/**\n * Metadata for categorizing and tracking spans within the AI application.\n */\ntype WithSpanMeta = {\n  /** High-level capability being performed (e.g., 'text_generation', 'chat', 'analysis') */\n  capability: string;\n  /** Specific step within the capability (e.g., 'generate_response', 'summarize', 'extract') */\n  step: string;\n};\n\n/**\n * Wrap Vercel AI SDK functions like `generateText` and `streamText` in an OpenTelemetry span.\n *\n * Automatically detects and handles different response types:\n * - **Response streams**: Keeps span alive during entire stream consumption\n * - **Streaming objects**: Warns about incorrect usage patterns\n * - **Regular objects**: Ends span immediately after function completion\n *\n * The span name will be updated by the AI SDK middleware from 'chat'\n * to a model-specific name like 'chat gpt-4o-mini' when used with wrapped models.\n *\n * @param meta - Span metadata for categorization and tracking\n * @param meta.capability - High-level capability being performed (e.g., 'customer_support', 'meeting_summarizer')\n * @param meta.step - Specific step within the capability (e.g., 'categorize_message', 'transcribe_audio')\n * @param fn - Function to execute within the span context. Receives the span as a parameter so you can add additional attributes.\n * @param opts - Optional configuration\n * @param opts.tracer - Custom OpenTelemetry tracer instance. Defaults to the tracer provided by `initAxiomAI`.\n * @param opts.timeoutMs - Timeout for abandoned streams. Defaults to 600,000 (10 minutes).\n * @param opts.redactionPolicy - Optional redaction policy to override global policy for this span.\n *\n * @returns Promise that resolves to the same value as the wrapped function\n *\n * @example \n * // Non-streaming usage\n * const result = await withSpan(\n *   { capability: 'text_generation', step: 'generate' },\n *   async (span) => {\n *     span.setAttribute('user.id', userId); // can set attributes on the span\n *     const result = await generateObject({ model, prompt });\n *     // can do something with the result here, eg set additional attributes\n *     return result\n *   }\n * );\n *\n * @example \n * // Streaming usage with `@ai-sdk/react` in the frontend\n * ```ts\n * const response = withSpan(\n *   { capability: 'chat', step: 'stream_chat' },\n *   async (span) => {\n *     span.setAttribute('user.id', userId);\n *     const result = streamText({ model, messages });\n *     return result.toUIMessageStreamResponse();\n *   }\n * );\n * ```\n * \n * @example \n * // Streaming usage with express\n * ```ts\n * await withSpan(\n *   { capability: 'chat', step: 'stream_chat' },\n *   async (span) => {\n *     span.setAttribute('user.id', userId);\n *\n *     const { textStream } = streamText({ model, messages });\n *\n *     // Keep span open during entire stream consumption\n *     for await (const chunk of textStream) {\n *       res.write(chunk);\n *     }\n *   }\n * );\n\n * res.end();\n * ```\n */\nexport function withSpan<Return, Capability extends string = string, Step extends string = string>(\n  meta: WithSpanMeta & {\n    capability: ValidateName<Capability>;\n    step: ValidateName<Step>;\n  },\n  fn: (span: Span) => Promise<Return>,\n  opts?: {\n    tracer?: Tracer;\n    timeoutMs?: number;\n    redactionPolicy?: AxiomAIRedactionPolicy;\n  },\n): Promise<Return> {\n  const tracer = opts?.tracer ?? getTracer();\n\n  // Create span manually to control its lifecycle\n  const span = tracer.startSpan('chat');\n  const spanContext = trace.setSpan(context.active(), span);\n\n  return context.with(spanContext, async () => {\n    const capabilityValidation = isValidName(meta.capability);\n    if (!capabilityValidation.valid) {\n      console.warn(`[AxiomAI] Invalid capability name: ${capabilityValidation.error}. `);\n    }\n\n    const stepValidation = isValidName(meta.step);\n    if (!stepValidation.valid) {\n      console.warn(`[AxiomAI] Invalid step name: ${stepValidation.error}. `);\n    }\n\n    if (!span.isRecording()) {\n      const provider = trace.getTracerProvider();\n      const providerIsNoOp = provider.constructor.name === 'NoopTracerProvider';\n\n      // We don't warn for other non-recording cases (sampling=DROP, etc.) as those may be intentional\n      if (providerIsNoOp) {\n        const isDebug = process.env.AXIOM_DEBUG === 'true';\n        if (!isDebug) {\n          console.warn(\n            '[AxiomAI] No TracerProvider registered - spans are no-op. Make sure to call initAxiomAI() after your OpenTelemetry SDK has started.',\n          );\n        }\n      }\n    }\n\n    const bag: Baggage = propagation.createBaggage({\n      capability: { value: meta.capability },\n      step: { value: meta.step },\n      // TODO: maybe we can just check the active span name instead?\n      [WITHSPAN_BAGGAGE_KEY]: { value: 'true' }, // Mark that we're inside withSpan\n      // Store serialized redaction policy if provided\n      ...(opts?.redactionPolicy && {\n        [WITHSPAN_REDACTION_POLICY_KEY]: { value: JSON.stringify(opts.redactionPolicy) },\n      }),\n    });\n\n    const ctx = propagation.setBaggage(context.active(), bag);\n\n    let spanEnded = false;\n    const safeEndSpan = () => {\n      if (!spanEnded) {\n        spanEnded = true;\n        span.end();\n      }\n    };\n\n    // Timeout fallback for abandoned streams\n    const timeoutMs = opts?.timeoutMs ?? 600_000; // 10 minutes default\n    const timeoutId = setTimeout(() => {\n      safeEndSpan();\n    }, timeoutMs);\n\n    try {\n      const result = await context.with(ctx, () => fn(span));\n\n      // Auto-detect Response streams and keep span alive during consumption\n      if (result instanceof Response && result.body) {\n        // Check if body is already locked\n        if (result.body.locked) {\n          console.warn('[AxiomAI] Response body is already locked, cannot instrument stream');\n          clearTimeout(timeoutId);\n          safeEndSpan();\n          return result;\n        }\n\n        const originalReader = result.body.getReader();\n        const wrappedStream = new ReadableStream({\n          async pull(controller) {\n            try {\n              const { value, done } = await context.with(ctx, () => originalReader.read());\n              if (done) {\n                originalReader.releaseLock?.();\n                clearTimeout(timeoutId);\n                span.setStatus({ code: SpanStatusCode.OK });\n                safeEndSpan();\n                controller.close();\n              } else {\n                controller.enqueue(value);\n              }\n            } catch (err) {\n              originalReader.releaseLock?.();\n              clearTimeout(timeoutId);\n              span.recordException(err as Error);\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: err instanceof Error ? err.message : String(err),\n              });\n              safeEndSpan();\n              controller.error(err);\n            }\n          },\n          async cancel(reason: unknown) {\n            try {\n              originalReader.releaseLock?.();\n              clearTimeout(timeoutId);\n              if (reason instanceof Error) {\n                span.recordException(reason);\n              } else if (reason) {\n                span.recordException({ message: String(reason), name: 'CancelError' });\n              }\n              span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: reason instanceof Error ? reason.message : String(reason),\n              });\n              safeEndSpan();\n              await originalReader.cancel(reason);\n            } catch (_err) {\n              // Ignore cancel errors\n            }\n          },\n        });\n\n        return new Response(wrappedStream, {\n          status: result.status,\n          statusText: result.statusText,\n          headers: result.headers,\n        }) as Return;\n      }\n\n      // Auto-detect Vercel AI SDK streaming objects (streamText returns object with textStream)\n      if (result && typeof result === 'object' && 'textStream' in result) {\n        console.warn(\n          '[AxiomAI] Detected streaming object with textStream. For proper span lifecycle, call .toUIMessageStreamResponse() or similar inside withSpan, not after.',\n        );\n        clearTimeout(timeoutId);\n        safeEndSpan(); // End span immediately to prevent memory leak\n        return result;\n      }\n\n      // Non-stream path: end span immediately\n      clearTimeout(timeoutId);\n      span.setStatus({ code: SpanStatusCode.OK });\n      safeEndSpan();\n      return result;\n    } catch (err) {\n      clearTimeout(timeoutId);\n      span.recordException(err as Error);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err instanceof Error ? err.message : String(err),\n      });\n      safeEndSpan();\n      throw err;\n    }\n  });\n}\n","import {\n  trace,\n  context,\n  propagation,\n  type Span,\n  type Tracer,\n  SpanStatusCode,\n  type AttributeValue,\n} from '@opentelemetry/api';\nimport { Attr } from '../semconv/attributes';\nimport { SCHEMA_URL } from '../../schema';\nimport { WITHSPAN_BAGGAGE_KEY } from '../withSpanBaggageKey';\nimport { createStartActiveSpan } from '../startActiveSpan';\n\nimport { getGlobalTracer } from '../initAxiomAI';\nimport packageJson from '../../../package.json';\nimport type { OpenAIMessage } from '../vercelTypes';\nimport type { LanguageModelV2Prompt } from '@ai-sdk/providerv2';\n\n/**\n * Common span context discriminated union for V1 and V2\n */\ntype GenAiSpanContext =\n  | {\n      version: 'v1';\n      originalPrompt: OpenAIMessage[];\n      rawCall?: {\n        rawPrompt?: unknown[];\n        rawSettings?: unknown;\n      };\n    }\n  | {\n      version: 'v2';\n      originalPrompt: OpenAIMessage[];\n      originalV2Prompt?: LanguageModelV2Prompt;\n    };\n\nexport type GenAiSpanContextV1 = Extract<GenAiSpanContext, { version: 'v1' }>;\nexport type GenAiSpanContextV2 = Extract<GenAiSpanContext, { version: 'v2' }>;\n\n/**\n * SpanLease represents ownership of a span's lifecycle\n * - owned: true means the middleware created the span and must end it\n * - owned: false means the span is owned by withSpan and middleware must NOT end it\n */\nexport interface SpanLease {\n  owned: boolean;\n  end: () => void;\n}\n\n/**\n * Safely converts a value to a number, handling string inputs from providers.\n * Some AI providers may return token counts as strings instead of numbers.\n *\n * @returns The numeric value, or undefined if the input is not a valid number\n */\nexport function ensureNumber(value: unknown): number | undefined {\n  const v =\n    typeof value === 'number' ? value : typeof value === 'string' ? Number(value) : undefined;\n  if (Number.isNaN(v)) return undefined;\n  if (v === Infinity || v === -Infinity) return undefined;\n  return v;\n}\n\n/**\n * Classifies errors into low-cardinality types for OpenTelemetry error.type attribute\n * Reference: OTel spec ยง 7.22.5 for error.type guidelines\n *\n * Uses explicit mapping for useful error types, avoiding generic built-in errors\n * that are not actionable for observability dashboards.\n *\n * @returns string for actionable error types, undefined for unclassifiable errors\n */\nfunction classifyError(err: unknown): string | undefined {\n  if (err == null) return undefined;\n\n  if (err instanceof Error) {\n    const name = err.name.toLowerCase();\n\n    // Explicit mapping for actionable error types\n    if (name.includes('timeout')) return 'timeout';\n    if (name.includes('abort')) return 'timeout'; // AbortError often means timeout\n    if (name.includes('network') || name.includes('fetch')) return 'network';\n    if (name.includes('validation')) return 'validation';\n    if (name.includes('auth')) return 'authentication';\n    if (name.includes('parse') || name.includes('json')) return 'parsing';\n    if (name.includes('permission') || name.includes('forbidden')) return 'authorization';\n    if (name.includes('rate') && name.includes('limit')) return 'rate_limit';\n    if (name.includes('quota') || name.includes('limit')) return 'quota_exceeded';\n\n    // Skip generic built-in errors (TypeError, ReferenceError, etc.)\n    // They're not useful for observability dashboards\n    return undefined;\n  }\n\n  return undefined; // Handles primitives thrown as errors\n}\n\n/**\n * Classifies tool-specific errors using duck-typing for cross-vendor compatibility\n * Handles node-fetch version differences and external API error patterns\n *\n * @param err The error to classify\n * @param span The span to set error attributes on\n */\nexport function classifyToolError(err: unknown, span: Span): void {\n  // Enhanced error handling for OpenTelemetry compliance\n  if (err instanceof Error) {\n    span.recordException(err); // Error objects are compatible with Exception interface\n  } else {\n    // Convert primitives to compatible format\n    span.recordException({\n      message: String(err),\n      name: 'UnknownError',\n    });\n  }\n\n  span.setStatus({\n    code: SpanStatusCode.ERROR,\n    message: err instanceof Error ? err.message : String(err),\n  });\n\n  let errorType = 'unknown';\n  let statusCode: string | number | undefined;\n\n  // Duck-type check for common error patterns (don't rely on inheritance)\n  if (err && typeof err === 'object') {\n    const errObj = err as any;\n    const name = errObj.name?.toLowerCase() || '';\n    const message = errObj.message?.toLowerCase() || '';\n\n    if (name.includes('timeout') || name.includes('abort') || message.includes('timeout')) {\n      errorType = 'timeout';\n    } else if (\n      name.includes('validation') ||\n      errObj.code === 'VALIDATION_ERROR' ||\n      message.includes('validation')\n    ) {\n      errorType = 'validation';\n    } else if (\n      name.includes('fetch') ||\n      name.includes('network') ||\n      message.includes('network') ||\n      message.includes('fetch failed')\n    ) {\n      errorType = 'network';\n      // Handle both node-fetch v2 (.code) and v3 (.status) patterns\n      statusCode = errObj.status || errObj.code;\n    } else if (\n      name.includes('auth') ||\n      message.includes('auth') ||\n      message.includes('unauthorized')\n    ) {\n      errorType = 'authentication';\n    } else if (\n      name.includes('permission') ||\n      name.includes('forbidden') ||\n      message.includes('forbidden')\n    ) {\n      errorType = 'authorization';\n    } else if (\n      name.includes('rate') &&\n      (name.includes('limit') || message.includes('rate limit'))\n    ) {\n      errorType = 'rate_limit';\n    } else if (\n      name.includes('quota') ||\n      message.includes('quota') ||\n      message.includes('limit exceeded')\n    ) {\n      errorType = 'quota_exceeded';\n    } else if (\n      name.includes('parse') ||\n      name.includes('json') ||\n      message.includes('json') ||\n      message.includes('parse')\n    ) {\n      errorType = 'parsing';\n    }\n  }\n\n  // MANDATORY: Standard OpenTelemetry error attributes\n  span.setAttribute(Attr.Error.Type, errorType);\n  if (err instanceof Error && err.message) {\n    span.setAttribute(Attr.Error.Message, err.message);\n  }\n\n  // Standard HTTP attributes for network errors\n  if (statusCode !== undefined) {\n    span.setAttribute(Attr.HTTP.Response.StatusCode, statusCode as AttributeValue);\n  }\n}\n\n/**\n * Check if the current tracer provider is a no-op\n * Uses safer detection that works with bundling/minification\n */\nfunction isNoOpTracerProvider(): boolean {\n  const provider = trace.getTracerProvider();\n\n  // Check constructor name (may fail with bundling/minification)\n  if (provider.constructor.name === 'NoopTracerProvider') {\n    return true;\n  }\n\n  // Check if getTracer method exists before calling it (for test mocks)\n  if (typeof (provider as any).getTracer !== 'function') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the appropriate tracer instance using global scope or fallbacks\n */\nexport function getTracer(): Tracer {\n  const tracer = getGlobalTracer();\n\n  if (isNoOpTracerProvider()) {\n    const isDebug = process.env.AXIOM_DEBUG === 'true';\n    if (!isDebug) {\n      console.warn(\n        '[AxiomAI] No TracerProvider registered - spans will be no-op. ' +\n          'Make sure to call initAxiomAI() after your OpenTelemetry SDK has started (sdk.start()).',\n      );\n    }\n  }\n\n  return tracer;\n}\n\n/**\n * Creates a standardized span name for GenAI operations\n */\nfunction createGenAISpanName(operation: string, suffix?: string): string {\n  return suffix ? `${operation} ${suffix}` : operation;\n}\n\n/**\n * Sets common scope attributes on a span from baggage\n */\nexport function setScopeAttributes(span: Span): void {\n  const bag = propagation.getActiveBaggage();\n\n  if (bag) {\n    const capability = bag.getEntry('capability')?.value;\n    if (capability) {\n      span.setAttribute(Attr.GenAI.Capability.Name, capability);\n    }\n\n    const step = bag.getEntry('step')?.value;\n    if (step) {\n      span.setAttribute(Attr.GenAI.Step.Name, step);\n    }\n  }\n}\n\n/**\n * Sets Axiom-specific base attributes on a span\n */\nexport function setAxiomBaseAttributes(span: Span): void {\n  span.setAttributes({\n    [Attr.Axiom.GenAI.SchemaURL]: SCHEMA_URL,\n    [Attr.Axiom.GenAI.SDK.Name]: packageJson.name,\n    [Attr.Axiom.GenAI.SDK.Version]: packageJson.version,\n  });\n}\n\n/**\n * Sets common base attributes on a span\n */\nexport function setBaseAttributes(span: Span, provider: string, modelId: string): void {\n  span.setAttributes({\n    [Attr.GenAI.Operation.Name]: Attr.GenAI.Operation.Name_Values.Chat,\n    [Attr.GenAI.Request.Model]: modelId,\n  });\n\n  const systemValue = mapVercelSDKProviderToOTelProvider(provider);\n  if (systemValue) {\n    span.setAttribute(Attr.GenAI.Provider.Name, systemValue);\n  }\n\n  setAxiomBaseAttributes(span);\n}\n\n/**\n * Sets common request parameter attributes on a span\n */\nexport function setRequestParameterAttributes(\n  span: Span,\n  params: {\n    maxTokens?: number;\n    frequencyPenalty?: number;\n    presencePenalty?: number;\n    temperature?: number;\n    topP?: number;\n    topK?: number;\n    seed?: number;\n    stopSequences?: string[];\n  },\n): void {\n  const {\n    maxTokens,\n    frequencyPenalty,\n    presencePenalty,\n    temperature,\n    topP,\n    topK,\n    seed,\n    stopSequences,\n  } = params;\n\n  if (maxTokens !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.MaxTokens, maxTokens);\n  }\n  if (frequencyPenalty !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.FrequencyPenalty, frequencyPenalty);\n  }\n  if (presencePenalty !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.PresencePenalty, presencePenalty);\n  }\n  if (temperature !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.Temperature, temperature);\n  }\n  if (topP !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.TopP, topP);\n  }\n  if (topK !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.TopK, topK);\n  }\n  if (seed !== undefined) {\n    span.setAttribute(Attr.GenAI.Request.Seed, seed);\n  }\n  if (stopSequences && stopSequences.length > 0) {\n    span.setAttribute(Attr.GenAI.Request.StopSequences, JSON.stringify(stopSequences));\n  }\n}\n\n/**\n * Creates a child span for stream processing\n * This provides granular visibility into stream consumption phases\n */\nexport function createStreamChildSpan(parentSpan: Span, operationName: string): Span {\n  const tracer = getTracer();\n\n  // Create child span by setting parent context\n  const ctx = context.active();\n  const spanContext = trace.setSpan(ctx, parentSpan);\n  const childSpan = tracer.startSpan(operationName, undefined, spanContext);\n\n  return childSpan;\n}\n\n/**\n * Records an error on a span with proper classification and attributes\n * Consolidates all error handling logic in one place\n */\nfunction recordSpanError(span: Span, err: unknown): void {\n  // Enhanced error handling for OpenTelemetry compliance\n  if (err instanceof Error) {\n    span.recordException(err);\n  } else {\n    span.recordException({\n      message: String(err),\n      name: 'UnknownError',\n    });\n  }\n\n  span.setStatus({\n    code: SpanStatusCode.ERROR,\n    message: err instanceof Error ? err.message : String(err),\n  });\n\n  // MANDATORY: Add OpenTelemetry error attributes for cross-vendor compatibility\n  const errorType = classifyError(err);\n  span.setAttribute(Attr.Error.Type, errorType ?? 'unknown');\n\n  // OPTIONAL: Add human-readable error message\n  if (err instanceof Error && err.message) {\n    span.setAttribute(Attr.Error.Message, err.message);\n  }\n\n  // For Vercel AI SDK specific errors, add HTTP status if available\n  if (err && typeof err === 'object' && 'status' in err) {\n    span.setAttribute(Attr.HTTP.Response.StatusCode, err.status as AttributeValue);\n  }\n}\n\n/**\n * Common span handling logic for both V1 and V2\n * Returns a SpanLease that indicates whether the middleware owns the span\n */\nexport async function withSpanHandling<T>(\n  modelId: string,\n  operation: (span: Span, context: GenAiSpanContext, lease: SpanLease) => Promise<T>,\n  options?: { streaming?: boolean; version?: 'v1' | 'v2' },\n): Promise<T> {\n  const bag = propagation.getActiveBaggage();\n  const isWithinWithSpan = bag?.getEntry(WITHSPAN_BAGGAGE_KEY)?.value === 'true';\n\n  const spanContext: GenAiSpanContext =\n    options?.version === 'v2'\n      ? { version: 'v2', originalPrompt: [], originalV2Prompt: undefined }\n      : { version: 'v1', originalPrompt: [], rawCall: undefined };\n\n  const name = createGenAISpanName(Attr.GenAI.Operation.Name_Values.Chat, modelId);\n\n  if (isWithinWithSpan) {\n    // Reuse existing span created by withSpan - we don't own it\n    const activeSpan = trace.getActiveSpan();\n    if (!activeSpan) {\n      throw new Error('Expected active span when within withSpan');\n    }\n    activeSpan.updateName(name);\n\n    const lease: SpanLease = {\n      owned: false,\n      end: () => {}, // No-op: we don't own this span\n    };\n\n    try {\n      return await operation(activeSpan, spanContext, lease);\n    } catch (err) {\n      recordSpanError(activeSpan, err);\n      throw err;\n    }\n  } else {\n    // Create new span - we own it\n    const tracer = getTracer();\n    const startActiveSpan = createStartActiveSpan(tracer);\n\n    return startActiveSpan(\n      name,\n      null,\n      async (span) => {\n        const lease: SpanLease = {\n          owned: true,\n          end: () => span.end(),\n        };\n        return await operation(span, spanContext, lease);\n      },\n      {\n        manualEnd: options?.streaming ?? false,\n        onError: (err, span) => {\n          // createStartActiveSpan already calls span.recordException()\n          // We only need to add our custom error classification attributes\n          const errorType = classifyError(err);\n          span.setAttribute(Attr.Error.Type, errorType ?? 'unknown');\n\n          if (err instanceof Error && err.message) {\n            span.setAttribute(Attr.Error.Message, err.message);\n          }\n\n          if (err && typeof err === 'object' && 'status' in err) {\n            span.setAttribute(Attr.HTTP.Response.StatusCode, err.status as AttributeValue);\n          }\n        },\n      },\n    );\n  }\n}\n\n/**\n * Sets common response attributes on a span\n */\nexport function setResponseAttributes(\n  span: Span,\n  response: {\n    id?: string;\n    modelId?: string;\n    usage?: {\n      inputTokens?: number;\n      outputTokens?: number;\n      promptTokens?: number;\n      completionTokens?: number;\n    };\n    finishReason?: string;\n  },\n): void {\n  if (response.id) {\n    span.setAttribute(Attr.GenAI.Response.ID, response.id);\n  }\n  if (response.modelId) {\n    span.setAttribute(Attr.GenAI.Response.Model, response.modelId);\n  }\n\n  if (response.usage) {\n    // Handle both V1 and V2 usage formats\n    const inputTokens = ensureNumber(response.usage.inputTokens ?? response.usage.promptTokens);\n    const outputTokens = ensureNumber(\n      response.usage.outputTokens ?? response.usage.completionTokens,\n    );\n\n    if (inputTokens !== undefined) {\n      span.setAttribute(Attr.GenAI.Usage.InputTokens, inputTokens);\n    }\n    if (outputTokens !== undefined) {\n      span.setAttribute(Attr.GenAI.Usage.OutputTokens, outputTokens);\n    }\n  }\n\n  if (response.finishReason) {\n    span.setAttribute(Attr.GenAI.Response.FinishReasons, JSON.stringify([response.finishReason]));\n  }\n}\n\n/**\n * Determines output type from response format - V1 version\n */\nexport function determineOutputTypeV1(options: {\n  responseFormat?: { type?: string };\n  mode?: { type?: string };\n}): string | undefined {\n  if (options.responseFormat?.type) {\n    switch (options.responseFormat.type) {\n      case 'json':\n        return Attr.GenAI.Output.Type_Values.Json;\n      case 'text':\n        return Attr.GenAI.Output.Type_Values.Text;\n    }\n  }\n\n  if (options.mode?.type === 'object-json' || options.mode?.type === 'object-tool') {\n    return Attr.GenAI.Output.Type_Values.Json;\n  }\n\n  if (options.mode?.type === 'regular') {\n    return Attr.GenAI.Output.Type_Values.Text;\n  }\n\n  return undefined;\n}\n\n/**\n * Determines output type from response format - V2 version\n */\nexport function determineOutputTypeV2(options: {\n  responseFormat?: { type?: string };\n}): string | undefined {\n  if (options.responseFormat?.type) {\n    switch (options.responseFormat.type) {\n      case 'json':\n        return Attr.GenAI.Output.Type_Values.Json;\n      case 'text':\n        return Attr.GenAI.Output.Type_Values.Text;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Maps AI SDK provider IDs to OpenTelemetry gen_ai.provider.name values\n *\n * @param vercelSDKProvider - The provider ID from the AI SDK\n * @returns The corresponding `gen_ai.provider.name` value, or `undefined` if no match is found\n */\nexport function mapVercelSDKProviderToOTelProvider(vercelSDKProvider: string): string | undefined {\n  if (vercelSDKProvider === 'openai-compatible') {\n    // we don't know the real provider\n    return undefined;\n  }\n\n  // exact matches\n  switch (vercelSDKProvider) {\n    case 'amazon-bedrock':\n      return Attr.GenAI.Provider.Name_Values.AWSBedrock;\n    case 'anthropic':\n    case 'anthropic.messages':\n      return Attr.GenAI.Provider.Name_Values.Anthropic;\n    case 'assemblyai':\n    case 'assemblyai.transcription':\n      return Attr.GenAI.Provider.Name_Values.AssemblyAI;\n    case 'deepgram':\n    case 'deepgram.transcription':\n      return Attr.GenAI.Provider.Name_Values.Deepgram;\n    case 'gateway': // `import { gateway } from 'ai'`\n      return Attr.GenAI.Provider.Name_Values.Vercel;\n    case 'gladia':\n    case 'gladia.transcription':\n      return Attr.GenAI.Provider.Name_Values.Gladia;\n    case 'google':\n    case 'google.generative-ai':\n      return Attr.GenAI.Provider.Name_Values.GCPGemini;\n    case 'groq':\n      return Attr.GenAI.Provider.Name_Values.Groq;\n    case 'mistral':\n      return Attr.GenAI.Provider.Name_Values.MistralAI;\n    case 'openai':\n      return Attr.GenAI.Provider.Name_Values.OpenAI;\n    case 'perplexity':\n      return Attr.GenAI.Provider.Name_Values.Perplexity;\n    case 'replicate':\n      return Attr.GenAI.Provider.Name_Values.Replicate;\n    case 'revai':\n    case 'revai.transcription':\n      return Attr.GenAI.Provider.Name_Values.RevAI;\n    case 'togetherai':\n      return Attr.GenAI.Provider.Name_Values.TogetherAI;\n    case 'xai':\n      return Attr.GenAI.Provider.Name_Values.XAI;\n\n    // startswith + fall through\n    default: {\n      if (vercelSDKProvider.startsWith('azure.')) {\n        return Attr.GenAI.Provider.Name_Values.AzureAIOpenAI;\n      }\n      if (vercelSDKProvider.startsWith('cerebras.')) {\n        return Attr.GenAI.Provider.Name_Values.Cerebras;\n      }\n      if (vercelSDKProvider.startsWith('cohere.')) {\n        return Attr.GenAI.Provider.Name_Values.Cohere;\n      }\n      if (vercelSDKProvider.startsWith('deepinfra.')) {\n        return Attr.GenAI.Provider.Name_Values.DeepInfra;\n      }\n      if (vercelSDKProvider.startsWith('deepseek.')) {\n        return Attr.GenAI.Provider.Name_Values.Deepseek;\n      }\n      if (vercelSDKProvider.startsWith('elevenlabs.')) {\n        return Attr.GenAI.Provider.Name_Values.ElevenLabs;\n      }\n      if (vercelSDKProvider.startsWith('fal.')) {\n        return Attr.GenAI.Provider.Name_Values.Fal;\n      }\n      if (vercelSDKProvider.startsWith('fireworks.')) {\n        return Attr.GenAI.Provider.Name_Values.Fireworks;\n      }\n      if (vercelSDKProvider.startsWith('google.vertex.')) {\n        return Attr.GenAI.Provider.Name_Values.GCPVertexAI;\n      }\n      if (vercelSDKProvider.startsWith('groq.')) {\n        return Attr.GenAI.Provider.Name_Values.Groq;\n      }\n      if (vercelSDKProvider.startsWith('hume.')) {\n        return Attr.GenAI.Provider.Name_Values.Hume;\n      }\n      if (vercelSDKProvider.startsWith('lmnt.')) {\n        return Attr.GenAI.Provider.Name_Values.Lmnt;\n      }\n      if (vercelSDKProvider.startsWith('luma.')) {\n        return Attr.GenAI.Provider.Name_Values.Luma;\n      }\n      if (vercelSDKProvider.startsWith('mistral.')) {\n        return Attr.GenAI.Provider.Name_Values.MistralAI;\n      }\n      if (vercelSDKProvider.startsWith('openai.')) {\n        return Attr.GenAI.Provider.Name_Values.OpenAI;\n      }\n      if (vercelSDKProvider.startsWith('vercel.')) {\n        return Attr.GenAI.Provider.Name_Values.Vercel;\n      }\n      if (vercelSDKProvider.startsWith('vertex.anthropic.')) {\n        return Attr.GenAI.Provider.Name_Values.GCPVertexAI;\n      }\n      if (vercelSDKProvider.startsWith('xai.')) {\n        return Attr.GenAI.Provider.Name_Values.XAI;\n      }\n\n      // most other openai-compatible providers use {providerName}.{chat|completion|embedding|image}\n      const s = vercelSDKProvider.split('.');\n      if (s.length === 2) {\n        return s[0];\n      }\n\n      // For unknown providers, don't set the attribute\n      return undefined;\n    }\n  }\n}\n","import {\n  ATTR_ERROR_TYPE,\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n} from '@opentelemetry/semantic-conventions';\n\nimport {\n  ATTR_EVAL_CASE_INDEX,\n  ATTR_EVAL_CASE_EXPECTED,\n  ATTR_EVAL_CASE_INPUT,\n  ATTR_EVAL_CASE_OUTPUT,\n  ATTR_EVAL_CASE_METADATA,\n  ATTR_EVAL_CASE_SCORES,\n  ATTR_EVAL_SCORE_PASSED,\n  ATTR_EVAL_SCORE_IS_BOOLEAN,\n  ATTR_EVAL_SCORE_VALUE,\n  ATTR_EVAL_SCORE_NAME,\n  ATTR_EVAL_SCORE_THRESHOLD,\n  ATTR_EVAL_SCORE_METADATA,\n  ATTR_EVAL_TASK_TYPE,\n  ATTR_EVAL_TASK_NAME,\n  ATTR_EVAL_TASK_OUTPUT,\n  ATTR_EVAL_COLLECTION_NAME,\n  ATTR_EVAL_COLLECTION_SIZE,\n  ATTR_EVAL_ID,\n  ATTR_EVAL_BASELINE_ID,\n  ATTR_EVAL_BASELINE_NAME,\n  ATTR_EVAL_BASELINE_VERSION,\n  ATTR_EVAL_NAME,\n  ATTR_EVAL_TAGS,\n  ATTR_EVAL_TYPE,\n  ATTR_EVAL_COLLECTION_ID,\n  ATTR_EVAL_USER_NAME,\n  ATTR_EVAL_USER_EMAIL,\n  ATTR_EVAL_VERSION,\n  ATTR_EVAL_RUN_ID,\n  ATTR_EVAL_METADATA,\n  ATTR_EVAL_CONFIG_FLAGS,\n  ATTR_EVAL_CAPABILITY_NAME,\n  ATTR_EVAL_STEP_NAME,\n} from './eval_proposal';\n\nimport {\n  ATTR_ERROR_MESSAGE,\n  ATTR_GEN_AI_AGENT_DESCRIPTION,\n  ATTR_GEN_AI_AGENT_ID,\n  ATTR_GEN_AI_AGENT_NAME,\n  ATTR_GEN_AI_CONVERSATION_ID,\n  ATTR_GEN_AI_INPUT_MESSAGES,\n  ATTR_GEN_AI_OPERATION_NAME,\n  ATTR_GEN_AI_OUTPUT_MESSAGES,\n  ATTR_GEN_AI_OUTPUT_TYPE,\n  ATTR_GEN_AI_PROVIDER_NAME,\n  ATTR_GEN_AI_REQUEST_CHOICE_COUNT,\n  ATTR_GEN_AI_REQUEST_ENCODING_FORMATS,\n  ATTR_GEN_AI_REQUEST_FREQUENCY_PENALTY,\n  ATTR_GEN_AI_REQUEST_MAX_TOKENS,\n  ATTR_GEN_AI_REQUEST_MODEL,\n  ATTR_GEN_AI_REQUEST_PRESENCE_PENALTY,\n  ATTR_GEN_AI_REQUEST_SEED,\n  ATTR_GEN_AI_REQUEST_STOP_SEQUENCES,\n  ATTR_GEN_AI_REQUEST_TEMPERATURE,\n  ATTR_GEN_AI_REQUEST_TOP_K,\n  ATTR_GEN_AI_REQUEST_TOP_P,\n  ATTR_GEN_AI_RESPONSE_FINISH_REASONS,\n  ATTR_GEN_AI_RESPONSE_ID,\n  ATTR_GEN_AI_RESPONSE_MODEL,\n  ATTR_GEN_AI_TOOL_CALL_ID,\n  ATTR_GEN_AI_TOOL_DESCRIPTION,\n  ATTR_GEN_AI_TOOL_NAME,\n  ATTR_GEN_AI_TOOL_TYPE,\n  ATTR_GEN_AI_USAGE_INPUT_TOKENS,\n  ATTR_GEN_AI_USAGE_OUTPUT_TOKENS,\n  GEN_AI_OPERATION_NAME_VALUE_CHAT,\n  GEN_AI_OPERATION_NAME_VALUE_CREATE_AGENT,\n  GEN_AI_OPERATION_NAME_VALUE_EMBEDDINGS,\n  GEN_AI_OPERATION_NAME_VALUE_EXECUTE_TOOL,\n  GEN_AI_OPERATION_NAME_VALUE_GENERATE_CONTENT,\n  GEN_AI_OPERATION_NAME_VALUE_INVOKE_AGENT,\n  GEN_AI_OUTPUT_TYPE_VALUE_IMAGE,\n  GEN_AI_OUTPUT_TYPE_VALUE_JSON,\n  GEN_AI_OUTPUT_TYPE_VALUE_SPEECH,\n  GEN_AI_OUTPUT_TYPE_VALUE_TEXT,\n  GEN_AI_PROVIDER_NAME_VALUE_ANTHROPIC,\n  GEN_AI_PROVIDER_NAME_VALUE_AWS_BEDROCK,\n  GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_INFERENCE,\n  GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_OPENAI,\n  GEN_AI_PROVIDER_NAME_VALUE_COHERE,\n  GEN_AI_PROVIDER_NAME_VALUE_DEEPSEEK,\n  GEN_AI_PROVIDER_NAME_VALUE_GCP_GEMINI,\n  GEN_AI_PROVIDER_NAME_VALUE_GCP_GEN_AI,\n  GEN_AI_PROVIDER_NAME_VALUE_GCP_VERTEX_AI,\n  GEN_AI_PROVIDER_NAME_VALUE_GROQ,\n  GEN_AI_PROVIDER_NAME_VALUE_IBM_WATSONX_AI,\n  GEN_AI_PROVIDER_NAME_VALUE_MISTRAL_AI,\n  GEN_AI_PROVIDER_NAME_VALUE_OPENAI,\n  GEN_AI_PROVIDER_NAME_VALUE_PERPLEXITY,\n  GEN_AI_PROVIDER_NAME_VALUE_X_AI,\n} from '@opentelemetry/semantic-conventions/incubating';\n\n/**\n * PROPRIETARY ATTRIBUTES (o11y)\n *\n * @see: https://axiom.co/docs/ai-engineering/semantic-conventions\n */\n\nconst ATTR_AXIOM_GEN_AI_SCHEMA_URL = 'axiom.gen_ai.schema_url';\nconst ATTR_AXIOM_GEN_AI_SDK_NAME = 'axiom.gen_ai.sdk.name';\nconst ATTR_AXIOM_GEN_AI_SDK_VERSION = 'axiom.gen_ai.sdk.version';\nconst ATTR_GEN_AI_CAPABILITY_NAME = 'gen_ai.capability.name';\nconst ATTR_GEN_AI_STEP_NAME = 'gen_ai.step.name';\nconst ATTR_GEN_AI_TOOL_ARGUMENTS = 'gen_ai.tool.arguments'; // deprecated by OTel\nconst ATTR_GEN_AI_TOOL_MESSAGE = 'gen_ai.tool.message'; // deprecated by OTel\n\nconst GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI = 'assemblyai';\nconst GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS = 'cerebras';\nconst GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM = 'deepgram';\nconst GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA = 'deepinfra';\nconst GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS = 'elevenlabs';\nconst GEN_AI_PROVIDER_NAME_VALUE_FAL = 'fal';\nconst GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS = 'fireworks';\nconst GEN_AI_PROVIDER_NAME_VALUE_GLADIA = 'gladia';\nconst GEN_AI_PROVIDER_NAME_VALUE_HUME = 'hume';\nconst GEN_AI_PROVIDER_NAME_VALUE_LMNT = 'lmnt';\nconst GEN_AI_PROVIDER_NAME_VALUE_LUMA = 'luma';\nconst GEN_AI_PROVIDER_NAME_VALUE_REPLICATE = 'replicate';\nconst GEN_AI_PROVIDER_NAME_VALUE_REVAI = 'revai';\nconst GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI = 'togetherai';\nconst GEN_AI_PROVIDER_NAME_VALUE_VERCEL = 'vercel';\n\n/**\n * When adding something new here, please:\n * 1. Make sure it doesn't already exist as part of OTel Semantic Conventions (use that instead)\n * 2. Make sure to use standard naming schema, ie snake_case\n * 3. If a specific feature has an attribute you would like to use, extract it to the shared section\n *\n * Also Experimental Attributes should always be imported here and then used from the CustomAttributes object\n * because they are unstable.\n *\n * @see: https://github.com/open-telemetry/opentelemetry-js/tree/c89cb38d0fec39d54cf3fcb35c429a8129e9c909/semantic-conventions#unstable-semconv\n */\nexport const Attr = {\n  __EXPERIMENTAL_Flag: (flagName: string) => `flag.${flagName}`,\n  __EXPERIMENTAL_Fact: (factName: string) => `fact.${factName}`,\n  Axiom: {\n    GenAI: {\n      SchemaURL: ATTR_AXIOM_GEN_AI_SCHEMA_URL,\n      SDK: {\n        Name: ATTR_AXIOM_GEN_AI_SDK_NAME,\n        Version: ATTR_AXIOM_GEN_AI_SDK_VERSION,\n      },\n    },\n  },\n  GenAI: {\n    PromptMetadata: {\n      ID: 'axiom.gen_ai.prompt.id',\n      Name: 'axiom.gen_ai.prompt.name',\n      Slug: 'axiom.gen_ai.prompt.slug',\n      Version: 'axiom.gen_ai.prompt.version',\n    },\n    /**\n     * These two are used to identify the span\n     */\n    Capability: {\n      Name: ATTR_GEN_AI_CAPABILITY_NAME,\n    },\n    Step: {\n      Name: ATTR_GEN_AI_STEP_NAME,\n    },\n    Provider: {\n      Name: ATTR_GEN_AI_PROVIDER_NAME,\n      Name_Values: {\n        Anthropic: GEN_AI_PROVIDER_NAME_VALUE_ANTHROPIC,\n        AssemblyAI: GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI,\n        AWSBedrock: GEN_AI_PROVIDER_NAME_VALUE_AWS_BEDROCK,\n        AzureAIInference: GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_INFERENCE,\n        AzureAIOpenAI: GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_OPENAI,\n        Cerebras: GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS,\n        Cohere: GEN_AI_PROVIDER_NAME_VALUE_COHERE,\n        Deepgram: GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM,\n        DeepInfra: GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA,\n        Deepseek: GEN_AI_PROVIDER_NAME_VALUE_DEEPSEEK,\n        ElevenLabs: GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS,\n        Fal: GEN_AI_PROVIDER_NAME_VALUE_FAL,\n        Fireworks: GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS,\n        GCPGemini: GEN_AI_PROVIDER_NAME_VALUE_GCP_GEMINI,\n        GCPGenAI: GEN_AI_PROVIDER_NAME_VALUE_GCP_GEN_AI,\n        GCPVertexAI: GEN_AI_PROVIDER_NAME_VALUE_GCP_VERTEX_AI,\n        Gladia: GEN_AI_PROVIDER_NAME_VALUE_GLADIA,\n        Groq: GEN_AI_PROVIDER_NAME_VALUE_GROQ,\n        Hume: GEN_AI_PROVIDER_NAME_VALUE_HUME,\n        IBMWatsonxAI: GEN_AI_PROVIDER_NAME_VALUE_IBM_WATSONX_AI,\n        Lmnt: GEN_AI_PROVIDER_NAME_VALUE_LMNT,\n        Luma: GEN_AI_PROVIDER_NAME_VALUE_LUMA,\n        MistralAI: GEN_AI_PROVIDER_NAME_VALUE_MISTRAL_AI,\n        OpenAI: GEN_AI_PROVIDER_NAME_VALUE_OPENAI,\n        Perplexity: GEN_AI_PROVIDER_NAME_VALUE_PERPLEXITY,\n        Replicate: GEN_AI_PROVIDER_NAME_VALUE_REPLICATE,\n        RevAI: GEN_AI_PROVIDER_NAME_VALUE_REVAI,\n        TogetherAI: GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI,\n        Vercel: GEN_AI_PROVIDER_NAME_VALUE_VERCEL,\n        XAI: GEN_AI_PROVIDER_NAME_VALUE_X_AI,\n      },\n    },\n    /**\n     * Regular attributes\n     */\n    Agent: {\n      Description: ATTR_GEN_AI_AGENT_DESCRIPTION, // not yet used by axiom-ai\n      ID: ATTR_GEN_AI_AGENT_ID, // not yet used by axiom-ai\n      Name: ATTR_GEN_AI_AGENT_NAME, // not yet used by axiom-ai\n    },\n    Conversation: {\n      ID: ATTR_GEN_AI_CONVERSATION_ID, // not yet used by axiom-ai, anyway probably needs to be provided by user\n    },\n    Input: {\n      Messages: ATTR_GEN_AI_INPUT_MESSAGES,\n    },\n    Operation: {\n      Name: ATTR_GEN_AI_OPERATION_NAME,\n      Name_Values: {\n        /**\n         * Note that \"text_completion\" is deprecated in favor of \"chat\" for both OpenAI and Anthropic\n         */\n        Chat: GEN_AI_OPERATION_NAME_VALUE_CHAT,\n        CreateAgent: GEN_AI_OPERATION_NAME_VALUE_CREATE_AGENT,\n        Embeddings: GEN_AI_OPERATION_NAME_VALUE_EMBEDDINGS,\n        ExecuteTool: GEN_AI_OPERATION_NAME_VALUE_EXECUTE_TOOL,\n        GenerateContent: GEN_AI_OPERATION_NAME_VALUE_GENERATE_CONTENT,\n        InvokeAgent: GEN_AI_OPERATION_NAME_VALUE_INVOKE_AGENT,\n      },\n    },\n    Output: {\n      Messages: ATTR_GEN_AI_OUTPUT_MESSAGES,\n      Type: ATTR_GEN_AI_OUTPUT_TYPE,\n      Type_Values: {\n        Text: GEN_AI_OUTPUT_TYPE_VALUE_TEXT,\n        Json: GEN_AI_OUTPUT_TYPE_VALUE_JSON,\n        Image: GEN_AI_OUTPUT_TYPE_VALUE_IMAGE,\n        Speech: GEN_AI_OUTPUT_TYPE_VALUE_SPEECH,\n      },\n    },\n    /**\n     * The provider that is hosting the model, eg AWS Bedrock\n     * There doesn't seem to be a semconv for this\n     */\n    Request: {\n      ChoiceCount: ATTR_GEN_AI_REQUEST_CHOICE_COUNT, // not yet used by axiom-ai\n      EncodingFormats: ATTR_GEN_AI_REQUEST_ENCODING_FORMATS, // not yet used by axiom-ai\n      FrequencyPenalty: ATTR_GEN_AI_REQUEST_FREQUENCY_PENALTY,\n      MaxTokens: ATTR_GEN_AI_REQUEST_MAX_TOKENS,\n      /**\n       * The model you asked for\n       */\n      Model: ATTR_GEN_AI_REQUEST_MODEL,\n      PresencePenalty: ATTR_GEN_AI_REQUEST_PRESENCE_PENALTY,\n      Seed: ATTR_GEN_AI_REQUEST_SEED,\n      StopSequences: ATTR_GEN_AI_REQUEST_STOP_SEQUENCES,\n      Temperature: ATTR_GEN_AI_REQUEST_TEMPERATURE,\n      TopK: ATTR_GEN_AI_REQUEST_TOP_K,\n      TopP: ATTR_GEN_AI_REQUEST_TOP_P,\n    },\n    Response: {\n      FinishReasons: ATTR_GEN_AI_RESPONSE_FINISH_REASONS,\n      ID: ATTR_GEN_AI_RESPONSE_ID,\n      /**\n       * The model that was actually used (might be different bc routing) - only ever get this from the response, otherwise omit\n       */\n      Model: ATTR_GEN_AI_RESPONSE_MODEL, // somehow not landing on the span for google models? check up on this...\n    },\n    Tool: {\n      CallID: ATTR_GEN_AI_TOOL_CALL_ID,\n      Description: ATTR_GEN_AI_TOOL_DESCRIPTION,\n      Name: ATTR_GEN_AI_TOOL_NAME,\n      Type: ATTR_GEN_AI_TOOL_TYPE,\n      /**\n       * Note, OTel Semantic Convention suggest only putting tool inputs/outputs on the parent chat span\n       * But we at least want to give users THE OPTION to put them on the tool spans themselves as well\n       * Because it enables a lot of things with querying\n       * @see https://github.com/open-telemetry/semantic-conventions/releases/tag/v1.37.0\n       */\n      Arguments: ATTR_GEN_AI_TOOL_ARGUMENTS,\n      /**\n       * Note, OTel Semantic Convention suggest only putting tool inputs/outputs on the parent chat span\n       * But we at least want to give users THE OPTION to put them on the tool spans themselves as well\n       * Because it enables a lot of things with querying\n       * @see https://github.com/open-telemetry/semantic-conventions/releases/tag/v1.37.0\n       */\n      Message: ATTR_GEN_AI_TOOL_MESSAGE,\n    },\n    Usage: {\n      InputTokens: ATTR_GEN_AI_USAGE_INPUT_TOKENS,\n      OutputTokens: ATTR_GEN_AI_USAGE_OUTPUT_TOKENS,\n    },\n  },\n  Eval: {\n    ID: ATTR_EVAL_ID,\n    Name: ATTR_EVAL_NAME,\n    Version: ATTR_EVAL_VERSION,\n    Type: ATTR_EVAL_TYPE,\n    Baseline: {\n      ID: ATTR_EVAL_BASELINE_ID,\n      Name: ATTR_EVAL_BASELINE_NAME,\n      Version: ATTR_EVAL_BASELINE_VERSION,\n    },\n    Capability: {\n      Name: ATTR_EVAL_CAPABILITY_NAME,\n    },\n    Step: {\n      Name: ATTR_EVAL_STEP_NAME,\n    },\n    Tags: ATTR_EVAL_TAGS,\n    Metadata: ATTR_EVAL_METADATA,\n    Collection: {\n      ID: ATTR_EVAL_COLLECTION_ID,\n      Name: ATTR_EVAL_COLLECTION_NAME,\n      Size: ATTR_EVAL_COLLECTION_SIZE,\n    },\n    Config: {\n      Flags: ATTR_EVAL_CONFIG_FLAGS,\n    },\n    Run: {\n      ID: ATTR_EVAL_RUN_ID,\n    },\n    Case: {\n      Index: ATTR_EVAL_CASE_INDEX,\n      Input: ATTR_EVAL_CASE_INPUT,\n      Output: ATTR_EVAL_CASE_OUTPUT,\n      Expected: ATTR_EVAL_CASE_EXPECTED,\n      Scores: ATTR_EVAL_CASE_SCORES,\n      Metadata: ATTR_EVAL_CASE_METADATA,\n    },\n    Task: {\n      Output: ATTR_EVAL_TASK_OUTPUT,\n      Name: ATTR_EVAL_TASK_NAME,\n      Type: ATTR_EVAL_TASK_TYPE,\n    },\n    Score: {\n      Name: ATTR_EVAL_SCORE_NAME,\n      Value: ATTR_EVAL_SCORE_VALUE,\n      Threshold: ATTR_EVAL_SCORE_THRESHOLD,\n      Passed: ATTR_EVAL_SCORE_PASSED,\n      IsBoolean: ATTR_EVAL_SCORE_IS_BOOLEAN,\n      Metadata: ATTR_EVAL_SCORE_METADATA,\n    },\n    User: {\n      Name: ATTR_EVAL_USER_NAME,\n      Email: ATTR_EVAL_USER_EMAIL,\n    },\n  },\n  Error: {\n    Type: ATTR_ERROR_TYPE,\n    Message: ATTR_ERROR_MESSAGE,\n  },\n  HTTP: {\n    Response: {\n      StatusCode: ATTR_HTTP_RESPONSE_STATUS_CODE,\n    },\n  },\n} as const;\n","// experiment\nexport const ATTR_EVAL_ID = 'eval.id' as const;\nexport const ATTR_EVAL_NAME = 'eval.name' as const;\nexport const ATTR_EVAL_VERSION = 'eval.version' as const;\nexport const ATTR_EVAL_TYPE = 'eval.type' as const;\nexport const ATTR_EVAL_TAGS = 'eval.tags' as const;\nexport const ATTR_EVAL_BASELINE_ID = 'eval.baseline.id' as const;\nexport const ATTR_EVAL_BASELINE_NAME = 'eval.baseline.name' as const;\nexport const ATTR_EVAL_BASELINE_VERSION = 'eval.baseline.version' as const;\nexport const ATTR_EVAL_METADATA = 'eval.metadata' as const;\n// capability\nexport const ATTR_EVAL_CAPABILITY_NAME = 'eval.capability.name' as const;\nexport const ATTR_EVAL_STEP_NAME = 'eval.step.name' as const;\n// collection\nexport const ATTR_EVAL_COLLECTION_ID = 'eval.collection.id' as const;\nexport const ATTR_EVAL_COLLECTION_SIZE = 'eval.collection.size' as const;\nexport const ATTR_EVAL_COLLECTION_NAME = 'eval.collection.name' as const;\n// config\nexport const ATTR_EVAL_CONFIG_FLAGS = 'eval.config.flags' as const;\n// case\nexport const ATTR_EVAL_CASE_INDEX = 'eval.case.index' as const;\nexport const ATTR_EVAL_CASE_INPUT = 'eval.case.input' as const;\nexport const ATTR_EVAL_CASE_OUTPUT = 'eval.case.output' as const;\nexport const ATTR_EVAL_CASE_EXPECTED = 'eval.case.expected' as const;\nexport const ATTR_EVAL_CASE_SCORES = 'eval.case.scores' as const;\nexport const ATTR_EVAL_CASE_METADATA = 'eval.case.metadata' as const;\n// task\nexport const ATTR_EVAL_TASK_OUTPUT = 'eval.task.output' as const;\nexport const ATTR_EVAL_TASK_NAME = 'eval.task.name' as const;\nexport const ATTR_EVAL_TASK_TYPE = 'eval.task.type' as const;\n// run\nexport const ATTR_EVAL_RUN_ID = 'eval.run.id' as const;\n// score\nexport const ATTR_EVAL_SCORE_NAME = 'eval.score.name' as const;\nexport const ATTR_EVAL_SCORE_VALUE = 'eval.score.value' as const;\nexport const ATTR_EVAL_SCORE_THRESHOLD = 'eval.score.threshold' as const;\nexport const ATTR_EVAL_SCORE_PASSED = 'eval.score.passed' as const;\nexport const ATTR_EVAL_SCORE_IS_BOOLEAN = 'eval.score.is_boolean' as const;\nexport const ATTR_EVAL_SCORE_SCORER = 'eval.score.scorer' as const;\nexport const ATTR_EVAL_SCORE_METADATA = 'eval.score.metadata' as const;\n// user\nexport const ATTR_EVAL_USER_NAME = 'eval.user.name';\nexport const ATTR_EVAL_USER_EMAIL = 'eval.user.email';\n","export const SCHEMA_VERSION = '0.0.2';\nexport const SCHEMA_BASE_URL = 'https://axiom.co/ai/schemas/';\nexport const SCHEMA_URL = `${SCHEMA_BASE_URL}${SCHEMA_VERSION}`;\n","import { type Span, type SpanOptions, SpanStatusCode, type Tracer } from '@opentelemetry/api';\n\ninterface Callbacks {\n  onSuccess?: (span: Span) => void;\n  onError?: (error: unknown, span: Span) => void;\n  onFinally?: (span: Span) => void;\n  /**\n   * If true, the operation will call span.end() manually.\n   * Used for streaming operations where the span should remain open until stream consumption completes.\n   */\n  manualEnd?: boolean;\n}\n\nexport const createStartActiveSpan =\n  (tracer: Tracer) =>\n  async <T>(\n    name: string,\n    options: SpanOptions | null,\n    fn: (span: Span) => Promise<T>,\n    callbacks?: Callbacks,\n  ): Promise<T> => {\n    return tracer.startActiveSpan(name, { ...(options ?? {}) }, async (span) => {\n      try {\n        const result = await fn(span);\n\n        callbacks?.onSuccess?.(span);\n\n        return result;\n      } catch (error) {\n        callbacks?.onError?.(error, span);\n\n        if (error instanceof Error) {\n          span.recordException(error);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message,\n          });\n        }\n\n        throw error;\n      } finally {\n        callbacks?.onFinally?.(span);\n\n        // Only auto-end the span if manualEnd is not set\n        // For streaming operations, the operation itself will call span.end() when the stream completes\n        if (!callbacks?.manualEnd) {\n          span.end();\n        }\n      }\n    });\n  };\n","import {\n  type LanguageModelV1,\n  type LanguageModelV1CallOptions,\n  type LanguageModelV1Prompt,\n  type LanguageModelV1StreamPart,\n} from '@ai-sdk/providerv1';\nimport {\n  type LanguageModelV2,\n  type LanguageModelV2CallOptions,\n  type LanguageModelV2Middleware,\n  type LanguageModelV2StreamPart,\n  type LanguageModelV2Content,\n  type LanguageModelV2ToolCall,\n  type LanguageModelV2Usage,\n  type LanguageModelV2ResponseMetadata,\n  type LanguageModelV2FinishReason,\n  type LanguageModelV2Prompt,\n} from '@ai-sdk/providerv2';\nimport { type LanguageModelV1Middleware } from 'aiv4';\n\nimport { type Span } from '@opentelemetry/api';\nimport { Attr } from './semconv/attributes';\nimport { createSimpleCompletion } from './completionUtils';\nimport {\n  appendToolCalls,\n  extractToolResultsFromPromptV2,\n  extractToolResultsFromRawPrompt,\n} from '../util/promptUtils';\nimport { sanitizeMultimodalContent } from './utils/contentSanitizer';\nimport {\n  setScopeAttributes,\n  setBaseAttributes,\n  setRequestParameterAttributes,\n  withSpanHandling,\n  determineOutputTypeV1,\n  determineOutputTypeV2,\n  classifyToolError,\n  createStreamChildSpan,\n  ensureNumber,\n  type GenAiSpanContextV1,\n  type GenAiSpanContextV2,\n} from './utils/wrapperUtils';\nimport {\n  promptV1ToOpenAI,\n  promptV2ToOpenAI,\n  normalizeV1ToolCalls,\n  normalizeV2ToolCalls,\n} from './utils/normalized';\nimport {\n  ToolCallAggregator,\n  TextAggregator,\n  StreamStats,\n  ToolCallAggregatorV2,\n  TextAggregatorV2,\n  StreamStatsV2,\n} from './streaming/aggregators';\nimport type { AxiomPromptMetadata } from '../types/metadata';\nimport { getRedactionPolicy, handleMaybeRedactedAttribute } from './utils/redaction';\n\nexport interface AxiomTelemetryConfig {\n  // Future configuration options can be added here\n}\n\nconst appendPromptMetadataToSpan = (\n  span: Span,\n  messages: LanguageModelV1Prompt | LanguageModelV2Prompt,\n) => {\n  const lastMessage = messages?.[messages.length - 1];\n\n  let axiomMeta: AxiomPromptMetadata | undefined;\n\n  if ('providerMetadata' in lastMessage) {\n    axiomMeta = lastMessage?.providerMetadata?._axiomMeta as AxiomPromptMetadata | undefined;\n  } else if ('providerOptions' in lastMessage) {\n    axiomMeta = lastMessage?.providerOptions?._axiomMeta as AxiomPromptMetadata | undefined;\n  }\n\n  if (axiomMeta) {\n    if (axiomMeta.id) span.setAttribute(Attr.GenAI.PromptMetadata.ID, axiomMeta.id);\n    if (axiomMeta.name) span.setAttribute(Attr.GenAI.PromptMetadata.Name, axiomMeta.name);\n    if (axiomMeta.slug) span.setAttribute(Attr.GenAI.PromptMetadata.Slug, axiomMeta.slug);\n    if (axiomMeta.version) span.setAttribute(Attr.GenAI.PromptMetadata.Version, axiomMeta.version);\n  }\n};\n\n/**\n * Creates Axiom telemetry middleware for LanguageModelV1\n */\nexport function axiomAIMiddlewareV1(/* _config?: AxiomTelemetryConfig */): LanguageModelV1Middleware {\n  return {\n    wrapGenerate: async ({ doGenerate, params, model }) => {\n      return withSpanHandling(\n        model.modelId,\n        async (span, commonContext, _lease) => {\n          const context = commonContext as GenAiSpanContextV1;\n\n          appendPromptMetadataToSpan(span, params.prompt);\n\n          // Pre-call setup\n          setScopeAttributes(span);\n          setPreCallAttributesV1(span, params, context, model);\n\n          const res = await doGenerate();\n\n          // Store rawCall data in context for access in post-call processing\n          context.rawCall = res.rawCall as { rawPrompt?: any[]; rawSettings?: any };\n\n          // Post-call processing\n          await setPostCallAttributesV1(span, res, context, model);\n\n          return res;\n        },\n        { version: 'v1' },\n      );\n    },\n\n    wrapStream: async ({ doStream, params, model }) => {\n      return withSpanHandling(\n        model.modelId,\n        async (span, commonContext, lease) => {\n          const context = commonContext as GenAiSpanContextV1;\n\n          appendPromptMetadataToSpan(span, params.prompt);\n\n          // Pre-call setup\n          setScopeAttributes(span);\n          setPreCallAttributesV1(span, params, context, model);\n\n          const { stream, ...head } = await doStream();\n\n          // Create child span for stream processing (provides granular visibility)\n          const childSpan = createStreamChildSpan(span, `chat ${model.modelId} stream`);\n\n          const stats = new StreamStats();\n          const toolAggregator = new ToolCallAggregator();\n          const textAggregator = new TextAggregator();\n\n          return {\n            ...head,\n            stream: stream.pipeThrough(\n              new TransformStream({\n                transform(chunk: LanguageModelV1StreamPart, controller) {\n                  try {\n                    stats.feed(chunk);\n                    toolAggregator.handleChunk(chunk);\n                    textAggregator.feed(chunk);\n\n                    controller.enqueue(chunk);\n                  } catch (err) {\n                    classifyToolError(err, childSpan);\n                    childSpan.end();\n                    if (lease.owned) lease.end();\n                    controller.error(err);\n                  }\n                },\n                async flush(controller) {\n                  try {\n                    await setPostCallAttributesV1(\n                      span,\n                      {\n                        ...head,\n                        ...stats.result,\n                        toolCalls:\n                          toolAggregator.result.length > 0 ? toolAggregator.result : undefined,\n                        text: textAggregator.text,\n                      },\n                      context,\n                      model,\n                    );\n\n                    childSpan.end();\n                    if (lease.owned) lease.end();\n                    controller.terminate();\n                  } catch (err) {\n                    classifyToolError(err, childSpan);\n                    childSpan.end();\n                    if (lease.owned) lease.end();\n                    controller.error(err);\n                  }\n                },\n              }),\n            ),\n          };\n        },\n        { streaming: true, version: 'v1' }, // Don't auto-end span, we'll end it when stream completes\n      );\n    },\n  };\n}\n\n/**\n * Creates unified Axiom telemetry middleware that works with both V1 and V2 models\n */\nexport function axiomAIMiddleware(config: { model: LanguageModelV1 }): LanguageModelV1Middleware;\nexport function axiomAIMiddleware(config: { model: LanguageModelV2 }): LanguageModelV2Middleware;\nexport function axiomAIMiddleware(config: { model: LanguageModelV1 | LanguageModelV2 }) {\n  if (config.model.specificationVersion === 'v1') {\n    return axiomAIMiddlewareV1();\n  } else if (config.model.specificationVersion === 'v2') {\n    return axiomAIMiddlewareV2();\n  } else {\n    console.warn(\n      // @ts-expect-error - not allowed at type level, but users can still do it...\n      `Unsupported model specification version: ${JSON.stringify(config.model.specificationVersion)}. Creating no-op middleware instead.`,\n    );\n    return {};\n  }\n}\n\n/**\n * Creates Axiom telemetry middleware for LanguageModelV2\n */\nexport function axiomAIMiddlewareV2(/* _config?: AxiomTelemetryConfig */): LanguageModelV2Middleware {\n  return {\n    wrapGenerate: async ({ doGenerate, params, model }) => {\n      return withSpanHandling(\n        model.modelId,\n        async (span, commonContext, _lease) => {\n          const context = commonContext as GenAiSpanContextV2;\n\n          appendPromptMetadataToSpan(span, params.prompt);\n\n          // Pre-call setup\n          setScopeAttributes(span);\n          setPreCallAttributesV2(span, params, context, model);\n\n          const res = await doGenerate();\n\n          // Post-call processing\n          await setPostCallAttributesV2(span, res, context, model);\n\n          return res;\n        },\n        { version: 'v2' },\n      );\n    },\n\n    wrapStream: async ({ doStream, params, model }) => {\n      return withSpanHandling(\n        model.modelId,\n        async (span, commonContext, lease) => {\n          const context = commonContext as GenAiSpanContextV2;\n\n          appendPromptMetadataToSpan(span, params.prompt);\n\n          // Pre-call setup\n          setScopeAttributes(span);\n          setPreCallAttributesV2(span, params, context, model);\n\n          const ret = await doStream();\n\n          // Create child span for stream processing (provides granular visibility)\n          const childSpan = createStreamChildSpan(span, `chat ${model.modelId} stream`);\n\n          const stats = new StreamStatsV2();\n          const toolAggregator = new ToolCallAggregatorV2();\n          const textAggregator = new TextAggregatorV2();\n\n          return {\n            ...ret,\n            stream: ret.stream.pipeThrough(\n              new TransformStream({\n                transform(chunk: LanguageModelV2StreamPart, controller) {\n                  try {\n                    stats.feed(chunk);\n                    toolAggregator.handleChunk(chunk);\n                    textAggregator.feed(chunk);\n\n                    controller.enqueue(chunk);\n                  } catch (err) {\n                    classifyToolError(err, childSpan);\n                    childSpan.end();\n                    if (lease.owned) lease.end();\n                    controller.error(err);\n                  }\n                },\n                async flush(controller) {\n                  try {\n                    const streamResult = {\n                      ...stats.result,\n                      content: [\n                        ...(textAggregator.text\n                          ? [{ type: 'text' as const, text: textAggregator.text }]\n                          : []),\n                        ...toolAggregator.result,\n                      ],\n                    };\n\n                    await setPostCallAttributesV2(span, streamResult, context, model);\n\n                    childSpan.end();\n                    if (lease.owned) lease.end();\n                    controller.terminate();\n                  } catch (err) {\n                    classifyToolError(err, childSpan);\n                    childSpan.end();\n                    if (lease.owned) lease.end();\n                    controller.error(err);\n                  }\n                },\n              }),\n            ),\n          };\n        },\n        { streaming: true, version: 'v2' }, // Don't auto-end span, we'll end it when stream completes\n      );\n    },\n  };\n}\n\n// V1 helper functions (extracted from AxiomWrappedLanguageModelV1)\nfunction setPreCallAttributesV1(\n  span: Span,\n  options: LanguageModelV1CallOptions,\n  context: GenAiSpanContextV1,\n  model: LanguageModelV1,\n) {\n  const redactionPolicy = getRedactionPolicy();\n\n  const {\n    prompt,\n    maxTokens,\n    frequencyPenalty,\n    presencePenalty,\n    temperature,\n    topP,\n    topK,\n    seed,\n    stopSequences,\n    responseFormat,\n    mode,\n  } = options;\n\n  // Set prompt attributes (full conversation history)\n  const processedPrompt = promptV1ToOpenAI(prompt);\n  context.originalPrompt = processedPrompt;\n\n  handleMaybeRedactedAttribute(\n    span,\n    Attr.GenAI.Input.Messages,\n    JSON.stringify(sanitizeMultimodalContent(processedPrompt)),\n    redactionPolicy.captureMessageContent,\n  );\n\n  setBaseAttributes(span, model.provider, model.modelId);\n\n  const outputType = determineOutputTypeV1({ responseFormat, mode });\n  if (outputType) {\n    span.setAttribute(Attr.GenAI.Output.Type, outputType);\n  }\n\n  setRequestParameterAttributes(span, {\n    maxTokens,\n    frequencyPenalty,\n    presencePenalty,\n    temperature,\n    topP,\n    topK,\n    seed,\n    stopSequences,\n  });\n}\n\nasync function setPostCallAttributesV1(\n  span: Span,\n  result: any,\n  context: GenAiSpanContextV1,\n  _model: LanguageModelV1,\n) {\n  const redactionPolicy = getRedactionPolicy();\n\n  // Update prompt to include tool calls and tool results if they exist\n  if (result.toolCalls && result.toolCalls.length > 0) {\n    const originalPrompt = context.originalPrompt || [];\n\n    // Normalize the tool calls to the common format\n    const normalizedToolCalls = normalizeV1ToolCalls(result.toolCalls);\n\n    // Note: rawCall might not be available in middleware, handle gracefully\n    const toolResultsMap = context.rawCall?.rawPrompt\n      ? extractToolResultsFromRawPrompt(context.rawCall.rawPrompt as any[])\n      : new Map();\n\n    const updatedPrompt = appendToolCalls(\n      originalPrompt,\n      normalizedToolCalls,\n      toolResultsMap,\n      result.text,\n    );\n\n    handleMaybeRedactedAttribute(\n      span,\n      Attr.GenAI.Input.Messages,\n      JSON.stringify(sanitizeMultimodalContent(updatedPrompt)),\n      redactionPolicy.captureMessageContent,\n    );\n  }\n\n  // Create simple completion array with just assistant text\n  if (result.text) {\n    const completion = createSimpleCompletion({\n      text: result.text,\n    });\n    handleMaybeRedactedAttribute(\n      span,\n      Attr.GenAI.Output.Messages,\n      JSON.stringify(completion),\n      redactionPolicy.captureMessageContent,\n    );\n  }\n\n  if (result.response?.id) {\n    span.setAttribute(Attr.GenAI.Response.ID, result.response.id);\n  }\n  if (result.response?.modelId) {\n    span.setAttribute(Attr.GenAI.Response.Model, result.response.modelId);\n  }\n\n  const inputTokens = ensureNumber(result.usage?.promptTokens);\n  if (inputTokens !== undefined) {\n    span.setAttribute(Attr.GenAI.Usage.InputTokens, inputTokens);\n  }\n\n  const outputTokens = ensureNumber(result.usage?.completionTokens);\n  if (outputTokens !== undefined) {\n    span.setAttribute(Attr.GenAI.Usage.OutputTokens, outputTokens);\n  }\n\n  if (result.finishReason) {\n    span.setAttribute(Attr.GenAI.Response.FinishReasons, JSON.stringify([result.finishReason]));\n  }\n}\n\n// V2 helper functions (extracted from AxiomWrappedLanguageModelV2)\nfunction setPreCallAttributesV2(\n  span: Span,\n  options: LanguageModelV2CallOptions,\n  context: GenAiSpanContextV2,\n  model: LanguageModelV2,\n) {\n  const redactionPolicy = getRedactionPolicy();\n\n  setBaseAttributes(span, model.provider, model.modelId);\n\n  const outputType = determineOutputTypeV2(options);\n  if (outputType) {\n    span.setAttribute(Attr.GenAI.Output.Type, outputType);\n  }\n\n  setRequestParameterAttributes(span, {\n    maxTokens: options.maxOutputTokens,\n    frequencyPenalty: options.frequencyPenalty,\n    presencePenalty: options.presencePenalty,\n    temperature: options.temperature,\n    topP: options.topP,\n    topK: options.topK,\n    seed: options.seed,\n    stopSequences: options.stopSequences,\n  });\n\n  const processedPrompt = promptV2ToOpenAI(options.prompt);\n\n  // Store both the original V2 prompt and processed prompt for later use\n  context.originalV2Prompt = options.prompt;\n  context.originalPrompt = processedPrompt;\n\n  handleMaybeRedactedAttribute(\n    span,\n    Attr.GenAI.Input.Messages,\n    JSON.stringify(sanitizeMultimodalContent(processedPrompt)),\n    redactionPolicy.captureMessageContent,\n  );\n}\n\nasync function setPostCallAttributesV2(\n  span: Span,\n  result: {\n    response?: LanguageModelV2ResponseMetadata;\n    finishReason?: LanguageModelV2FinishReason;\n    usage?: LanguageModelV2Usage;\n    content?: Array<LanguageModelV2Content>;\n  },\n  context: GenAiSpanContextV2,\n  _model: LanguageModelV2,\n) {\n  const redactionPolicy = getRedactionPolicy();\n\n  // Check if we have tool calls in this response\n  const toolCalls = result.content?.filter(\n    (c) => c.type === 'tool-call',\n  ) as LanguageModelV2ToolCall[];\n\n  // Only set response metadata once per span to prevent overwriting when generateText() makes multiple calls\n  const alreadySet = (span as any).attributes?.[Attr.GenAI.Response.FinishReasons] !== undefined;\n\n  if (!alreadySet) {\n    if (result.response?.id) {\n      span.setAttribute(Attr.GenAI.Response.ID, result.response.id);\n    }\n    if (result.response?.modelId) {\n      span.setAttribute(Attr.GenAI.Response.Model, result.response.modelId);\n    }\n\n    const inputTokens = ensureNumber(result.usage?.inputTokens);\n    if (inputTokens !== undefined) {\n      span.setAttribute(Attr.GenAI.Usage.InputTokens, inputTokens);\n    }\n\n    const outputTokens = ensureNumber(result.usage?.outputTokens);\n    if (outputTokens !== undefined) {\n      span.setAttribute(Attr.GenAI.Usage.OutputTokens, outputTokens);\n    }\n  }\n\n  // Update prompt to include tool calls and tool results if they exist\n  if (toolCalls && toolCalls.length > 0) {\n    const originalPrompt = context.originalPrompt || [];\n\n    const normalizedToolCalls = normalizeV2ToolCalls(toolCalls);\n\n    // Extract real tool results from the original V2 prompt structure\n    const toolResultsMap = extractToolResultsFromPromptV2(context.originalV2Prompt || []);\n\n    // Extract assistant text content from the response\n    const textContent = result.content?.find((c) => c.type === 'text');\n    const assistantText = textContent?.type === 'text' ? textContent.text : undefined;\n\n    // Use the standard prompt utility to append tool calls\n    const updatedPrompt = appendToolCalls(\n      originalPrompt,\n      normalizedToolCalls,\n      toolResultsMap,\n      assistantText,\n    );\n\n    // Update the prompt attribute with the complete conversation history\n    handleMaybeRedactedAttribute(\n      span,\n      Attr.GenAI.Input.Messages,\n      JSON.stringify(sanitizeMultimodalContent(updatedPrompt)),\n      redactionPolicy.captureMessageContent,\n    );\n  }\n\n  // Process tool calls and create child spans\n  if (result.content && result.content.length > 0) {\n    await processToolCallsAndCreateSpansV2(span, result.content);\n  } else if (result.finishReason) {\n    // For non-tool responses, still create completion array\n    const completion = createSimpleCompletion({\n      text: '',\n    });\n    handleMaybeRedactedAttribute(\n      span,\n      Attr.GenAI.Output.Messages,\n      JSON.stringify(completion),\n      redactionPolicy.captureMessageContent,\n    );\n  }\n\n  // Store finish reason separately as per semantic conventions (only on first call to prevent overwriting)\n  if (result.finishReason && !alreadySet) {\n    span.setAttribute(Attr.GenAI.Response.FinishReasons, JSON.stringify([result.finishReason]));\n  }\n}\n\nasync function processToolCallsAndCreateSpansV2(\n  parentSpan: Span,\n  content: Array<LanguageModelV2Content>,\n): Promise<void> {\n  const redactionPolicy = getRedactionPolicy();\n\n  // Extract text and tool calls from content\n  const textContent = content.find((c) => c.type === 'text');\n  const assistantText = textContent?.type === 'text' ? textContent.text : undefined;\n  const toolCalls = content.filter((c) => c.type === 'tool-call') as LanguageModelV2ToolCall[];\n\n  // Only set completion for final responses without tool calls\n  if (toolCalls.length === 0) {\n    // Create completion with multimodal content support\n    const completion = [\n      {\n        role: 'assistant' as const,\n        content: sanitizeMultimodalContent(\n          content.length === 1 && assistantText ? assistantText : content,\n        ),\n      },\n    ];\n\n    // Set completion array as span attribute\n    handleMaybeRedactedAttribute(\n      parentSpan,\n      Attr.GenAI.Output.Messages,\n      JSON.stringify(completion),\n      redactionPolicy.captureMessageContent,\n    );\n  }\n}\n","/**\n * Utility functions for formatting tool calls in completion array format\n */\n\nimport type { LanguageModelV1FunctionToolCall } from '@ai-sdk/providerv1';\nimport { sanitizeMultimodalContent } from './utils/contentSanitizer';\nimport type {\n  CompletionArray,\n  FormatToolCallsOptions,\n  FormattedCompletionResult,\n} from './completionTypes';\nimport type { OpenAIMessage, OpenAIAssistantMessage, OpenAIToolMessage } from './vercelTypes';\n\n/**\n * Converts OpenAI messages to completion array format\n */\nfunction convertToCompletionMessages(messages: OpenAIMessage[]): OpenAIMessage[] {\n  return messages.map((message): OpenAIMessage => {\n    switch (message.role) {\n      case 'system':\n        return {\n          role: 'system',\n          content: message.content,\n        };\n\n      case 'user':\n        return {\n          role: 'user',\n          content: sanitizeMultimodalContent(message.content) as string | any[],\n        };\n\n      case 'assistant':\n        return {\n          role: 'assistant',\n          content: sanitizeMultimodalContent(message.content) as string | null,\n          tool_calls: message.tool_calls?.map((toolCall) => ({\n            id: toolCall.id,\n            type: 'function' as const,\n            function: {\n              name: toolCall.function.name,\n              arguments: toolCall.function.arguments,\n            },\n          })),\n        };\n\n      case 'tool':\n        return {\n          role: 'tool',\n          content: message.content,\n          tool_call_id: message.tool_call_id,\n        };\n\n      default:\n        throw new Error(`Unknown message role: ${(message as any).role}`);\n    }\n  });\n}\n\n/**\n * Creates tool result messages from tool execution results\n */\nfunction createToolResultMessages(\n  toolResults: Array<{\n    toolCallId: string;\n    result: unknown;\n  }>,\n): OpenAIToolMessage[] {\n  return toolResults.map((result) => ({\n    role: 'tool' as const,\n    content: typeof result.result === 'string' ? result.result : JSON.stringify(result.result),\n    tool_call_id: result.toolCallId,\n  }));\n}\n\n/**\n * Main function to format tool calls in completion array format\n * Transforms AI SDK tool calls into the completion array structure\n */\nexport function formatToolCallsInCompletion(\n  options: FormatToolCallsOptions,\n): FormattedCompletionResult {\n  const { promptMessages = [], text, toolCalls = [], toolResults = [] } = options;\n\n  // Convert prompt messages to completion format\n  const historyMessages = convertToCompletionMessages(promptMessages);\n\n  // Create assistant message with tool calls\n  const assistantMessage: OpenAIAssistantMessage = {\n    role: 'assistant',\n    content: text ?? (toolCalls.length > 0 ? null : ''),\n  };\n\n  // Add tool calls if present\n  if (toolCalls.length > 0) {\n    assistantMessage.tool_calls = toolCalls.map((toolCall) => ({\n      id: toolCall.id,\n      type: 'function' as const,\n      function: {\n        name: toolCall.toolName,\n        arguments: toolCall.args,\n      },\n    }));\n  }\n\n  // Create tool result messages\n  const toolMessages = createToolResultMessages(toolResults);\n\n  // Build complete completion array\n  const completion: CompletionArray = [...historyMessages, assistantMessage, ...toolMessages];\n\n  return {\n    completion,\n    assistantMessage,\n    toolMessages,\n  };\n}\n\n/**\n * Creates a simple completion array with just assistant text response\n * Used for V1 model wrapper where tool calls are handled separately\n */\nexport function createSimpleCompletion({ text }: { text?: string }): CompletionArray {\n  // Create assistant message with text only\n  const assistantMessage: OpenAIAssistantMessage = {\n    role: 'assistant',\n    content: text ?? '',\n  };\n\n  return [assistantMessage];\n}\n\n/**\n * Formats V2 tool calls for completion array\n * Convenience function for V2 model wrapper\n */\nexport function formatV2ToolCallsInCompletion({\n  promptMessages = [],\n  text,\n  toolCalls = [],\n}: {\n  promptMessages?: OpenAIMessage[];\n  text?: string;\n  toolCalls?: Array<{\n    toolCallId: string;\n    toolName: string;\n    args: unknown;\n  }>;\n}): CompletionArray {\n  // Convert prompt messages\n  const historyMessages = convertToCompletionMessages(promptMessages);\n\n  // Create assistant message\n  const assistantMessage: OpenAIAssistantMessage = {\n    role: 'assistant',\n    content: text ?? (toolCalls.length > 0 ? null : ''),\n  };\n\n  // Add tool calls if present\n  if (toolCalls.length > 0) {\n    assistantMessage.tool_calls = toolCalls.map((toolCall) => ({\n      id: toolCall.toolCallId,\n      type: 'function' as const,\n      function: {\n        name: toolCall.toolName,\n        arguments:\n          typeof toolCall.args === 'string' ? toolCall.args : JSON.stringify(toolCall.args),\n      },\n    }));\n  }\n\n  return [...historyMessages, assistantMessage];\n}\n\n/**\n * Aggregates tool call chunks for streaming responses\n * Handles partial tool calls and builds complete tool call objects\n */\nexport function aggregateStreamingToolCalls(\n  chunks: Array<{\n    toolCallId?: string;\n    toolName?: string;\n    argsTextDelta?: string;\n  }>,\n): LanguageModelV1FunctionToolCall[] {\n  const toolCallMap = new Map<\n    string,\n    {\n      toolCallId: string;\n      toolName: string;\n      args: string;\n    }\n  >();\n\n  for (const chunk of chunks) {\n    if (!chunk.toolCallId) continue;\n\n    const existing = toolCallMap.get(chunk.toolCallId);\n    if (existing) {\n      // Append args delta\n      existing.args += chunk.argsTextDelta || '';\n    } else {\n      // Create new tool call entry\n      toolCallMap.set(chunk.toolCallId, {\n        toolCallId: chunk.toolCallId,\n        toolName: chunk.toolName || '',\n        args: chunk.argsTextDelta || '',\n      });\n    }\n  }\n\n  return Array.from(toolCallMap.values()).map((call) => ({\n    ...call,\n    toolCallType: 'function' as const,\n  }));\n}\n","/**\n * Utilities for sanitizing multimodal content in telemetry data\n * Replaces large binary content with metadata while preserving structure\n */\n\nimport { createHash } from 'crypto';\n\ninterface ImageMetadata {\n  format?: string;\n  size_bytes?: number;\n  hash: string;\n  is_data_url: boolean;\n  dimensions?: string;\n}\n\n/**\n * Extracts metadata from an image URL (data URL or external URL)\n */\nfunction extractImageMetadata(url: string): ImageMetadata {\n  if (url.startsWith('data:')) {\n    // Parse data URL: data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...\n    const [header, base64Data] = url.split(',');\n    const formatMatch = header.match(/data:image\\/(\\w+)/);\n    const format = formatMatch?.[1];\n\n    // Estimate size from base64 data\n    const sizeBytes = base64Data ? Math.floor((base64Data.length * 3) / 4) : 0;\n\n    // Create a short hash of the content for identification\n    const hash = base64Data\n      ? createHash('sha256').update(base64Data).digest('hex').slice(0, 16)\n      : 'unknown';\n\n    return {\n      format,\n      size_bytes: sizeBytes,\n      hash,\n      is_data_url: true,\n    };\n  } else {\n    // External URL - create hash of the URL itself\n    const hash = createHash('sha256').update(url).digest('hex').slice(0, 16);\n    return {\n      hash,\n      is_data_url: false,\n    };\n  }\n}\n\n/**\n * Sanitizes an image URL by replacing large data URLs with metadata\n */\nfunction sanitizeImageUrl(url: string, detail?: string) {\n  const metadata = extractImageMetadata(url);\n\n  if (metadata.is_data_url) {\n    // Replace data URL with reference\n    const formatPart = metadata.format ? `:${metadata.format}` : '';\n    const sizePart = metadata.size_bytes ? `:${metadata.size_bytes}b` : '';\n    return {\n      url: `[IMAGE${formatPart}${sizePart}:${metadata.hash}]`,\n      detail,\n      ...metadata,\n    };\n  } else {\n    // Keep external URLs but add metadata\n    return {\n      url,\n      detail,\n      ...metadata,\n    };\n  }\n}\n\ntype SanitizedContent<T> = T extends readonly unknown[] ? unknown[] : T;\n\n/**\n * Sanitizes any multimodal content for telemetry purposes\n * This is the main function that should be used throughout the codebase\n */\nexport function sanitizeMultimodalContent<T>(content: T): SanitizedContent<T> {\n  if (Array.isArray(content)) {\n    return content.map((part) => {\n      if (part && typeof part === 'object' && 'type' in part && part.type === 'image_url') {\n        const imagePart = part;\n        if (imagePart.image_url?.url) {\n          return {\n            ...part,\n            image_url: sanitizeImageUrl(imagePart.image_url.url, imagePart.image_url.detail),\n          };\n        }\n      }\n      return part;\n    }) as SanitizedContent<T>;\n  }\n\n  return content as SanitizedContent<T>;\n}\n","import type { LanguageModelV1FunctionToolCall } from '@ai-sdk/providerv1';\nimport type { NormalizedToolCall } from '../otel/utils/normalized';\nimport type { LanguageModelV2Prompt } from '@ai-sdk/providerv2';\nimport type { OpenAIMessage } from '../otel/vercelTypes';\n\nexport type ToolResultMap = Map<string, unknown>;\n\n/**\n * Appends tool calls and their results to a conversation prompt.\n *\n * This function takes an existing conversation prompt and adds:\n * 1. An assistant message containing the tool calls\n * 2. Tool result messages for each tool call with results\n *\n * @param prompt - The existing conversation prompt\n * @param toolCalls - The tool calls made by the assistant\n * @param toolResults - Map of tool names to their results\n * @param assistantContent - Optional assistant message content to include with tool calls\n * @returns Updated prompt with tool calls and results appended\n */\nexport function appendToolCalls(\n  prompt: OpenAIMessage[],\n  toolCalls: LanguageModelV1FunctionToolCall[] | NormalizedToolCall[],\n  toolResults: ToolResultMap,\n  assistantContent?: string | null,\n): OpenAIMessage[] {\n  const updatedPrompt = [...prompt];\n\n  // Add assistant message with tool calls\n  updatedPrompt.push({\n    role: 'assistant',\n    content: assistantContent || null,\n    tool_calls: toolCalls.map((toolCall) => ({\n      id: toolCall.toolCallId,\n      function: {\n        name: toolCall.toolName,\n        arguments:\n          typeof toolCall.args === 'string' ? toolCall.args : JSON.stringify(toolCall.args),\n      },\n      type: 'function',\n    })),\n  });\n\n  // Add tool result messages with real data\n  for (const toolCall of toolCalls) {\n    const realToolResult = toolResults.get(toolCall.toolName);\n\n    if (realToolResult) {\n      updatedPrompt.push({\n        role: 'tool',\n        tool_call_id: toolCall.toolCallId,\n        content: JSON.stringify(realToolResult),\n      });\n    }\n  }\n\n  return updatedPrompt;\n}\n\n/**\n * Extracts tool results from a raw prompt array.\n *\n * Searches through different message formats to find tool results:\n * - Google AI format: user messages with functionResponse parts\n * - OpenAI format: tool role messages (future enhancement)\n *\n * @param rawPrompt - The raw prompt array from the model provider\n * @returns Map of tool names to their results\n */\n// TODO: @cje - This should be typed based on the specific provider's raw prompt format\n// but it needs to handle multiple providers (Google AI, OpenAI, etc.)\nexport function extractToolResultsFromRawPrompt(rawPrompt: any[]): Map<string, unknown> {\n  const toolResultsMap = new Map<string, unknown>();\n\n  if (!Array.isArray(rawPrompt)) {\n    return toolResultsMap;\n  }\n\n  // Look for tool results in different message formats\n  for (const message of rawPrompt) {\n    // Google AI format: user message with functionResponse parts\n    if (message?.role === 'user' && Array.isArray(message.parts)) {\n      for (const part of message.parts) {\n        if (part?.functionResponse) {\n          const functionResponse = part.functionResponse;\n          if (functionResponse.name && functionResponse.response) {\n            // Store by function name since that's what we have access to\n            toolResultsMap.set(\n              functionResponse.name,\n              functionResponse.response.content || functionResponse.response,\n            );\n          }\n        }\n      }\n    }\n\n    // OpenAI format: tool role messages with tool_call_id\n    if (message?.role === 'tool' && message?.tool_call_id && message?.content) {\n      // For OpenAI format, we'd need to map back from tool_call_id to tool name\n      // This is more complex as we'd need to track the tool calls first\n      // For now, we'll skip this but it could be implemented later\n    }\n  }\n\n  return toolResultsMap;\n}\n\n/**\n * Extracts tool results from a V2 prompt structure.\n *\n * V2 prompts use a \"parts\" array structure where:\n * - Tool calls are in assistant messages as 'tool-call' parts\n * - Tool results are in 'tool' role messages as 'tool-result' parts with 'output' property\n *\n * @param prompt - The V2 prompt array\n * @returns Map of tool names to their results\n */\nexport function extractToolResultsFromPromptV2(\n  prompt: LanguageModelV2Prompt,\n): Map<string, unknown> {\n  const idToName = new Map<string, string>();\n  const results = new Map<string, unknown>();\n\n  // 1. Collect tool-call ids โ names from assistant messages\n  for (const message of prompt) {\n    if (message.role === 'assistant' && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        if (part.type === 'tool-call') {\n          idToName.set(part.toolCallId, part.toolName);\n        }\n      }\n    }\n  }\n\n  // 2. Collect tool results from tool role messages\n  for (const message of prompt) {\n    if (message.role === 'tool' && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        // In V2, tool result parts have toolCallId and result properties\n        if (part.toolCallId && part.output !== undefined) {\n          const toolName = idToName.get(part.toolCallId);\n          if (toolName) {\n            results.set(toolName, part.output);\n          }\n        }\n      }\n    }\n  }\n\n  return results;\n}\n","import type {\n  LanguageModelV1Prompt,\n  LanguageModelV1FunctionToolCall,\n  LanguageModelV1TextPart,\n  LanguageModelV1ToolCallPart,\n} from '@ai-sdk/providerv1';\nimport type {\n  LanguageModelV2Prompt,\n  LanguageModelV2ToolCall,\n  LanguageModelV2TextPart,\n  LanguageModelV2ToolCallPart,\n  LanguageModelV2ToolResultOutput,\n} from '@ai-sdk/providerv2';\nimport type { OpenAIMessage, OpenAIContentPart } from '../vercelTypes';\n\n/**\n * Normalized tool call interface that can represent both V1 and V2 tool calls\n */\nexport interface NormalizedToolCall {\n  toolCallId: string;\n  toolName: string;\n  args: string; // Always a JSON string for consistency\n  toolCallType: 'function';\n}\n\n/**\n * Normalized result interface for both V1 and V2 generation results\n */\nexport interface NormalizedResult {\n  text?: string;\n  toolCalls?: NormalizedToolCall[];\n  response?: { id?: string; modelId?: string };\n  usage?: {\n    promptTokens?: number;\n    completionTokens?: number;\n    inputTokens?: number;\n    outputTokens?: number;\n  };\n  finishReason?: string;\n}\n\n/**\n * Normalizes a V1 tool call to the common format\n */\nfunction normalizeV1ToolCall(toolCall: LanguageModelV1FunctionToolCall): NormalizedToolCall {\n  return {\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    args: typeof toolCall.args === 'string' ? toolCall.args : JSON.stringify(toolCall.args),\n    toolCallType: 'function',\n  };\n}\n\n/**\n * Normalizes a V2 tool call to the common format\n */\nfunction normalizeV2ToolCall(toolCall: LanguageModelV2ToolCall): NormalizedToolCall {\n  return {\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    args:\n      typeof toolCall.input === 'string'\n        ? toolCall.input.replace(/:\\s+/g, ':')\n        : JSON.stringify(toolCall.input),\n    toolCallType: 'function',\n  };\n}\n\n/**\n * Normalizes an array of V1 tool calls\n */\nexport function normalizeV1ToolCalls(\n  toolCalls: LanguageModelV1FunctionToolCall[],\n): NormalizedToolCall[] {\n  return toolCalls.map(normalizeV1ToolCall);\n}\n\n/**\n * Normalizes an array of V2 tool calls\n */\nexport function normalizeV2ToolCalls(toolCalls: LanguageModelV2ToolCall[]): NormalizedToolCall[] {\n  return toolCalls.map(normalizeV2ToolCall);\n}\n\n/**\n * Converts a V1 prompt to OpenAI message format\n */\nexport function promptV1ToOpenAI(prompt: LanguageModelV1Prompt): OpenAIMessage[] {\n  const results: OpenAIMessage[] = [];\n\n  for (const message of prompt) {\n    switch (message.role) {\n      case 'system':\n        results.push({\n          role: 'system',\n          content: message.content,\n        });\n        break;\n\n      case 'assistant':\n        const textPart = message.content.find((part) => part.type === 'text') as\n          | LanguageModelV1TextPart\n          | undefined;\n        const toolCallParts = message.content.filter(\n          (part) => part.type === 'tool-call',\n        ) as LanguageModelV1ToolCallPart[];\n\n        results.push({\n          role: 'assistant',\n          content: textPart?.text || null,\n          ...(toolCallParts.length > 0\n            ? {\n                tool_calls: toolCallParts.map((part) => ({\n                  id: part.toolCallId,\n                  function: {\n                    name: part.toolName,\n                    arguments: JSON.stringify(part.args),\n                  },\n                  type: 'function',\n                })),\n              }\n            : {}),\n        });\n        break;\n\n      case 'user':\n        results.push({\n          role: 'user',\n          content: message.content.map((part): OpenAIContentPart => {\n            switch (part.type) {\n              case 'text':\n                return {\n                  type: 'text',\n                  text: part.text,\n                };\n              case 'image':\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url: part.image.toString(),\n                  },\n                };\n              default:\n                // Convert unknown content types to text for compatibility\n                return {\n                  type: 'text',\n                  text:\n                    `[${part.type}]` +\n                    (typeof part === 'object' && part !== null\n                      ? JSON.stringify(part)\n                      : String(part)),\n                };\n            }\n          }),\n        });\n        break;\n\n      case 'tool':\n        for (const part of message.content) {\n          results.push({\n            role: 'tool',\n            tool_call_id: part.toolCallId,\n            content: JSON.stringify(part.result),\n          });\n        }\n        break;\n    }\n  }\n\n  return results;\n}\n\n/**\n * Converts a V2 prompt to OpenAI message format\n */\nexport function promptV2ToOpenAI(prompt: LanguageModelV2Prompt): OpenAIMessage[] {\n  const results: OpenAIMessage[] = [];\n\n  for (const message of prompt) {\n    switch (message.role) {\n      case 'system':\n        results.push({\n          role: 'system',\n          content: message.content,\n        });\n        break;\n\n      case 'assistant':\n        const textContent = message.content.find(\n          (part): part is LanguageModelV2TextPart => part.type === 'text',\n        );\n        const toolCalls = message.content.filter(\n          (part): part is LanguageModelV2ToolCallPart => part.type === 'tool-call',\n        );\n\n        results.push({\n          role: 'assistant',\n          content: textContent?.text || null,\n          ...(toolCalls.length > 0\n            ? {\n                tool_calls: toolCalls.map((part) => ({\n                  id: part.toolCallId,\n                  function: {\n                    name: part.toolName,\n                    arguments:\n                      typeof part.input === 'string' ? part.input : JSON.stringify(part.input),\n                  },\n                  type: 'function',\n                })),\n              }\n            : {}),\n        });\n        break;\n\n      case 'user':\n        results.push({\n          role: 'user',\n          content: message.content.map((part: any) => {\n            switch (part.type) {\n              case 'text':\n                return {\n                  type: 'text',\n                  text: part.text,\n                };\n              case 'image':\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url: part.image.toString(),\n                  },\n                };\n              default:\n                // Handle unknown content types by passing them through\n                return part as any;\n            }\n          }),\n        });\n        break;\n\n      case 'tool':\n        for (const part of message.content) {\n          results.push({\n            role: 'tool',\n            tool_call_id: part.toolCallId,\n            content: formatV2ToolCallOutput(part.output),\n          });\n        }\n        break;\n    }\n  }\n\n  return results;\n}\n\nfunction formatV2ToolCallOutput(output: LanguageModelV2ToolResultOutput) {\n  switch (output.type) {\n    case 'text':\n      return output.value;\n    case 'json':\n      return typeof output.value === 'string' ? output.value : JSON.stringify(output.value);\n    case 'error-text':\n      return output.value;\n    case 'error-json':\n      return typeof output.value === 'string' ? output.value : JSON.stringify(output.value);\n    case 'content':\n      return JSON.stringify(output.value);\n  }\n}\n","import {\n  type LanguageModelV1StreamPart,\n  type LanguageModelV1FunctionToolCall,\n  type LanguageModelV1FinishReason,\n} from '@ai-sdk/providerv1';\n\nimport {\n  type LanguageModelV2StreamPart,\n  type LanguageModelV2ToolCall,\n  type LanguageModelV2FinishReason,\n  type LanguageModelV2Usage,\n  type LanguageModelV2ResponseMetadata,\n} from '@ai-sdk/providerv2';\n\nimport { currentUnixTime } from '../../util/currentUnixTime';\n\n// V1-specific aggregators (the original ones)\nexport class ToolCallAggregator {\n  private readonly calls: Record<string, LanguageModelV1FunctionToolCall> = {};\n\n  handleChunk(chunk: LanguageModelV1StreamPart): void {\n    switch (chunk.type) {\n      case 'tool-call':\n        this.calls[chunk.toolCallId] = {\n          toolCallType: chunk.toolCallType,\n          toolCallId: chunk.toolCallId,\n          toolName: chunk.toolName,\n          args: chunk.args,\n        };\n        break;\n      case 'tool-call-delta':\n        if (!this.calls[chunk.toolCallId]) {\n          this.calls[chunk.toolCallId] = {\n            toolCallType: chunk.toolCallType,\n            toolCallId: chunk.toolCallId,\n            toolName: chunk.toolName,\n            args: '',\n          };\n        }\n        this.calls[chunk.toolCallId].args += chunk.argsTextDelta;\n        break;\n    }\n  }\n\n  get result(): LanguageModelV1FunctionToolCall[] {\n    return Object.values(this.calls);\n  }\n}\n\nexport class TextAggregator {\n  private content = '';\n\n  feed(chunk: LanguageModelV1StreamPart): void {\n    if (chunk.type === 'text-delta') {\n      this.content += chunk.textDelta;\n    }\n  }\n\n  get text(): string | undefined {\n    return this.content || undefined;\n  }\n}\n\nexport class StreamStats {\n  private startTime: number;\n  private timeToFirstToken?: number;\n  private _usage?: { promptTokens: number; completionTokens: number };\n  private _finishReason?: LanguageModelV1FinishReason;\n  private _responseId?: string;\n  private _responseModelId?: string;\n\n  constructor() {\n    this.startTime = currentUnixTime();\n  }\n\n  feed(chunk: LanguageModelV1StreamPart): void {\n    // Track time to first token on any chunk\n    if (this.timeToFirstToken === undefined) {\n      this.timeToFirstToken = currentUnixTime() - this.startTime;\n    }\n\n    switch (chunk.type) {\n      case 'response-metadata':\n        if (chunk.id) {\n          this._responseId = chunk.id;\n        }\n        if (chunk.modelId) {\n          this._responseModelId = chunk.modelId;\n        }\n\n        break;\n      case 'finish':\n        this._usage = chunk.usage;\n        this._finishReason = chunk.finishReason;\n        break;\n    }\n  }\n\n  get result() {\n    return {\n      response:\n        this._responseId || this._responseModelId\n          ? {\n              id: this._responseId,\n              modelId: this._responseModelId,\n            }\n          : undefined,\n      finishReason: this._finishReason,\n      usage: this._usage,\n    };\n  }\n\n  get firstTokenTime(): number | undefined {\n    return this.timeToFirstToken;\n  }\n}\n\n// V2-specific aggregators\nexport class ToolCallAggregatorV2 {\n  private readonly calls: Record<string, LanguageModelV2ToolCall> = {};\n\n  handleChunk(chunk: LanguageModelV2StreamPart): void {\n    if (chunk.type === 'tool-call') {\n      this.calls[chunk.toolCallId] = chunk;\n    }\n  }\n\n  get result(): LanguageModelV2ToolCall[] {\n    return Object.values(this.calls);\n  }\n}\n\nexport class TextAggregatorV2 {\n  private content = '';\n\n  feed(chunk: LanguageModelV2StreamPart): void {\n    // TODO: @cje - is this enough?\n    switch (chunk.type) {\n      case 'text-start':\n        this.content = '';\n        break;\n      case 'text-delta':\n        this.content += chunk.delta;\n        break;\n      case 'text-end':\n        break;\n    }\n  }\n\n  get text(): string | undefined {\n    return this.content || undefined;\n  }\n}\n\nexport class StreamStatsV2 {\n  private startTime: number;\n  private timeToFirstToken?: number;\n  private _usage?: LanguageModelV2Usage;\n  private _finishReason?: LanguageModelV2FinishReason;\n  private _responseMetadata?: LanguageModelV2ResponseMetadata;\n\n  constructor() {\n    this.startTime = currentUnixTime();\n  }\n\n  feed(chunk: LanguageModelV2StreamPart): void {\n    // Track time to first token on any chunk\n    if (this.timeToFirstToken === undefined) {\n      this.timeToFirstToken = currentUnixTime() - this.startTime;\n    }\n\n    switch (chunk.type) {\n      case 'response-metadata':\n        this._responseMetadata = {\n          id: chunk.id,\n          modelId: chunk.modelId,\n          timestamp: chunk.timestamp,\n        };\n        break;\n      case 'finish':\n        this._usage = chunk.usage;\n        this._finishReason = chunk.finishReason;\n        break;\n    }\n  }\n\n  get result() {\n    return {\n      response: this._responseMetadata,\n      finishReason: this._finishReason,\n      usage: this._usage,\n    };\n  }\n\n  get firstTokenTime(): number | undefined {\n    return this.timeToFirstToken;\n  }\n}\n","export function currentUnixTime(): number {\n  return Date.now() / 1000;\n}\n","import { type LanguageModelV1 } from '@ai-sdk/providerv1';\nimport { type LanguageModelV2 } from '@ai-sdk/providerv2';\n\nimport { AxiomWrappedLanguageModelV1, isLanguageModelV1 } from './AxiomWrappedLanguageModelV1';\nimport { AxiomWrappedLanguageModelV2, isLanguageModelV2 } from './AxiomWrappedLanguageModelV2';\n\n/**\n * Wraps an AI SDK model to provide OpenTelemetry instrumentation.\n *\n * Supports both AI SDK v4 (LanguageModelV1) and v5 (LanguageModelV2) models.\n *\n * @param model - Language model implementing LanguageModelV1 or LanguageModelV2 interface\n * @returns Wrapped model with identical interface but added instrumentation\n */\nexport function wrapAISDKModel<T extends LanguageModelV1 | LanguageModelV2>(model: T): T {\n  if (isLanguageModelV2(model)) {\n    return new AxiomWrappedLanguageModelV2(model) as never as T;\n  } else if (isLanguageModelV1(model)) {\n    return new AxiomWrappedLanguageModelV1(model) as never as T;\n  } else {\n    console.warn('Unsupported AI SDK model. Not wrapping.');\n    return model;\n  }\n}\n","import { type LanguageModelV1, type LanguageModelV1CallOptions } from '@ai-sdk/providerv1';\nimport { axiomAIMiddlewareV1 } from './middleware';\n\nexport function isLanguageModelV1(model: unknown): model is LanguageModelV1 {\n  return (\n    model != null &&\n    typeof model === 'object' &&\n    'specificationVersion' in model &&\n    'provider' in model &&\n    'modelId' in model &&\n    (model as any).specificationVersion === 'v1' &&\n    typeof (model as any).provider === 'string' &&\n    typeof (model as any).modelId === 'string'\n  );\n}\n\n/**\n * Wraps a LanguageModelV1 to provide OpenTelemetry instrumentation.\n *\n * Internally uses Axiom's telemetry middleware while maintaining a simple class-based API.\n *\n * @example\n * ```typescript\n * import { AxiomWrappedLanguageModelV1 } from '@axiom/ai';\n * import { openai } from '@ai-sdk/openai';\n *\n * const model = new AxiomWrappedLanguageModelV1(openai('gpt-3.5-turbo'));\n * ```\n *\n * For advanced use cases, you can also use the middleware directly:\n * ```typescript\n * import { wrapLanguageModel } from 'ai';\n * import { createAxiomTelemetryV1 } from '@axiom/ai';\n *\n * const model = wrapLanguageModel({\n *   model: yourV1Model,\n *   middleware: createAxiomTelemetryV1(),\n * });\n * ```\n */\nexport class AxiomWrappedLanguageModelV1 {\n  constructor(model: LanguageModelV1) {\n    const middleware = axiomAIMiddlewareV1();\n\n    // Return the wrapped model directly from constructor\n    return {\n      specificationVersion: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId,\n      defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n      supportsImageUrls: model.supportsImageUrls,\n      supportsStructuredOutputs: model.supportsStructuredOutputs,\n      supportsUrl: model.supportsUrl?.bind(model),\n\n      doGenerate: async (params: LanguageModelV1CallOptions) => {\n        return middleware.wrapGenerate!({\n          doGenerate: () => model.doGenerate(params),\n          doStream: () => model.doStream(params),\n          params,\n          model,\n        });\n      },\n\n      doStream: async (params: LanguageModelV1CallOptions) => {\n        return middleware.wrapStream!({\n          doGenerate: () => model.doGenerate(params),\n          doStream: () => model.doStream(params),\n          params,\n          model,\n        });\n      },\n    } as LanguageModelV1;\n  }\n}\n","import { type LanguageModelV2, type LanguageModelV2CallOptions } from '@ai-sdk/providerv2';\nimport { axiomAIMiddlewareV2 } from './middleware';\n\nexport function isLanguageModelV2(model: any): model is LanguageModelV2 {\n  return (\n    model?.specificationVersion === 'v2' &&\n    typeof model?.provider === 'string' &&\n    typeof model?.modelId === 'string'\n  );\n}\n\n/**\n * Wraps a LanguageModelV2 to provide OpenTelemetry instrumentation.\n *\n * Internally uses Axiom's telemetry middleware while maintaining a simple class-based API.\n *\n * @example\n * ```typescript\n * import { AxiomWrappedLanguageModelV2 } from '@axiom/ai';\n * import { anthropic } from '@ai-sdk/anthropic';\n *\n * const model = new AxiomWrappedLanguageModelV2(anthropic('claude-3-haiku-20240307'));\n * ```\n *\n * For advanced use cases, you can also use the middleware directly:\n * ```typescript\n * import { wrapLanguageModel } from 'ai';\n * import { createAxiomTelemetryV2 } from '@axiom/ai';\n *\n * const model = wrapLanguageModel({\n *   model: yourV2Model,\n *   middleware: createAxiomTelemetryV2(),\n * });\n * ```\n */\nexport class AxiomWrappedLanguageModelV2 {\n  constructor(model: LanguageModelV2) {\n    const middleware = axiomAIMiddlewareV2();\n\n    // Return the wrapped model directly from constructor\n    return {\n      specificationVersion: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId,\n      supportedUrls: model.supportedUrls,\n\n      doGenerate: async (params: LanguageModelV2CallOptions) => {\n        return middleware.wrapGenerate!({\n          doGenerate: () => model.doGenerate(params),\n          doStream: () => model.doStream(params),\n          params,\n          model,\n        });\n      },\n\n      doStream: async (params: LanguageModelV2CallOptions) => {\n        return middleware.wrapStream!({\n          doGenerate: () => model.doGenerate(params),\n          doStream: () => model.doStream(params),\n          params,\n          model,\n        });\n      },\n    } as LanguageModelV2;\n  }\n}\n","import { getGlobalFlagOverrides } from './evals/context/global-flags';\nimport {\n  getEvalContext,\n  updateEvalContext,\n  addOutOfScopeFlag,\n  setConfigScope,\n} from './evals/context/storage';\nimport { validateCliFlags } from './validate-flags';\nimport {\n  parsePath,\n  dotNotationToNested,\n  isValidPath,\n  getValueAtPath,\n  buildSchemaForPath,\n  findSchemaAtPath,\n} from './util/dot-path';\nimport {\n  getDef,\n  getKind,\n  getInnerType,\n  getShape,\n  isObjectSchema,\n  assertZodV4,\n} from './util/zod-internals';\nimport { trace } from '@opentelemetry/api';\nimport { type z, type ZodObject, type ZodDefault, type ZodSchema } from 'zod';\nimport { toOtelAttribute } from './otel/utils/to-otel-attribute';\nimport { Attr } from './otel';\n\ntype DefaultMaxDepth = 8;\n\n// Helper to recursively check if a schema has defaults (including nested objects)\ntype HasDefaults<S> = S extends { _zod: { def: { defaultValue: unknown } } }\n  ? true\n  : S extends ZodObject<infer Shape>\n    ? {\n        [K in keyof Shape]: HasDefaults<Shape[K]>;\n      } extends Record<keyof Shape, true>\n      ? true\n      : false\n    : false;\n\n// Helper type to extract the underlying ZodObject from ZodDefault wrapper\ntype UnwrapSchema<T> = T extends ZodDefault<infer U> ? U : T;\n\n// Helper to check if ALL fields in a schema have defaults\ntype AllFieldsHaveDefaults<Schema> =\n  // First check if the schema itself has an object-level default\n  Schema extends { _zod: { def: { defaultValue: unknown } } }\n    ? true\n    : // Otherwise recursively check if all fields have defaults\n      HasDefaults<UnwrapSchema<Schema>>;\n\ninterface AppScopeConfig<\n  FlagSchema extends ZodObject<any> | undefined = undefined,\n  FactSchema extends ZodObject<any> | undefined = undefined,\n> {\n  flagSchema: FlagSchema;\n  factSchema?: FactSchema;\n}\n\n/**\n * Recursive type to extract all possible paths from an object type.\n * Uses stack-based depth limiting for better performance.\n *\n * @template T - The object type to extract paths from\n * @template Stack - Internal stack counter (do not set manually)\n * @template MaxDepth - Maximum recursion depth (default: 8 for good balance)\n */\ntype ObjectPaths<\n  T,\n  Stack extends unknown[] = [],\n  MaxDepth extends number = DefaultMaxDepth,\n> = Stack['length'] extends MaxDepth\n  ? never\n  : T extends object\n    ? {\n        [K in keyof T]-?: K extends string | number\n          ? `${K}` | `${K}.${ObjectPaths<T[K], [1, ...Stack], MaxDepth>}`\n          : never;\n      }[keyof T]\n    : never;\n\n// Type to get value at a specific path in an object\ntype ObjectPathValue<T, P extends string> = P extends keyof T\n  ? T[P]\n  : P extends `${infer K}.${infer Rest}`\n    ? K extends keyof T\n      ? ObjectPathValue<T[K], Rest>\n      : never\n    : never;\n\n/**\n * Generate deep nested paths from flag schema.\n *\n * @template T - ZodObject to extract paths from\n * @template MaxDepth - Maximum recursion depth (default: 8, override for deeper nesting)\n * @example\n * // Default 8-level depth\n * type Paths = DotPaths<MySchema>\n *\n * // Custom depth for deeper nesting (impacts performance)\n * type DeepPaths = DotPaths<MySchema, 12>\n */\nexport type DotPaths<T extends ZodObject<any>, MaxDepth extends number = DefaultMaxDepth> = {\n  [NS in keyof T['shape']]:\n    | (string & NS) // Include the namespace itself\n    | {\n        [P in ObjectPaths<\n          z.output<UnwrapSchema<T['shape'][NS]>>,\n          [],\n          MaxDepth\n        >]: `${string & NS}.${P}`;\n      }[ObjectPaths<z.output<UnwrapSchema<T['shape'][NS]>>, [], MaxDepth>];\n}[keyof T['shape']];\n\ntype PathValue<T extends ZodObject<any>, P extends string> = P extends `${infer NS}.${infer Rest}`\n  ? NS extends keyof T['shape']\n    ? ObjectPathValue<z.output<UnwrapSchema<T['shape'][NS]>>, Rest>\n    : never\n  : P extends keyof T['shape']\n    ? z.output<UnwrapSchema<T['shape'][P]>>\n    : never;\n\ntype DotNotationFlagFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any> ? <P extends DotPaths<FS>>(path: P) => PathValue<FS, P> : never;\n\ntype FactFunction<SC extends ZodObject<any> | undefined> =\n  SC extends ZodObject<any>\n    ? <P extends DotPaths<SC> & string>(name: P, value: PathValue<SC, P>) => void\n    : never;\n\ntype OverrideFlagsFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any>\n    ? (partial: { [K in DotPaths<FS>]?: PathValue<FS, K> }) => void\n    : (partial: Record<string, any>) => void;\n\ntype WithFlagsFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any>\n    ? <T>(overrides: { [K in DotPaths<FS>]?: PathValue<FS, K> }, fn: () => T) => T\n    : <T>(overrides: Record<string, any>, fn: () => T) => T;\n\ntype PickFlagsFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any>\n    ? {\n        // Spread arguments: pickFlags2('foo', 'bar')\n        <K extends ReadonlyArray<DotPaths<FS> & string>>(...paths: K): K;\n        // Array argument: pickFlags2(['foo', 'bar'])\n        <K extends ReadonlyArray<DotPaths<FS> & string>>(paths: K): K;\n      }\n    : never;\n\nexport interface AppScope<\n  FS extends ZodObject<any> | undefined,\n  SC extends ZodObject<any> | undefined,\n> {\n  flag: DotNotationFlagFunction<FS>;\n  fact: FactFunction<SC>;\n  overrideFlags: OverrideFlagsFunction<FS>;\n  withFlags: WithFlagsFunction<FS>;\n  pickFlags: PickFlagsFunction<FS>;\n  getAllDefaultFlags: () => Record<string, any>;\n}\n\n/**\n * Check if a flag path is covered by the picked flags.\n * @param flagPath - The flag path to check (e.g., 'foo', 'foo.bar')\n * @param pickedFlags - Array of picked flag paths\n * @returns true if the flag is covered by picked flags\n */\nexport function isPickedFlag(flagPath: string, pickedFlags?: string[]): boolean {\n  if (!pickedFlags) {\n    // If no picked flags are provided, all flags are allowed\n    return true;\n  }\n\n  if (pickedFlags.length === 0) {\n    // If no flags are picked, all flags are allowed\n    return true;\n  }\n\n  return pickedFlags.some((picked) => {\n    // Exact match\n    if (flagPath === picked) {\n      return true;\n    }\n    // Nested match: flagPath starts with picked flag followed by a dot\n    if (flagPath.startsWith(picked + '.')) {\n      return true;\n    }\n    return false;\n  });\n}\n\n// Helper to recursively validate that schemas don't contain union types\nfunction assertNoUnions(schema: unknown, path = 'schema'): void {\n  if (!schema) return;\n\n  const kind = getKind(schema);\n  if (!kind) return;\n\n  // Unwrap transparent containers\n  if (kind === 'default' || kind === 'optional' || kind === 'nullable') {\n    const innerType = getInnerType(schema);\n    return assertNoUnions(innerType, path);\n  }\n\n  // Hard-fail on unions\n  if (kind === 'union' || kind === 'discriminatedunion') {\n    throw new Error(`[AxiomAI] Union types are not supported in flag schemas (found at \"${path}\")`);\n  }\n\n  // Recurse into compound types\n  if (kind === 'object') {\n    const shape = getShape(schema);\n    if (shape) {\n      for (const [k, v] of Object.entries(shape)) {\n        assertNoUnions(v, `${path}.${k}`);\n      }\n    }\n  } else if (kind === 'array') {\n    const innerType = getInnerType(schema);\n    if (innerType) {\n      assertNoUnions(innerType, `${path}[]`);\n    }\n  } else if (kind === 'record') {\n    const def = getDef(schema);\n    const valueType = def?.valueType;\n    if (valueType) {\n      assertNoUnions(valueType, `${path}{}`);\n    }\n  }\n}\n\n/**\n * Recursively verify that all leaf fields in the schema have defaults.\n * Throws with a detailed error message listing all paths missing defaults.\n * TODO: this should probably be in an adapter, not the core lib...\n */\nfunction ensureAllDefaults(schema: unknown, path = ''): void {\n  const missingDefaults: string[] = [];\n\n  function checkDefaults(current: unknown, currentPath: string): void {\n    if (!current) return;\n\n    const kind = getKind(current);\n    if (!kind) return;\n\n    const def = getDef(current);\n    const hasDefault = def?.defaultValue !== undefined;\n\n    // Unwrap transparent containers and check their inner type\n    if (kind === 'default') {\n      // This has a default, we're done - no need to check inner type\n      return;\n    }\n\n    if (kind === 'optional' || kind === 'nullable') {\n      // Transparent wrappers - check inner type\n      const innerType = getInnerType(current);\n      return checkDefaults(innerType, currentPath);\n    }\n\n    // ZodRecord is not allowed\n    if (kind === 'record') {\n      throw new Error(\n        `[AxiomAI] ZodRecord is not supported in flag schemas (found at \"${currentPath || 'root'}\")\\n` +\n          `All flag fields must have known keys and defaults. Consider using z.object() instead.`,\n      );\n    }\n\n    // For objects: if there's an object-level default, we're good\n    // Otherwise, recursively check all fields\n    if (kind === 'object') {\n      if (hasDefault) {\n        // Object-level default covers all nested fields\n        return;\n      }\n\n      const shape = getShape(current);\n      if (shape) {\n        for (const [k, v] of Object.entries(shape)) {\n          const nextPath = currentPath ? `${currentPath}.${k}` : k;\n          checkDefaults(v, nextPath);\n        }\n      }\n      return;\n    }\n\n    // For arrays: arrays are leaf types (no per-index access)\n    // Just check if the array schema itself has a default\n    if (kind === 'array') {\n      if (!hasDefault) {\n        missingDefaults.push(currentPath || 'root');\n      }\n      return;\n    }\n\n    // For all other types (primitives, etc): must have a default\n    if (!hasDefault) {\n      missingDefaults.push(currentPath || 'root');\n    }\n  }\n\n  checkDefaults(schema, path);\n\n  if (missingDefaults.length > 0) {\n    throw new Error(\n      `[AxiomAI] All flag fields must have defaults. Missing defaults for:\\n` +\n        missingDefaults.map((p) => `  - ${p}`).join('\\n') +\n        `\\n\\nAdd .default(value) to these fields or to their parent objects.`,\n    );\n  }\n}\n\n/**\n * Create a new application-level evaluation scope.\n *\n * @param config.flagSchema A zod object describing the schema for flags **(required)**\n * @param config.factSchema A zod object describing the schema for facts (optional)\n *\n * @example\n * import { z } from 'zod';\n *\n * const { flag, fact, withFlags, pickFlags, overrideFlags } = createAppScope({\n *   flagSchema: z.object({\n *     ui: z.object({\n *       darkMode: z.boolean().default(false),\n *       theme:    z.object({\n *         primary: z.string().default('#00f'),\n *       }),\n *     }),\n *     api: z.object({ \n       endpoint: z.string().default('/api') \n     }),\n *   }),\n *   factSchema: z.object({\n *     userAction: z.string(),\n *     timing: z.number(),\n *   }),\n * });\n *\n * // Typed flag access\n * const dark = flag('ui.darkMode'); // inferred boolean\n * const theme = flag('ui.theme'); // entire object\n * const primary = flag('ui.theme.primary'); // '#00f'\n * const endpoint = flag('api.endpoint'); // uses schema default\n *\n * // Typed fact recording\n * fact('userAction', 'clicked_button');\n * fact('timing', 1250);\n *\n * // Temporarily override flags for a block of code\n * withFlags({ 'ui.darkMode': true }, () => {\n *   // code here, `ui.darkMode` will be true in this block and reset after\n * });\n *\n * // Override flags globally for the current evaluation run\n * overrideFlags({ 'api.endpoint': '/custom' });\n */\n// Overload: Require all fields to have defaults (compile-time check)\nexport function createAppScope<\n  FlagSchema extends ZodObject<any>,\n  FactSchema extends ZodObject<any> | undefined = undefined,\n>(\n  config: AllFieldsHaveDefaults<FlagSchema> extends true\n    ? AppScopeConfig<FlagSchema, FactSchema>\n    : {\n        flagSchema: FlagSchema;\n        factSchema?: FactSchema;\n        __error__: 'createAppScope: flagSchema must have .default() for all leaf fields';\n      },\n): AppScope<FlagSchema, FactSchema>;\n\n// Implementation signature: Keep broad for internal use\nexport function createAppScope<\n  FlagSchema extends ZodObject<any> | undefined = undefined,\n  FactSchema extends ZodObject<any> | undefined = undefined,\n>(config: AppScopeConfig<FlagSchema, FactSchema>): AppScope<FlagSchema, FactSchema> {\n  // Store schemas for runtime validation\n  const flagSchemaConfig = config?.flagSchema;\n  const factSchemaConfig = config?.factSchema;\n\n  // Reject Zod v3 schemas\n  if (flagSchemaConfig) {\n    assertZodV4(flagSchemaConfig, 'flagSchema');\n  }\n  if (factSchemaConfig) {\n    assertZodV4(factSchemaConfig, 'factSchema');\n  }\n\n  // reject union types\n  if (flagSchemaConfig) {\n    assertNoUnions(flagSchemaConfig, 'flagSchema');\n  }\n\n  // Ensure all fields have defaults\n  if (flagSchemaConfig) {\n    ensureAllDefaults(flagSchemaConfig);\n  }\n\n  // CLI validation with dot notation support\n  if (flagSchemaConfig) {\n    validateCliFlags(flagSchemaConfig);\n  }\n\n  // Helper to check if a path represents a namespace access (no dots after first segment)\n  function isNamespaceAccess(segments: string[]): boolean {\n    if (!flagSchemaConfig || segments.length === 0) return false;\n\n    // For root namespace (like 'ui'), check if it exists in the ZodObject shape\n    if (segments.length === 1) {\n      return flagSchemaConfig.shape ? segments[0] in flagSchemaConfig.shape : false;\n    }\n\n    // For nested paths (like 'app.ui.layout'), need to check if the path points to an object schema\n    const schema = findSchemaAtPath(flagSchemaConfig, segments);\n    return isObjectSchema(schema);\n  }\n\n  // Helper function to check if a schema has complete defaults at runtime\n  // This mirrors the compile-time AllFieldsHaveDefaults<> type\n\n  // Recursively build object with all defaults from a Zod schema\n  function buildObjectWithDefaults(schema: unknown): unknown {\n    if (!schema) return undefined;\n\n    const kind = getKind(schema);\n    if (!kind) return undefined;\n\n    // `directDefault`: default for the entire object\n    // If this is not present, we try to construct the defaults from child fields (recursively)\n    const directDefault = extractDefault(schema);\n    if (directDefault !== undefined) {\n      return directDefault;\n    }\n\n    // We can only collect defaults from child fields if we're dealing with an object (for a scalar, there are no children)\n    if (kind === 'object') {\n      const shape = getShape(schema);\n      if (shape) {\n        const result: Record<string, unknown> = {};\n\n        for (const [key, fieldSchema] of Object.entries(shape)) {\n          const fieldValue = buildObjectWithDefaults(fieldSchema);\n          result[key] = fieldValue;\n        }\n\n        return result;\n      }\n    }\n\n    // No direct default, and it's not an object\n    return undefined;\n  }\n\n  function extractDefault(schema: unknown): unknown {\n    if (!schema) return undefined;\n\n    // Unwrap transparent containers first, checking for defaults at each level\n    let current: unknown = schema;\n\n    for (let i = 0; i < 10; i++) {\n      const def = getDef(current);\n      if (!def) break;\n\n      // Check for default value at current level\n      if (def.defaultValue !== undefined) {\n        return typeof def.defaultValue === 'function' ? def.defaultValue() : def.defaultValue;\n      }\n\n      // Unwrap one level if possible\n      const inner = getInnerType(current);\n      if (inner) {\n        current = inner;\n      } else {\n        // No more wrapping, stop here\n        break;\n      }\n    }\n\n    return undefined;\n  }\n\n  function validateFinalFlagValue(\n    dotPath: string,\n    value: unknown,\n  ): { ok: true; parsed: unknown } | { ok: false } {\n    if (!flagSchemaConfig) return { ok: true, parsed: value };\n\n    const segments = parsePath(dotPath);\n\n    // 1. Fast-path: validate directly with field-level schema\n    const fieldSchema = findSchemaAtPath(flagSchemaConfig, segments);\n    if (fieldSchema) {\n      const direct = (fieldSchema as ZodSchema<any>).safeParse(value);\n      if (direct.success) return { ok: true, parsed: direct.data };\n      // If we have a field schema but validation failed, this is a real error\n      return { ok: false };\n    }\n\n    // 2. If we don't have a field schema, check if the path is even valid in our schema\n    // Don't validate values for paths that don't exist in the schema - just pass them through\n    const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;\n    if (!hasValidNamespace) {\n      // Invalid namespace - pass through without validation (for backward compatibility with fallback values)\n      return { ok: true, parsed: value };\n    }\n\n    // 3. For valid namespaces but invalid paths, try nested object validation\n    const nested = dotNotationToNested({ [dotPath]: value });\n    const nestedResult = flagSchemaConfig.strict().partial().safeParse(nested);\n    if (nestedResult.success) {\n      const parsed = getValueAtPath(nestedResult.data, segments) ?? value;\n      return { ok: true, parsed };\n    }\n\n    // 4. If nested validation failed but the namespace is valid, allow it for backward compatibility\n    return { ok: true, parsed: value };\n  }\n\n  function hasUndefinedLeaves(obj: unknown): boolean {\n    if (obj === undefined) return true;\n    if (obj === null || typeof obj !== 'object') return false;\n    return Object.values(obj).some((v) =>\n      typeof v === 'object' && v !== null ? hasUndefinedLeaves(v) : v === undefined,\n    );\n  }\n\n  /**\n   * Get flag value with dot notation path support and schema validation.\n   * All flag fields must have .default() values in the schema.\n   * Precedence: CLI overrides -> Context overrides -> Schema defaults โ Error\n   *\n   * @param path - Dot notation path to the flag (e.g., 'ui.theme' or 'api.timeout')\n   * @returns The flag value or undefined if path is invalid\n   */\n  function flag<P extends string>(path: P): unknown {\n    const segments = parsePath(path);\n\n    const ctx = getEvalContext();\n    const globalOverrides = getGlobalFlagOverrides();\n\n    if (!isPickedFlag(path, ctx.pickedFlags)) {\n      addOutOfScopeFlag(path);\n    }\n\n    let finalValue: any;\n    let source: 'cli' | 'ctx' | 'schema' | undefined;\n\n    // Flag precedence order:\n    // 1. CLI overrides (getGlobalFlagOverrides)\n    // 2. Eval context overrides (getEvalContext().flags)\n    // 3. Schema/object defaults\n    // 4. undefined + console.error\n\n    // 1. Check CLI overrides first (highest priority)\n    if (path in globalOverrides) {\n      finalValue = globalOverrides[path];\n      source = 'cli';\n    }\n    // 2. Check context overrides (from withFlags() or overrideFlags)\n    else if (path in ctx.flags) {\n      finalValue = ctx.flags[path];\n      source = 'ctx';\n    }\n    // 3. Resolve from schema\n    else {\n      if (!flagSchemaConfig) {\n        console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n        return undefined;\n      }\n\n      // Check valid namespace\n      const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;\n      if (!hasValidNamespace) {\n        console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n        return undefined;\n      }\n\n      const schemaForPath = findSchemaAtPath(flagSchemaConfig, segments);\n\n      // If schema path doesn't exist, try extracting from parent object-level defaults\n      if (!schemaForPath) {\n        const namespaceSchema = findSchemaAtPath(flagSchemaConfig, [segments[0]]);\n        if (namespaceSchema) {\n          const namespaceObject = buildObjectWithDefaults(namespaceSchema);\n          if (namespaceObject && typeof namespaceObject === 'object') {\n            finalValue = getValueAtPath(namespaceObject, segments.slice(1));\n          }\n        }\n\n        if (finalValue === undefined) {\n          console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n          return undefined;\n        }\n      }\n      // Check if this is a namespace access (returning whole objects)\n      else if (isNamespaceAccess(segments)) {\n        finalValue = buildObjectWithDefaults(schemaForPath);\n\n        // If buildObjectWithDefaults fails or returns incomplete object, try extracting from parent defaults\n        if (finalValue === undefined || hasUndefinedLeaves(finalValue)) {\n          const nsSchema = findSchemaAtPath(flagSchemaConfig, [segments[0]]);\n          if (nsSchema) {\n            const nsObj = buildObjectWithDefaults(nsSchema);\n            if (nsObj && typeof nsObj === 'object') {\n              const extracted = getValueAtPath(nsObj, segments.slice(1));\n              if (extracted !== undefined) {\n                finalValue = extracted;\n              }\n            }\n          }\n        }\n\n        if (finalValue === undefined) {\n          console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n          return undefined;\n        }\n      }\n      // Leaf access: try field-level default first\n      else {\n        finalValue = extractDefault(schemaForPath);\n\n        // If no field-level default, try extracting from parent object-level default\n        if (finalValue === undefined) {\n          const nsSchema = findSchemaAtPath(flagSchemaConfig, [segments[0]]);\n          if (nsSchema) {\n            const nsObj = buildObjectWithDefaults(nsSchema);\n            if (nsObj && typeof nsObj === 'object') {\n              finalValue = getValueAtPath(nsObj, segments.slice(1));\n            }\n          }\n\n          if (finalValue === undefined) {\n            console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n            return undefined;\n          }\n        }\n      }\n\n      source = 'schema';\n    }\n\n    // Validate only overrides (schema values are pre-validated)\n    if (source !== 'schema') {\n      const validation = validateFinalFlagValue(path, finalValue);\n      if (!validation.ok) {\n        console.error(`[AxiomAI] Invalid flag: \"${path}\" - value does not match schema`);\n      }\n    }\n\n    updateEvalContext({ [path]: finalValue });\n\n    const span = trace.getActiveSpan();\n    if (span?.isRecording()) {\n      const attr = toOtelAttribute(finalValue);\n      if (attr) {\n        span.setAttribute(Attr.__EXPERIMENTAL_Flag(path), attr);\n      }\n    }\n\n    return finalValue;\n  }\n\n  /**\n   * Record a typed fact value for tracking and telemetry with dot notation support.\n   * @param name - The fact name/key\n   */\n  function fact<N extends string>(name: N, value: unknown): void {\n    let finalValue = value;\n\n    // Validate with schema if provided (but only log errors for now to match tests)\n    if (factSchemaConfig) {\n      const segments = parsePath(name);\n\n      let success = true;\n      // Fast path check - validate path exists in schema before creating nested object\n      if (!isValidPath(factSchemaConfig, segments)) {\n        success = false;\n      } else {\n        try {\n          // Build a schema specific to this path that makes sibling fields optional\n          const pathSchema = buildSchemaForPath(factSchemaConfig, segments);\n\n          // Convert dot notation to nested object for validation\n          const nested = dotNotationToNested({ [name]: value });\n          const result = pathSchema.safeParse(nested);\n\n          if (!result.success) {\n            success = false;\n          } else {\n            finalValue = getValueAtPath(result.data, segments) ?? value;\n          }\n        } catch (_error) {\n          // buildSchemaForPath can throw if schema structure is invalid\n          success = false;\n        }\n      }\n\n      if (!success) {\n        console.error(`[AxiomAI] Invalid fact: \"${name}\"`);\n      }\n    }\n\n    updateEvalContext(undefined, { [name]: finalValue });\n\n    const span = trace.getActiveSpan();\n    if (span?.isRecording()) {\n      const attr = toOtelAttribute(finalValue);\n      if (attr) {\n        span.setAttribute(Attr.__EXPERIMENTAL_Fact(name), attr);\n      }\n    }\n  }\n\n  /**\n   * Override flag values for the current evaluation context with type safety.\n   * @param partial - Typed flag overrides that must match the flag schema paths and types\n   */\n  function overrideFlags(partial: Record<string, any>): void {\n    const ctx = getEvalContext();\n    Object.assign(ctx.flags, partial);\n  }\n\n  /**\n   * Execute code with temporary flag overrides, automatically restoring original values.\n   * @param overrides - Typed flag overrides that must match the flag schema paths and types\n   * @param fn - Function to execute with the overridden flags\n   * @returns The return value of the executed function\n   */\n  function withFlags<T>(overrides: Record<string, any>, fn: () => T): T {\n    const ctx = getEvalContext();\n    const originalFlags = { ...ctx.flags };\n\n    // Apply overrides\n    Object.assign(ctx.flags, overrides);\n\n    try {\n      return fn();\n    } finally {\n      // Restore original flags by clearing and reassigning\n      Object.keys(ctx.flags).forEach((key) => delete ctx.flags[key]);\n      Object.assign(ctx.flags, originalFlags);\n    }\n  }\n\n  const pickFlags = ((...args: any[]) => {\n    // Handle both array and spread arguments\n    return args[0] && Array.isArray(args[0]) ? args[0] : args;\n  }) as PickFlagsFunction<FlagSchema>;\n\n  function flattenToDot(obj: any, prefix: string[] = [], out: Record<string, any> = {}) {\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) {\n      for (const [k, v] of Object.entries(obj)) {\n        flattenToDot(v, [...prefix, k], out);\n      }\n    } else {\n      if (prefix.length > 0) {\n        out[prefix.join('.')] = obj;\n      }\n    }\n    return out;\n  }\n\n  function getAllDefaultFlags(): Record<string, any> {\n    if (!flagSchemaConfig) return {};\n    const defaultsObj = buildObjectWithDefaults(flagSchemaConfig);\n    if (defaultsObj && typeof defaultsObj === 'object') {\n      return flattenToDot(defaultsObj as Record<string, any>);\n    }\n    return {};\n  }\n\n  const scope = {\n    flag: flag as any as DotNotationFlagFunction<FlagSchema>,\n    fact: fact as any as FactFunction<FactSchema>,\n    overrideFlags: overrideFlags as any as OverrideFlagsFunction<FlagSchema>,\n    withFlags: withFlags as any as WithFlagsFunction<FlagSchema>,\n    pickFlags,\n    getAllDefaultFlags,\n  } as AppScope<FlagSchema, FactSchema>;\n\n  // Expose scope to current eval context for downstream collection (suite-end summaries)\n  setConfigScope(scope as any);\n\n  return scope;\n}\n","/**\n * Global flag overrides storage for CLI flag functionality.\n * Uses globalThis for process-wide flag persistence.\n */\n\nconst GLOBAL_OVERRIDES_SYMBOL = Symbol.for('axiom.global_flag_overrides');\n\nfunction getRoot(): Record<string, any> {\n  return (globalThis as any)[GLOBAL_OVERRIDES_SYMBOL] ?? {};\n}\n\nfunction setRoot(val: Record<string, any>): void {\n  (globalThis as any)[GLOBAL_OVERRIDES_SYMBOL] = val;\n}\n\n/**\n * Set global flag overrides (called by CLI) - persists until cleared\n */\nexport function setGlobalFlagOverrides(overrides: Record<string, any>): void {\n  setRoot(overrides);\n}\n\n/**\n * Get global flag overrides (called by flag functions)\n */\nexport function getGlobalFlagOverrides(): Record<string, any> {\n  return getRoot();\n}\n\n/**\n * Clear global flag overrides (for testing)\n */\nexport function clearGlobalFlagOverrides(): void {\n  setRoot({});\n}\n","import { trace } from '@opentelemetry/api';\nimport { createAsyncHook } from './manager';\nimport { type createAppScope } from '../../app-scope';\nimport type { ResolvedAxiomConfig } from '../../config/index';\nimport type { OutOfScopeFlagAccess } from '../eval.types';\n\n// Global fallback for config scope when called outside of eval context (e.g., module import time)\nconst CONFIG_SCOPE_SYMBOL = Symbol.for('axiom.eval.configScope');\nfunction getGlobalConfigScope(): ReturnType<typeof createAppScope> | undefined {\n  return (globalThis as any)[CONFIG_SCOPE_SYMBOL];\n}\nfunction setGlobalConfigScope(scope: ReturnType<typeof createAppScope>) {\n  (globalThis as any)[CONFIG_SCOPE_SYMBOL] = scope;\n}\n\n// Global storage for axiom config (accessible from reporters)\nconst AXIOM_CONFIG_SYMBOL = Symbol.for('axiom.eval.config');\nexport function getAxiomConfig(): ResolvedAxiomConfig | undefined {\n  return (globalThis as any)[AXIOM_CONFIG_SYMBOL];\n}\nexport function setAxiomConfig(config: ResolvedAxiomConfig) {\n  (globalThis as any)[AXIOM_CONFIG_SYMBOL] = config;\n}\n\n// Mini-context for in-process access\nexport const EVAL_CONTEXT = createAsyncHook<{\n  flags: Record<string, any>;\n  facts: Record<string, any>;\n  configScope?: ReturnType<typeof createAppScope>;\n  pickedFlags?: string[];\n  outOfScopeFlags?: OutOfScopeFlagAccess[];\n  parent?: EvalContextData<any, any>;\n  overrides?: Record<string, any>;\n  accessedFlagKeys?: string[];\n}>('eval-context');\n\nexport interface EvalContextData<Flags = any, Facts = any> {\n  flags: Partial<Flags>;\n  facts: Partial<Facts>;\n  configScope?: ReturnType<typeof createAppScope>;\n  pickedFlags?: string[];\n  outOfScopeFlags?: OutOfScopeFlagAccess[];\n  parent?: EvalContextData<Flags, Facts>;\n  overrides?: Record<string, any>;\n  accessedFlagKeys?: string[];\n}\n\nexport function getEvalContext<\n  Flags extends Record<string, unknown> = any,\n  Facts extends Record<string, unknown> = any,\n>(): EvalContextData<Flags, Facts> {\n  const ctx = EVAL_CONTEXT.get();\n  if (!ctx) {\n    // Return empty context if none exists\n    return {\n      flags: {} as Partial<Flags>,\n      facts: {} as Partial<Facts>,\n      pickedFlags: undefined,\n      outOfScopeFlags: undefined,\n    };\n  }\n  return {\n    flags: ctx.flags as Partial<Flags>,\n    facts: ctx.facts as Partial<Facts>,\n    pickedFlags: ctx.pickedFlags,\n    outOfScopeFlags: ctx.outOfScopeFlags,\n    parent: ctx.parent,\n    overrides: ctx.overrides,\n    accessedFlagKeys: ctx.accessedFlagKeys,\n  };\n}\n\nexport function updateEvalContext(flags?: Record<string, any>, facts?: Record<string, any>) {\n  const current = EVAL_CONTEXT.get();\n  if (!current) {\n    // Silently return - this is expected when running capabilities outside of eval\n    return;\n  }\n\n  // Mutate the existing context (safe within the same async context)\n  if (flags) {\n    Object.assign(current.flags, flags);\n    // Track accessed flag keys for runtime reporting\n    if (!current.accessedFlagKeys) current.accessedFlagKeys = [];\n    for (const key of Object.keys(flags)) {\n      if (!current.accessedFlagKeys.includes(key)) {\n        current.accessedFlagKeys.push(key);\n      }\n    }\n  }\n  if (facts) {\n    Object.assign(current.facts, facts);\n  }\n}\n\n/**\n * Parse stack trace to extract relevant frames, filtering out internal/framework frames\n */\nfunction parseStackTrace(stack: string): string[] {\n  const lines = stack.split('\\n');\n  const frames: string[] = [];\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    if (!trimmed || !trimmed.startsWith('at ')) {\n      continue;\n    }\n\n    // filter out frames that users likely don't care about\n    if (\n      trimmed.includes('node_modules') ||\n      trimmed.includes('node:internal') ||\n      trimmed.includes('addOutOfScopeFlag') ||\n      trimmed.includes('storage.ts') ||\n      // Keep app-scope.ts frames that aren't the flag() function itself\n      (trimmed.includes('app-scope.ts') &&\n        (trimmed.includes('flag (') || trimmed.includes('flag2 (')))\n    ) {\n      continue;\n    }\n\n    frames.push(trimmed.replace('at ', ''));\n  }\n\n  return frames.slice(0, 5);\n}\n\nexport function addOutOfScopeFlag(flagPath: string) {\n  const current = EVAL_CONTEXT.get();\n  if (!current) {\n    console.warn('addOutOfScopeFlag called outside of evaluation context');\n    return;\n  }\n\n  if (!current.outOfScopeFlags) {\n    current.outOfScopeFlags = [];\n  }\n\n  const stack = new Error().stack || '';\n  const stackTrace = parseStackTrace(stack);\n\n  current.outOfScopeFlags.push({\n    flagPath,\n    accessedAt: Date.now(),\n    stackTrace,\n  });\n}\n\n// Helper: write to current span + context\nexport function putOnSpan(kind: 'flag' | 'fact', key: string, value: any) {\n  const span = trace.getActiveSpan();\n  if (span?.isRecording()) {\n    span.setAttributes({ [`${kind}.${key}`]: value });\n  }\n}\n\n/**\n * Resolve a flag value by walking the parent chain, checking overrides first\n */\nexport function resolveFlagValue<V>(ctx: EvalContextData<any, any>, key: string): V {\n  // First check current context overrides\n  if (ctx.overrides && key in ctx.overrides) {\n    return ctx.overrides[key] as V;\n  }\n\n  // Then check current context flags\n  if (key in ctx.flags) {\n    return ctx.flags[key] as V;\n  }\n\n  // Walk up the parent chain\n  if (ctx.parent) {\n    return resolveFlagValue(ctx.parent, key);\n  }\n\n  // This should not happen\n  // Return undefined as a fallback\n  console.error(`[AxiomAI] Flag \"${key}\" not found in context, returning undefined`);\n  return undefined as V;\n}\n\n/**\n * Create an overlay context that inherits from the current context\n * but isolates overrides to this specific execution context.\n */\nfunction createOverlayContext(overrides: Record<string, any>): any {\n  const current = EVAL_CONTEXT.get();\n  if (!current) {\n    if (process.env.NODE_ENV !== 'test') {\n      console.warn('createOverlayContext called outside of evaluation context');\n    }\n    return {\n      flags: { ...overrides },\n      facts: {},\n      pickedFlags: [],\n      outOfScopeFlags: [],\n      overrides: { ...overrides },\n    };\n  }\n\n  // Create merged flags for backwards compatibility\n  const mergedFlags = { ...current.flags, ...overrides };\n\n  return {\n    ...current,\n    flags: mergedFlags,\n    parent: current,\n    overrides: { ...overrides },\n  };\n}\n\n/**\n * Execute a function with flag overrides that are isolated to the execution context.\n * This creates an overlay context that inherits from the current context but isolates\n * the overrides to prevent them from leaking to sibling operations.\n */\nexport function withFlagOverrides<T>(overrides: Record<string, any>, fn: () => T): T {\n  const overlayContext = createOverlayContext(overrides);\n\n  // Write overridden flags to span for observability\n  for (const [key, value] of Object.entries(overrides)) {\n    putOnSpan('flag', key, value);\n  }\n\n  return EVAL_CONTEXT.run(overlayContext, fn);\n}\n\nexport function withEvalContext<T>(\n  options: {\n    initialFlags?: Record<string, any>;\n    pickedFlags?: string[];\n  } = {},\n  fn: () => T,\n): T {\n  const { initialFlags = {}, pickedFlags = [] } = options;\n  return EVAL_CONTEXT.run(\n    {\n      flags: { ...initialFlags },\n      facts: {},\n      pickedFlags,\n      outOfScopeFlags: [],\n      accessedFlagKeys: [],\n    },\n    fn,\n  );\n}\n\n/**\n * Set the config scope for the current evaluation context.\n * This makes the scope available for global flag/fact access.\n *\n * Also stores a global fallback so suite-end summary can access schema defaults\n * even if createAppScope ran outside the active async context.\n */\nexport function setConfigScope(scope: ReturnType<typeof createAppScope>) {\n  const current = EVAL_CONTEXT.get();\n  if (current) {\n    current.configScope = scope;\n  }\n  // Always set global fallback\n  setGlobalConfigScope(scope);\n}\n\n/**\n * Get the config scope from the current evaluation context.\n * Falls back to global scope when no context is active.\n */\nexport function getConfigScope(): ReturnType<typeof createAppScope> | undefined {\n  const current = EVAL_CONTEXT.get();\n  return current?.configScope ?? getGlobalConfigScope();\n}\n\n/**\n * Get the picked flags from the current evaluation context.\n * Returns undefined if no picked flags are set or if called outside eval context.\n */\nexport function getPickedFlags(): string[] | undefined {\n  return EVAL_CONTEXT.get()?.pickedFlags;\n}\n","import { createRequire } from 'node:module';\n\ninterface ContextManager<T = any> {\n  getStore(): T | undefined;\n  run<R>(value: T, fn: () => R): R;\n}\n\nconst CONTEXT_MANAGER_SYMBOL = Symbol.for('axiom.context_manager');\n\nfunction getGlobalContextManager(): ContextManager | undefined {\n  return (globalThis as any)[CONTEXT_MANAGER_SYMBOL];\n}\n\nfunction setGlobalContextManager(manager: ContextManager): void {\n  (globalThis as any)[CONTEXT_MANAGER_SYMBOL] = manager;\n}\n\nconst isNodeJS = typeof process !== 'undefined' && !!process.versions?.node;\n\nfunction getContextManager(): ContextManager {\n  // Check global Symbol registry cache first (shared across VM contexts)\n  const existing = getGlobalContextManager();\n  if (existing) return existing;\n\n  let manager: ContextManager;\n\n  if (isNodeJS) {\n    try {\n      // Resolve AsyncLocalStorage in both ESM and CJS Node contexts without bundler interference\n      let AsyncLocalStorage: any;\n\n      // Use createRequire to obtain a require in ESM\n      const req = createRequire(import.meta.url);\n      try {\n        AsyncLocalStorage = req('node:async_hooks').AsyncLocalStorage;\n      } catch {\n        AsyncLocalStorage = req('async_hooks').AsyncLocalStorage;\n      }\n\n      manager = new AsyncLocalStorage();\n    } catch (error) {\n      // Fallback if AsyncLocalStorage cannot be loaded\n      console.warn('AsyncLocalStorage not available, using fallback context manager:', error);\n      manager = createFallbackManager();\n    }\n  } else {\n    // Browser/CF Workers - simple fallback (no warning needed here)\n    console.warn('AsyncLocalStorage not available, using fallback context manager');\n    manager = createFallbackManager();\n  }\n\n  // Cache using Symbol to share across VM contexts\n  setGlobalContextManager(manager);\n\n  return manager;\n}\n\nfunction createFallbackManager(): ContextManager {\n  let currentContext: any = null;\n  return {\n    getStore: () => currentContext,\n    run: <R>(value: any, fn: () => R): R => {\n      const prev = currentContext;\n      currentContext = value;\n      try {\n        return fn();\n      } finally {\n        currentContext = prev;\n      }\n    },\n  };\n}\n\nexport function createAsyncHook<T>(_name: string) {\n  return {\n    get(): T | undefined {\n      const manager = getContextManager();\n      if (manager.getStore) {\n        return manager.getStore();\n      }\n      return undefined;\n    },\n    run<R>(value: T, fn: () => R): R {\n      const manager = getContextManager();\n      return manager.run(value, fn);\n    },\n  };\n}\n\n/**\n * Reset the context manager singleton for tests.\n * This clears the global cache and forces a new AsyncLocalStorage instance to be created.\n * Useful for test isolation when needed.\n */\nexport function __resetContextManagerForTests(): void {\n  delete (globalThis as any)[CONTEXT_MANAGER_SYMBOL];\n}\n","import { type ZodObject } from 'zod';\nimport { getGlobalFlagOverrides } from './evals/context/global-flags';\nimport { formatZodErrors, generateFlagExamples } from './cli/utils/format-zod-errors';\nimport { dotNotationToNested, isValidPath, parsePath } from './util/dot-path';\nimport { makeDeepPartial } from './util/deep-partial-schema';\nimport { assertZodV4 } from './util/zod-internals';\n\n/**\n * Validate CLI flag overrides against a schema early in eval execution.\n * Call this at the top of your eval file to fail fast on invalid flags.\n *\n * @param flagSchema - Zod schema to validate CLI flags against\n * @throws Error with helpful message if validation fails\n */\nexport function validateCliFlags(flagSchema: ZodObject<any>): void {\n  assertZodV4(flagSchema, 'flagSchema');\n  const globalOverrides = getGlobalFlagOverrides();\n\n  if (Object.keys(globalOverrides).length === 0) {\n    // No CLI flags provided, nothing to validate\n    return;\n  }\n\n  validateFlags(flagSchema, globalOverrides);\n}\n\nfunction validateFlags(flagSchema: ZodObject<any>, globalOverrides: Record<string, any>): void {\n  // First pass: check all paths exist in schema\n  for (const [dotPath, _value] of Object.entries(globalOverrides)) {\n    const segments = parsePath(dotPath);\n    if (!isValidPath(flagSchema, segments)) {\n      console.error('โ Invalid CLI flags:');\n      console.error(`  โข flag '${dotPath}': Invalid flag path`);\n      console.error('\\n๐ง Fix your CLI flags and try again.\\n');\n      process.exit(1);\n    }\n  }\n\n  // Second pass: validate values using nested object approach with deep partial\n  // This allows providing only some flags without requiring all nested objects\n  const nestedObject = dotNotationToNested(globalOverrides);\n  const deepPartialSchema = makeDeepPartial(flagSchema);\n  const result = deepPartialSchema.safeParse(nestedObject);\n\n  if (!result.success) {\n    console.error('โ Invalid CLI flags:');\n    console.error(formatZodErrors(result.error));\n\n    const examples = generateFlagExamples(result.error);\n    if (examples.length > 0) {\n      console.error('\\n๐ก Valid examples:');\n      examples.forEach((example) => console.error(`  ${example}`));\n    }\n\n    console.error('\\n๐ง Fix your CLI flags and try again.\\n');\n    process.exit(1);\n  }\n}\n","import { type ZodError } from 'zod';\nimport type { ZodIssue } from 'zod/v3';\nimport type { $ZodIssue } from 'zod/v4/core';\n\n/**\n * Format ZodError issues into user-friendly CLI error messages\n */\nexport function formatZodErrors(error: ZodError): string {\n  const issues = error.issues;\n  const messages: string[] = [];\n\n  for (const issue of issues) {\n    const path = issue.path.join('.');\n    const message = formatIssueMessage(issue, path);\n    messages.push(`  โข ${message}`);\n  }\n\n  return messages.join('\\n');\n}\n\nfunction formatIssueMessage(issue: any, path: string): string {\n  switch (issue.code) {\n    case 'invalid_type':\n      return `flag '${path}' expected ${issue.expected}, got ${JSON.stringify(issue.received)} (${typeof issue.received})`;\n\n    case 'too_small':\n      if (issue.type === 'number' || issue.origin === 'number') {\n        return `flag '${path}' must be >= ${issue.minimum}, got ${issue.received}`;\n      }\n      return `flag '${path}' is too small: ${issue.message}`;\n\n    case 'too_big':\n      if (issue.type === 'number') {\n        return `flag '${path}' must be <= ${issue.maximum}, got ${issue.received}`;\n      }\n      return `flag '${path}' is too big: ${issue.message}`;\n\n    case 'invalid_enum_value':\n      const options = issue.options.map((opt: any) => `\"${opt}\"`).join(', ');\n      return `flag '${path}' must be one of: ${options}, got \"${issue.received}\"`;\n\n    case 'invalid_value':\n      // Handle enum validation errors\n      if (issue.values && Array.isArray(issue.values)) {\n        const values = issue.values.map((val: any) => `\"${val}\"`).join(', ');\n        return `flag '${path}' must be one of: ${values}`;\n      }\n      return `flag '${path}': ${issue.message}`;\n\n    case 'unrecognized_keys':\n      // Handle unrecognized keys properly, especially when path is empty\n      const keys = issue.keys || [];\n      if (keys.length === 1) {\n        return `unrecognized flag '${keys[0]}'`;\n      } else if (keys.length > 1) {\n        const keysList = keys.map((key: string) => `'${key}'`).join(', ');\n        return `unrecognized flags ${keysList}`;\n      }\n      return `unrecognized keys in flags`;\n\n    case 'custom':\n      return `flag '${path}': ${issue.message}`;\n\n    default:\n      return `flag '${path}': ${issue.message}`;\n  }\n}\n\n/**\n * Create helpful examples for CLI usage based on validation errors\n */\nexport function generateFlagExamples(error: ZodError): string[] {\n  const examples: string[] = [];\n\n  for (const issue of error.issues) {\n    const path = issue.path.join('.');\n    const example = generateExampleForIssue(issue, path);\n    if (example && !examples.includes(example)) {\n      examples.push(example);\n    }\n  }\n\n  return examples.slice(0, 3); // Limit to 3 examples\n}\n\nfunction generateExampleForIssue(issue: ZodIssue | $ZodIssue, path: string): string | null {\n  switch (issue.code) {\n    case 'invalid_type':\n      if (issue.expected === 'number') {\n        return `--flag.${path}=0.7`;\n      }\n      if (issue.expected === 'boolean') {\n        return `--flag.${path}=true`;\n      }\n      if (issue.expected === 'string') {\n        return `--flag.${path}=\"value\"`;\n      }\n      break;\n\n    case 'too_small':\n      if (typeof issue.minimum === 'number' || typeof issue.minimum === 'bigint') {\n        return `--flag.${path}=${issue.minimum}`;\n      }\n      break;\n\n    case 'too_big':\n      if (typeof issue.maximum === 'number' || typeof issue.maximum === 'bigint') {\n        return `--flag.${path}=${issue.maximum}`;\n      }\n      break;\n\n    case 'invalid_enum_value':\n      if (issue.options.length > 0) {\n        return `--flag.${path}=${issue.options[0]}`;\n      }\n      break;\n\n    case 'invalid_value':\n      if (issue.values && Array.isArray(issue.values) && issue.values.length > 0) {\n        return `--flag.${path}=${String(issue.values[0])}`;\n      }\n      break;\n  }\n\n  return null;\n}\n","import { type ZodObject, type ZodSchema, type ZodType, z } from 'zod';\nimport { getDef, getShape, isObjectSchema, unwrapTransparent } from './zod-internals';\n\n/**\n * Parse a dot notation path into segments.\n * @param path - Dot notation path like \"ui.theme\" or \"api.timeout\"\n * @returns Array of path segments\n */\nexport function parsePath(path: string): string[] {\n  return path.split('.');\n}\n\n/**\n * Transform dot notation object to nested object structure.\n * Example: {\"ui.theme\": \"dark\", \"config.name\": \"test\"}\n * -> {ui: {theme: \"dark\"}, config: {name: \"test\"}}\n */\nexport function dotNotationToNested(\n  dotNotationObject: Record<string, unknown>,\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  for (const [dotPath, value] of Object.entries(dotNotationObject)) {\n    const segments = parsePath(dotPath);\n    let current: Record<string, unknown> = result;\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n\n      if (i === segments.length - 1) {\n        // Last segment - set the value\n        current[segment] = value;\n      } else {\n        // Intermediate segment - ensure object exists\n        if (!(segment in current) || typeof current[segment] !== 'object') {\n          current[segment] = {};\n        }\n        current = current[segment] as Record<string, unknown>;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Flatten nested object to dot notation.\n * Example: {ui: {theme: \"dark\"}, config: {name: \"test\"}}\n * -> {\"ui.theme\": \"dark\", \"config.name\": \"test\"}\n */\nexport function flattenObject(obj: Record<string, unknown>, prefix = ''): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      Object.assign(result, flattenObject(value as Record<string, unknown>, newKey));\n    } else {\n      result[newKey] = value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Check if a dot notation path exists in the schema.\n */\nexport function isValidPath(\n  schema: ZodObject<Record<string, ZodType>>,\n  segments: string[],\n): boolean {\n  let currentSchema: ZodType = schema;\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const shape = getShape(currentSchema);\n\n    if (!shape || !(segment in shape)) {\n      return false;\n    }\n\n    if (i < segments.length - 1) {\n      // Not the last segment, should be a ZodObject\n      const nextSchema = shape[segment];\n\n      // Handle wrapped schemas (ZodDefault, ZodOptional, etc.)\n      const unwrappedSchema = unwrapTransparent(nextSchema);\n\n      if (!isObjectSchema(unwrappedSchema)) {\n        return false;\n      }\n\n      currentSchema = unwrappedSchema;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Get value at a specific path in a nested object.\n */\nexport function getValueAtPath(obj: unknown, segments: string[]): unknown {\n  let current = obj;\n  for (const segment of segments) {\n    if (current == null || typeof current !== 'object' || !(segment in current)) {\n      return undefined;\n    }\n    current = (current as Record<string, unknown>)[segment];\n  }\n  return current;\n}\n\n/**\n * Helper function to traverse schema object to find the field schema at a specific path.\n */\nexport function findSchemaAtPath(\n  rootSchema: ZodObject<Record<string, ZodType>> | undefined,\n  segments: string[],\n): ZodSchema | undefined {\n  if (!rootSchema || segments.length === 0) return undefined;\n\n  let current: ZodType = rootSchema;\n\n  // ZodObject root - start with the shape\n  if (segments.length > 0) {\n    const rootShape = getShape(current);\n    if (!rootShape || !(segments[0] in rootShape)) {\n      return undefined;\n    }\n    current = rootShape[segments[0]];\n\n    // Continue with remaining segments starting from index 1\n    for (let i = 1; i < segments.length; i++) {\n      const segment = segments[i];\n      const def = getDef(current);\n      if (!def) {\n        return undefined;\n      }\n\n      // Unwrap transparent wrappers (ZodDefault, ZodOptional, ZodNullable, etc.)\n      current = unwrapTransparent(current);\n      if (!isObjectSchema(current)) {\n        return undefined;\n      }\n      const shape = getShape(current);\n      if (!shape) {\n        return undefined;\n      }\n      const nextSchema = shape[segment];\n      if (!nextSchema) {\n        return undefined;\n      }\n      current = nextSchema;\n    }\n    return current as ZodSchema;\n  }\n\n  return current as ZodSchema;\n}\n\n/**\n * Build a schema that validates only a specific path within a larger schema structure.\n * This allows validation of partial nested objects where only the target field is required.\n *\n * For example, for path \"ui.theme.colors.primary\":\n * - Creates: z.object({ ui: z.object({ theme: z.object({ colors: z.object({ primary: leafSchema }).partial() }).partial() }).partial() }).strict()\n * - This allows recording just { ui: { theme: { colors: { primary: value } } } } without requiring siblings\n *\n * @param rootSchema - The root ZodObject schema\n * @param segments - Path segments (e.g. ['ui', 'theme', 'colors', 'primary'])\n * @returns A schema that validates the specific path with partial validation for siblings\n */\nexport function buildSchemaForPath(\n  rootSchema: ZodObject<Record<string, ZodType>>,\n  segments: string[],\n): ZodSchema {\n  const pathKey = segments.join('.');\n\n  // Find the leaf schema for the target field\n  const leafSchema = findSchemaAtPath(rootSchema, segments);\n  if (!leafSchema) {\n    throw new Error(`Cannot find schema for path: ${pathKey}`);\n  }\n\n  // Build the schema from leaf back to root, making siblings optional at each level\n  let currentSchema: ZodSchema = leafSchema;\n\n  // Work backwards through the segments\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n\n    // Create an object schema with just this segment\n    const objectSchema = z.object({ [segment]: currentSchema });\n\n    // Make it partial (so siblings aren't required) and strict (so unknown keys are rejected)\n    currentSchema = objectSchema.partial().strict();\n  }\n\n  return currentSchema;\n}\n","import type { ZodObject, ZodType } from 'zod';\n\n/**\n * Detect if a schema is from Zod v4.\n * v4 schemas have `_zod`, v3 schemas only have `_def`.\n */\nexport function isZodV4Schema(schema: unknown): boolean {\n  if (!schema || typeof schema !== 'object') return false;\n  const s = schema as Record<string, unknown>;\n  return '_zod' in s;\n}\n\n/**\n * Assert that a schema is from Zod v4, throwing a helpful error if it isn't.\n */\nexport function assertZodV4(schema: unknown, context: string): void {\n  if (!isZodV4Schema(schema)) {\n    throw new Error(\n      `[AxiomAI] Zod v4 schemas are required (detected in ${context}). Found unsupported Zod version.`,\n    );\n  }\n}\n\n/** Normalized schema kinds we care about */\nexport type ZodKind =\n  | 'object'\n  | 'optional'\n  | 'default'\n  | 'nullable'\n  | 'readonly'\n  | 'prefault'\n  | 'nonoptional'\n  | 'catch'\n  | 'array'\n  | 'record'\n  | 'union'\n  | 'discriminatedunion'\n  | 'other';\n\n/** Minimal internal def shape we access (Zod v4) */\ninterface ZodInternalDef {\n  type?: unknown;\n  innerType?: ZodType<unknown>;\n  element?: ZodType<unknown>;\n  defaultValue?: unknown;\n  shape?: Record<string, ZodType<unknown>>;\n  valueType?: ZodType<unknown>;\n}\n\n/**\n * Get the internal def object from a Zod v4 schema.\n */\nexport function getDef(schema: unknown): ZodInternalDef | undefined {\n  if (!schema || typeof schema !== 'object') return undefined;\n\n  const s = schema as Record<string, unknown>;\n\n  if (s._zod && typeof s._zod === 'object') {\n    const zod = s._zod as Record<string, unknown>;\n    if (zod.def && typeof zod.def === 'object') {\n      return zod.def as ZodInternalDef;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Get the raw type string from a def (Zod v4).\n */\nfunction getDefRawType(def: ZodInternalDef | undefined): string | undefined {\n  if (!def) return undefined;\n  const raw = def.type;\n  if (raw == null) return undefined;\n  return typeof raw === 'string' ? raw : String(raw);\n}\n\nconst KNOWN_KINDS = new Set<ZodKind>([\n  'object',\n  'optional',\n  'default',\n  'nullable',\n  'readonly',\n  'prefault',\n  'nonoptional',\n  'catch',\n  'array',\n  'record',\n  'union',\n  'discriminatedunion',\n]);\n\n/**\n * Get the normalized ZodKind from a schema or def (Zod v4).\n */\nexport function getKind(schemaOrDef: unknown): ZodKind | undefined {\n  // If it looks like a def already (has type), use it directly\n  const def =\n    schemaOrDef && typeof schemaOrDef === 'object' && 'type' in schemaOrDef\n      ? (schemaOrDef as ZodInternalDef)\n      : getDef(schemaOrDef);\n\n  const raw = getDefRawType(def);\n  if (!raw) return undefined;\n\n  const normalized = raw.toLowerCase();\n  return KNOWN_KINDS.has(normalized as ZodKind) ? (normalized as ZodKind) : 'other';\n}\n\n/**\n * Check if a schema is an object schema (has shape).\n */\nexport function isObjectSchema(schema: unknown): schema is ZodObject<Record<string, ZodType>> {\n  if (!schema || typeof schema !== 'object') return false;\n\n  if ('shape' in schema && typeof (schema as Record<string, unknown>).shape === 'object') {\n    return true;\n  }\n\n  return getKind(schema) === 'object';\n}\n\n/**\n * Get the innerType from wrapper schemas (optional, nullable, default).\n */\nexport function getInnerType(schema: unknown): ZodType<unknown> | undefined {\n  const def = getDef(schema);\n  return def?.innerType;\n}\n\n/**\n * Get the element type from array schemas.\n */\nexport function getArrayElement(schema: unknown): ZodType<unknown> | undefined {\n  const def = getDef(schema);\n  return def?.element;\n}\n\n/**\n * Get the shape from an object schema (Zod v4).\n */\nexport function getShape(schema: unknown): Record<string, ZodType<unknown>> | undefined {\n  if (!schema || typeof schema !== 'object') return undefined;\n\n  // Direct shape property (Zod v4)\n  const s = schema as Record<string, unknown>;\n  if (s.shape && typeof s.shape === 'object') {\n    return s.shape as Record<string, ZodType<unknown>>;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the default value from a schema wrapped in ZodDefault.\n */\nexport function getDefaultValue(schema: unknown): unknown {\n  const def = getDef(schema);\n  return def?.defaultValue;\n}\n\nconst TRANSPARENT_WRAPPERS = [\n  'optional',\n  'nullable',\n  'default',\n  'readonly',\n  'prefault',\n  'nonoptional',\n  'catch', // transparent for schema structure, but alters error behavior\n];\n\n/**\n * Unwrap transparent wrappers (optional, nullable, default) to get the core schema.\n * Useful when you need to check the underlying type.\n */\nexport function unwrapTransparent(schema: ZodType<unknown>): ZodType<unknown> {\n  let current: unknown = schema;\n\n  for (let i = 0; i < 10; i++) {\n    const kind = getKind(current);\n    if (!kind) break;\n\n    if (TRANSPARENT_WRAPPERS.includes(kind)) {\n      const inner = getInnerType(current);\n      if (!inner) break;\n      current = inner;\n      continue;\n    }\n    break;\n  }\n\n  return current as ZodType<unknown>;\n}\n","import { type ZodObject, type ZodType, z } from 'zod';\nimport {\n  getKind,\n  getInnerType,\n  getArrayElement,\n  isObjectSchema,\n  getDefaultValue,\n} from './zod-internals';\n\n/**\n * Recursively makes all properties of a ZodObject schema optional (deep partial).\n * This is needed because Zod 4 removed the deprecated `.deepPartial()` method.\n *\n * When validating CLI flag overrides, we only want to validate the flags that are\n * provided, not require all nested objects to be fully specified.\n */\nexport function makeDeepPartial(schema: ZodObject<Record<string, ZodType>>): ZodType {\n  const shape = schema.shape;\n  const newShape: Record<string, ZodType> = {};\n\n  for (const [key, value] of Object.entries(shape)) {\n    newShape[key] = makeDeepPartialField(value as ZodType);\n  }\n\n  return z.object(newShape);\n}\n\n/**\n * Apply deep partial semantics to a single field of an object shape.\n */\nfunction makeDeepPartialField(fieldSchema: ZodType): ZodType {\n  const kind = getKind(fieldSchema);\n\n  // Plain object field - recurse and make optional\n  if (isObjectSchema(fieldSchema)) {\n    const partialObject = makeDeepPartial(fieldSchema as ZodObject<Record<string, ZodType>>);\n    return partialObject.optional();\n  }\n\n  // Optional wrapper - check if inner type is an object\n  if (kind === 'optional') {\n    const inner = getInnerType(fieldSchema);\n    if (inner && isObjectSchema(inner)) {\n      const partialInner = makeDeepPartial(inner as ZodObject<Record<string, ZodType>>);\n      return partialInner.optional();\n    }\n    // Already optional and not an object - preserve as-is\n    return fieldSchema;\n  }\n\n  // Nullable wrapper - check if inner type is an object\n  if (kind === 'nullable') {\n    const inner = getInnerType(fieldSchema);\n    if (inner && isObjectSchema(inner)) {\n      const partialInner = makeDeepPartial(inner as ZodObject<Record<string, ZodType>>);\n      return partialInner.nullable().optional();\n    }\n    // Nullable non-object - just make optional\n    return fieldSchema.optional();\n  }\n\n  // Default wrapper - check if inner type is an object\n  if (kind === 'default') {\n    const inner = getInnerType(fieldSchema);\n    const defaultValue = getDefaultValue(fieldSchema);\n\n    if (inner && isObjectSchema(inner)) {\n      const partialInner = makeDeepPartial(inner as ZodObject<Record<string, ZodType>>);\n      // Reapply the default on the deep-partialled object, preserving function references for lazy defaults\n      return (partialInner as ZodObject<Record<string, ZodType>>).default(defaultValue as any);\n    }\n    // Non-object with default - make optional to allow partial validation\n    return fieldSchema.optional();\n  }\n\n  // Array wrapper - deep partial the element type if it's an object\n  if (kind === 'array') {\n    const element = getArrayElement(fieldSchema);\n    if (element && isObjectSchema(element)) {\n      const partialElement = makeDeepPartial(element as ZodObject<Record<string, ZodType>>);\n      return z.array(partialElement).optional();\n    }\n    // Array of non-objects - just make optional\n    return fieldSchema.optional();\n  }\n\n  // All other field types - just make optional\n  return fieldSchema.optional();\n}\n","import { type AttributeValue } from '@opentelemetry/api';\n\nfunction toHomogeneousArray(input: unknown[]): AttributeValue | undefined {\n  if (input.length === 0) return undefined;\n\n  const converted: (string | number | boolean)[] = [];\n  const types = new Set<string>();\n\n  for (const item of input) {\n    const converted_item = toOtelPrimitive(item);\n    if (converted_item !== undefined) {\n      converted.push(converted_item);\n      types.add(typeof converted_item);\n    }\n  }\n\n  if (converted.length === 0) return undefined;\n\n  if (types.size > 1) {\n    return converted.map((item) => String(item)) as AttributeValue;\n  }\n\n  return converted as AttributeValue;\n}\n\nfunction toOtelPrimitive(v: unknown): string | number | boolean | undefined {\n  switch (typeof v) {\n    case 'string':\n      return v;\n    case 'number':\n      return Number.isFinite(v) ? v : undefined;\n    case 'boolean':\n      return v;\n    case 'bigint':\n      if (v >= Number.MIN_SAFE_INTEGER && v <= Number.MAX_SAFE_INTEGER) {\n        return Number(v);\n      }\n      return v.toString();\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n      return undefined;\n    case 'object':\n      if (v === null) return undefined;\n      if (v instanceof Date) return v.toISOString();\n      if (v instanceof Error) return v.message;\n      // fallback: stringify object-ish values\n      return safeStringify(v);\n  }\n}\n\nfunction safeStringify(obj: unknown): string | undefined {\n  try {\n    // Convert BigInt -> Number inside objects so JSON.stringify won't throw.\n    // Functions/undefined are dropped by JSON rules.\n    const s = JSON.stringify(obj, (_k, val) =>\n      typeof val === 'bigint' ? Number(val) : val instanceof Date ? val.toISOString() : val,\n    );\n    // Avoid empty/meaningless \"{}\" for Map/Setโstringify those explicitly\n    if (s === '{}') {\n      if (obj instanceof Map) {\n        return JSON.stringify(Object.fromEntries(obj));\n      }\n      if (obj instanceof Set) {\n        return JSON.stringify(Array.from(obj));\n      }\n    }\n    return s ?? undefined;\n  } catch {\n    // As a last resort, use toString() if present\n    try {\n      const t = (obj as any)?.toString?.();\n      return typeof t === 'string' ? t : undefined;\n    } catch {\n      return undefined;\n    }\n  }\n}\n\nexport function toOtelAttribute(input: unknown): AttributeValue | undefined {\n  // primitives fast-path\n  switch (typeof input) {\n    case 'string':\n      return input;\n    case 'number':\n      return Number.isFinite(input) ? input : undefined;\n    case 'boolean':\n      return input;\n    case 'bigint':\n      if (input >= Number.MIN_SAFE_INTEGER && input <= Number.MAX_SAFE_INTEGER) {\n        return Number(input);\n      }\n      return input.toString();\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n      return undefined;\n  }\n\n  // arrays -> homogeneous array of primitives\n  if (Array.isArray(input)) {\n    return toHomogeneousArray(input);\n  }\n\n  // date -> ISO string\n  if (input instanceof Date) {\n    return input.toISOString();\n  }\n\n  // null / objects -> JSON string\n  if (input === null) return undefined;\n  return safeStringify(input);\n}\n","export { withSpan } from './withSpan';\nexport { wrapAISDKModel } from './vercel';\nexport { Attr } from './semconv/attributes';\n"],"mappings":"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","names":["context","propagation","trace","SpanStatusCode","trace","context","propagation","SpanStatusCode","SpanStatusCode","trace","propagation","context","trace","context","propagation","SpanStatusCode","context","trace","trace","context","z","z","trace","trace"]}
#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.6.1_postcss@8.5.6_tsx@4.20.4_typescript@5.9.2/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl, importMetaUrl;
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.6.1_postcss@8.5.6_tsx@4.20.4_typescript@5.9.2/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
    getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
    importMetaUrl = /* @__PURE__ */ getImportMetaUrl();
  }
});

// src/evals/context/manager.ts
function getGlobalContextManager() {
  return globalThis[CONTEXT_MANAGER_SYMBOL];
}
function setGlobalContextManager(manager) {
  globalThis[CONTEXT_MANAGER_SYMBOL] = manager;
}
function getContextManager() {
  const existing = getGlobalContextManager();
  if (existing) return existing;
  let manager;
  if (isNodeJS) {
    try {
      let AsyncLocalStorage;
      const req = (0, import_node_module.createRequire)(importMetaUrl);
      try {
        AsyncLocalStorage = req("node:async_hooks").AsyncLocalStorage;
      } catch {
        AsyncLocalStorage = req("async_hooks").AsyncLocalStorage;
      }
      manager = new AsyncLocalStorage();
    } catch (error) {
      console.warn("AsyncLocalStorage not available, using fallback context manager:", error);
      manager = createFallbackManager();
    }
  } else {
    console.warn("AsyncLocalStorage not available, using fallback context manager");
    manager = createFallbackManager();
  }
  setGlobalContextManager(manager);
  return manager;
}
function createFallbackManager() {
  let currentContext = null;
  return {
    getStore: () => currentContext,
    run: (value, fn) => {
      const prev = currentContext;
      currentContext = value;
      try {
        return fn();
      } finally {
        currentContext = prev;
      }
    }
  };
}
function createAsyncHook(_name) {
  return {
    get() {
      const manager = getContextManager();
      if (manager.getStore) {
        return manager.getStore();
      }
      return void 0;
    },
    run(value, fn) {
      const manager = getContextManager();
      return manager.run(value, fn);
    }
  };
}
var import_node_module, CONTEXT_MANAGER_SYMBOL, isNodeJS;
var init_manager = __esm({
  "src/evals/context/manager.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_module = require("module");
    CONTEXT_MANAGER_SYMBOL = Symbol.for("axiom.context_manager");
    isNodeJS = typeof process !== "undefined" && !!process.versions?.node;
  }
});

// src/evals/context/global-flags.ts
function setRoot(val) {
  globalThis[GLOBAL_OVERRIDES_SYMBOL] = val;
}
function setGlobalFlagOverrides(overrides2) {
  setRoot(overrides2);
}
var GLOBAL_OVERRIDES_SYMBOL;
var init_global_flags = __esm({
  "src/evals/context/global-flags.ts"() {
    "use strict";
    init_cjs_shims();
    GLOBAL_OVERRIDES_SYMBOL = Symbol.for("axiom.global_flag_overrides");
  }
});

// src/cli/utils/format-zod-errors.ts
function formatZodErrors(error) {
  const issues = error.issues;
  const messages = [];
  for (const issue of issues) {
    const path3 = issue.path.join(".");
    const message = formatIssueMessage(issue, path3);
    messages.push(`  \u2022 ${message}`);
  }
  return messages.join("\n");
}
function formatIssueMessage(issue, path3) {
  switch (issue.code) {
    case "invalid_type":
      return `flag '${path3}' expected ${issue.expected}, got ${JSON.stringify(issue.received)} (${typeof issue.received})`;
    case "too_small":
      if (issue.type === "number" || issue.origin === "number") {
        return `flag '${path3}' must be >= ${issue.minimum}, got ${issue.received}`;
      }
      return `flag '${path3}' is too small: ${issue.message}`;
    case "too_big":
      if (issue.type === "number") {
        return `flag '${path3}' must be <= ${issue.maximum}, got ${issue.received}`;
      }
      return `flag '${path3}' is too big: ${issue.message}`;
    case "invalid_enum_value":
      const options = issue.options.map((opt) => `"${opt}"`).join(", ");
      return `flag '${path3}' must be one of: ${options}, got "${issue.received}"`;
    case "invalid_value":
      if (issue.values && Array.isArray(issue.values)) {
        const values = issue.values.map((val) => `"${val}"`).join(", ");
        return `flag '${path3}' must be one of: ${values}`;
      }
      return `flag '${path3}': ${issue.message}`;
    case "unrecognized_keys":
      const keys = issue.keys || [];
      if (keys.length === 1) {
        return `unrecognized flag '${keys[0]}'`;
      } else if (keys.length > 1) {
        const keysList = keys.map((key) => `'${key}'`).join(", ");
        return `unrecognized flags ${keysList}`;
      }
      return `unrecognized keys in flags`;
    case "custom":
      return `flag '${path3}': ${issue.message}`;
    default:
      return `flag '${path3}': ${issue.message}`;
  }
}
function generateFlagExamples(error) {
  const examples = [];
  for (const issue of error.issues) {
    const path3 = issue.path.join(".");
    const example = generateExampleForIssue(issue, path3);
    if (example && !examples.includes(example)) {
      examples.push(example);
    }
  }
  return examples.slice(0, 3);
}
function generateExampleForIssue(issue, path3) {
  switch (issue.code) {
    case "invalid_type":
      if (issue.expected === "number") {
        return `--flag.${path3}=0.7`;
      }
      if (issue.expected === "boolean") {
        return `--flag.${path3}=true`;
      }
      if (issue.expected === "string") {
        return `--flag.${path3}="value"`;
      }
      break;
    case "too_small":
      if (typeof issue.minimum === "number" || typeof issue.minimum === "bigint") {
        return `--flag.${path3}=${issue.minimum}`;
      }
      break;
    case "too_big":
      if (typeof issue.maximum === "number" || typeof issue.maximum === "bigint") {
        return `--flag.${path3}=${issue.maximum}`;
      }
      break;
    case "invalid_enum_value":
      if (issue.options.length > 0) {
        return `--flag.${path3}=${issue.options[0]}`;
      }
      break;
    case "invalid_value":
      if (issue.values && Array.isArray(issue.values) && issue.values.length > 0) {
        return `--flag.${path3}=${String(issue.values[0])}`;
      }
      break;
  }
  return null;
}
var import_zod;
var init_format_zod_errors = __esm({
  "src/cli/utils/format-zod-errors.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod = require("zod");
  }
});

// src/util/zod-internals.ts
function isZodV4Schema(schema) {
  if (!schema || typeof schema !== "object") return false;
  const s2 = schema;
  return "_zod" in s2;
}
function assertZodV4(schema, context5) {
  if (!isZodV4Schema(schema)) {
    throw new Error(
      `[AxiomAI] Zod v4 schemas are required (detected in ${context5}). Found unsupported Zod version.`
    );
  }
}
function getDef(schema) {
  if (!schema || typeof schema !== "object") return void 0;
  const s2 = schema;
  if (s2._zod && typeof s2._zod === "object") {
    const zod = s2._zod;
    if (zod.def && typeof zod.def === "object") {
      return zod.def;
    }
  }
  return void 0;
}
function getDefRawType(def) {
  if (!def) return void 0;
  const raw = def.type;
  if (raw == null) return void 0;
  return typeof raw === "string" ? raw : String(raw);
}
function getKind(schemaOrDef) {
  const def = schemaOrDef && typeof schemaOrDef === "object" && "type" in schemaOrDef ? schemaOrDef : getDef(schemaOrDef);
  const raw = getDefRawType(def);
  if (!raw) return void 0;
  const normalized = raw.toLowerCase();
  return KNOWN_KINDS.has(normalized) ? normalized : "other";
}
function isObjectSchema(schema) {
  if (!schema || typeof schema !== "object") return false;
  if ("shape" in schema && typeof schema.shape === "object") {
    return true;
  }
  return getKind(schema) === "object";
}
function getInnerType(schema) {
  const def = getDef(schema);
  return def?.innerType;
}
function getArrayElement(schema) {
  const def = getDef(schema);
  return def?.element;
}
function getShape(schema) {
  if (!schema || typeof schema !== "object") return void 0;
  const s2 = schema;
  if (s2.shape && typeof s2.shape === "object") {
    return s2.shape;
  }
  return void 0;
}
function getDefaultValue(schema) {
  const def = getDef(schema);
  return def?.defaultValue;
}
function unwrapTransparent(schema) {
  let current = schema;
  for (let i = 0; i < 10; i++) {
    const kind = getKind(current);
    if (!kind) break;
    if (TRANSPARENT_WRAPPERS.includes(kind)) {
      const inner = getInnerType(current);
      if (!inner) break;
      current = inner;
      continue;
    }
    break;
  }
  return current;
}
var KNOWN_KINDS, TRANSPARENT_WRAPPERS;
var init_zod_internals = __esm({
  "src/util/zod-internals.ts"() {
    "use strict";
    init_cjs_shims();
    KNOWN_KINDS = /* @__PURE__ */ new Set([
      "object",
      "optional",
      "default",
      "nullable",
      "readonly",
      "prefault",
      "nonoptional",
      "catch",
      "array",
      "record",
      "union",
      "discriminatedunion"
    ]);
    TRANSPARENT_WRAPPERS = [
      "optional",
      "nullable",
      "default",
      "readonly",
      "prefault",
      "nonoptional",
      "catch"
      // transparent for schema structure, but alters error behavior
    ];
  }
});

// src/util/dot-path.ts
function parsePath(path3) {
  return path3.split(".");
}
function dotNotationToNested(dotNotationObject) {
  const result = {};
  for (const [dotPath, value] of Object.entries(dotNotationObject)) {
    const segments = parsePath(dotPath);
    let current = result;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === segments.length - 1) {
        current[segment] = value;
      } else {
        if (!(segment in current) || typeof current[segment] !== "object") {
          current[segment] = {};
        }
        current = current[segment];
      }
    }
  }
  return result;
}
function flattenObject(obj, prefix = "") {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value, newKey));
    } else {
      result[newKey] = value;
    }
  }
  return result;
}
function isValidPath(schema, segments) {
  let currentSchema = schema;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const shape = getShape(currentSchema);
    if (!shape || !(segment in shape)) {
      return false;
    }
    if (i < segments.length - 1) {
      const nextSchema = shape[segment];
      const unwrappedSchema = unwrapTransparent(nextSchema);
      if (!isObjectSchema(unwrappedSchema)) {
        return false;
      }
      currentSchema = unwrappedSchema;
    }
  }
  return true;
}
var import_zod2;
var init_dot_path = __esm({
  "src/util/dot-path.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod2 = require("zod");
    init_zod_internals();
  }
});

// src/util/deep-partial-schema.ts
function makeDeepPartial(schema) {
  const shape = schema.shape;
  const newShape = {};
  for (const [key, value] of Object.entries(shape)) {
    newShape[key] = makeDeepPartialField(value);
  }
  return import_zod3.z.object(newShape);
}
function makeDeepPartialField(fieldSchema) {
  const kind = getKind(fieldSchema);
  if (isObjectSchema(fieldSchema)) {
    const partialObject = makeDeepPartial(fieldSchema);
    return partialObject.optional();
  }
  if (kind === "optional") {
    const inner = getInnerType(fieldSchema);
    if (inner && isObjectSchema(inner)) {
      const partialInner = makeDeepPartial(inner);
      return partialInner.optional();
    }
    return fieldSchema;
  }
  if (kind === "nullable") {
    const inner = getInnerType(fieldSchema);
    if (inner && isObjectSchema(inner)) {
      const partialInner = makeDeepPartial(inner);
      return partialInner.nullable().optional();
    }
    return fieldSchema.optional();
  }
  if (kind === "default") {
    const inner = getInnerType(fieldSchema);
    const defaultValue = getDefaultValue(fieldSchema);
    if (inner && isObjectSchema(inner)) {
      const partialInner = makeDeepPartial(inner);
      return partialInner.default(defaultValue);
    }
    return fieldSchema.optional();
  }
  if (kind === "array") {
    const element = getArrayElement(fieldSchema);
    if (element && isObjectSchema(element)) {
      const partialElement = makeDeepPartial(element);
      return import_zod3.z.array(partialElement).optional();
    }
    return fieldSchema.optional();
  }
  return fieldSchema.optional();
}
var import_zod3;
var init_deep_partial_schema = __esm({
  "src/util/deep-partial-schema.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod3 = require("zod");
    init_zod_internals();
  }
});

// src/validate-flags.ts
var import_zod4;
var init_validate_flags = __esm({
  "src/validate-flags.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod4 = require("zod");
    init_global_flags();
    init_format_zod_errors();
    init_dot_path();
    init_deep_partial_schema();
    init_zod_internals();
  }
});

// src/otel/utils/to-otel-attribute.ts
var import_api;
var init_to_otel_attribute = __esm({
  "src/otel/utils/to-otel-attribute.ts"() {
    "use strict";
    init_cjs_shims();
    import_api = require("@opentelemetry/api");
  }
});

// src/otel/withSpanBaggageKey.ts
var init_withSpanBaggageKey = __esm({
  "src/otel/withSpanBaggageKey.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/semconv/eval_proposal.ts
var init_eval_proposal = __esm({
  "src/otel/semconv/eval_proposal.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/semconv/attributes.ts
var import_semantic_conventions, import_incubating;
var init_attributes = __esm({
  "src/otel/semconv/attributes.ts"() {
    "use strict";
    init_cjs_shims();
    import_semantic_conventions = require("@opentelemetry/semantic-conventions");
    init_eval_proposal();
    import_incubating = require("@opentelemetry/semantic-conventions/incubating");
  }
});

// src/schema.ts
var SCHEMA_VERSION, SCHEMA_BASE_URL, SCHEMA_URL;
var init_schema = __esm({
  "src/schema.ts"() {
    "use strict";
    init_cjs_shims();
    SCHEMA_VERSION = "0.0.2";
    SCHEMA_BASE_URL = "https://axiom.co/ai/schemas/";
    SCHEMA_URL = `${SCHEMA_BASE_URL}${SCHEMA_VERSION}`;
  }
});

// src/otel/startActiveSpan.ts
var import_api2;
var init_startActiveSpan = __esm({
  "src/otel/startActiveSpan.ts"() {
    "use strict";
    init_cjs_shims();
    import_api2 = require("@opentelemetry/api");
  }
});

// package.json
var package_default;
var init_package = __esm({
  "package.json"() {
    package_default = {
      name: "axiom",
      version: "0.37.0",
      type: "module",
      author: "Axiom, Inc.",
      contributors: [
        "Islam Shehata <islam@axiom.co>",
        "Chris Ehrlich <chris@axiom.co>",
        "Gabriel de Andrade <gabriel@axiom.co>"
      ],
      scripts: {
        dev: "tsup --watch",
        build: "tsup && chmod +x dist/bin.js",
        format: "prettier --write .",
        "format:check": "prettier --check .",
        lint: "eslint './**/*.{js,ts}'",
        typecheck: "tsc --noEmit",
        test: "vitest run",
        "test:watch": "vitest --watch",
        publint: "npx publint"
      },
      types: "./dist/index.d.ts",
      main: "./dist/index.cjs",
      module: "./dist/index.js",
      bin: {
        axiom: "./dist/bin.js"
      },
      exports: {
        "./ai": {
          import: {
            types: "./dist/index.d.ts",
            default: "./dist/index.js"
          },
          require: {
            types: "./dist/index.d.cts",
            default: "./dist/index.cjs"
          }
        },
        "./ai/evals": {
          import: {
            types: "./dist/evals.d.ts",
            default: "./dist/evals.js"
          },
          require: {
            types: "./dist/evals.d.cts",
            default: "./dist/evals.cjs"
          }
        },
        "./ai/config": {
          import: {
            types: "./dist/config.d.ts",
            default: "./dist/config.js"
          },
          require: {
            types: "./dist/config.d.cts",
            default: "./dist/config.cjs"
          }
        },
        "./ai/feedback": {
          import: {
            types: "./dist/feedback.d.ts",
            default: "./dist/feedback.js"
          },
          require: {
            types: "./dist/feedback.d.cts",
            default: "./dist/feedback.cjs"
          }
        }
      },
      keywords: [
        "axiom",
        "logging",
        "ai",
        "otel",
        "opentelemetry"
      ],
      repository: {
        type: "git",
        url: "git+https://github.com/axiomhq/ai.git",
        directory: "packages/ai"
      },
      license: "MIT",
      dependencies: {
        "@next/env": "^15.4.2",
        "@opentelemetry/auto-instrumentations-node": "^0.60.1",
        "@opentelemetry/context-async-hooks": "^2.0.1",
        "@opentelemetry/exporter-trace-otlp-http": "^0.202.0",
        "@opentelemetry/resources": "^2.0.1",
        "@opentelemetry/sdk-trace-node": "^2.0.1",
        "@opentelemetry/semantic-conventions": "^1.37.0",
        "@sinclair/typebox": "^0.34.37",
        c12: "^2.0.4",
        commander: "^14.0.0",
        defu: "^6.1.4",
        handlebars: "^4.7.8",
        nanoid: "^5.1.5",
        open: "^10.1.0",
        "vite-tsconfig-paths": "^5.1.4",
        vitest: "^4.0.0"
      },
      peerDependencies: {
        "@opentelemetry/api": "^1.9.0",
        zod: "^3.25.0 || ^4.0.0"
      },
      devDependencies: {
        "@ai-sdk/anthropicv1": "npm:@ai-sdk/anthropic@^1.2.12",
        "@ai-sdk/anthropicv2": "npm:@ai-sdk/anthropic@^2.0.44",
        "@ai-sdk/openaiv1": "npm:@ai-sdk/openai@^1.3.24",
        "@ai-sdk/openaiv2": "npm:@ai-sdk/openai@^2.0.67",
        "@ai-sdk/providerv1": "npm:@ai-sdk/provider@^1.1.3",
        "@ai-sdk/providerv2": "npm:@ai-sdk/provider@^2.0.0",
        "@opentelemetry/api": "^1.9.0",
        "@opentelemetry/core": "^2.0.1",
        "@opentelemetry/sdk-trace-base": "^2.0.1",
        "@opentelemetry/sdk-trace-node": "^2.0.1",
        "@repo/eslint-config": "workspace:*",
        "@types/node": "^22.15.29",
        "@vitest/coverage-v8": "^4.0.0",
        aiv4: "npm:ai@^4.3.19",
        aiv5: "npm:ai@^5.0.93",
        esbuild: "^0.25.8",
        eslint: "catalog:",
        msw: "^2.12.2",
        prettier: "catalog:",
        tinyrainbow: "^2.0.0",
        tsup: "catalog:",
        typescript: "catalog:",
        vitest: "catalog:",
        zod: "catalog:"
      },
      files: [
        "dist"
      ],
      packageManager: "pnpm@10.16.1"
    };
  }
});

// src/otel/utils/redaction.ts
var import_api3, AXIOM_AI_REDACTION_KEY;
var init_redaction = __esm({
  "src/otel/utils/redaction.ts"() {
    "use strict";
    init_cjs_shims();
    import_api3 = require("@opentelemetry/api");
    init_withSpanBaggageKey();
    AXIOM_AI_REDACTION_KEY = Symbol.for("__axiom_ai_redaction__");
  }
});

// src/otel/initAxiomAI.ts
function extractTracerScope(tracer) {
  const tracerAny = tracer;
  const name = tracerAny._instrumentationScope?.name || tracerAny.instrumentationLibrary?.name || package_default.name;
  const version = tracerAny._instrumentationScope?.version || tracerAny.instrumentationLibrary?.version || package_default.version;
  return { name, version };
}
function initAxiomAI(config) {
  const newScope = extractTracerScope(config.tracer);
  const existingScope = globalThis[AXIOM_AI_SCOPE_KEY];
  if (existingScope && existingScope.name === newScope.name && existingScope.version === newScope.version) {
    return;
  }
  if (existingScope) {
    console.warn(
      `[AxiomAI] initAxiomAI() called multiple times with different scopes. Previous: ${existingScope.name}@${existingScope.version}, New: ${newScope.name}@${newScope.version}`
    );
  }
  globalThis[AXIOM_AI_SCOPE_KEY] = newScope;
  if (config.redactionPolicy) {
    globalThis[AXIOM_AI_REDACTION_KEY] = config.redactionPolicy;
  }
}
var import_api4, AXIOM_AI_SCOPE_KEY;
var init_initAxiomAI = __esm({
  "src/otel/initAxiomAI.ts"() {
    "use strict";
    init_cjs_shims();
    import_api4 = require("@opentelemetry/api");
    init_package();
    init_redaction();
    AXIOM_AI_SCOPE_KEY = Symbol.for("__axiom_ai_scope__");
  }
});

// src/otel/utils/wrapperUtils.ts
var import_api5;
var init_wrapperUtils = __esm({
  "src/otel/utils/wrapperUtils.ts"() {
    "use strict";
    init_cjs_shims();
    import_api5 = require("@opentelemetry/api");
    init_attributes();
    init_schema();
    init_withSpanBaggageKey();
    init_startActiveSpan();
    init_initAxiomAI();
  }
});

// src/util/name-validation-runtime.ts
var init_name_validation_runtime = __esm({
  "src/util/name-validation-runtime.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/withSpan.ts
var import_api6;
var init_withSpan = __esm({
  "src/otel/withSpan.ts"() {
    "use strict";
    init_cjs_shims();
    import_api6 = require("@opentelemetry/api");
    init_withSpanBaggageKey();
    init_wrapperUtils();
    init_name_validation_runtime();
  }
});

// src/otel/utils/contentSanitizer.ts
var init_contentSanitizer = __esm({
  "src/otel/utils/contentSanitizer.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/completionUtils.ts
var init_completionUtils = __esm({
  "src/otel/completionUtils.ts"() {
    "use strict";
    init_cjs_shims();
    init_contentSanitizer();
  }
});

// src/util/promptUtils.ts
var init_promptUtils = __esm({
  "src/util/promptUtils.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/utils/normalized.ts
var init_normalized = __esm({
  "src/otel/utils/normalized.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/util/currentUnixTime.ts
var init_currentUnixTime = __esm({
  "src/util/currentUnixTime.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/streaming/aggregators.ts
var init_aggregators = __esm({
  "src/otel/streaming/aggregators.ts"() {
    "use strict";
    init_cjs_shims();
    init_currentUnixTime();
  }
});

// src/otel/middleware.ts
var import_api7;
var init_middleware = __esm({
  "src/otel/middleware.ts"() {
    "use strict";
    init_cjs_shims();
    import_api7 = require("@opentelemetry/api");
    init_attributes();
    init_completionUtils();
    init_promptUtils();
    init_contentSanitizer();
    init_wrapperUtils();
    init_normalized();
    init_aggregators();
    init_redaction();
  }
});

// src/otel/AxiomWrappedLanguageModelV1.ts
var init_AxiomWrappedLanguageModelV1 = __esm({
  "src/otel/AxiomWrappedLanguageModelV1.ts"() {
    "use strict";
    init_cjs_shims();
    init_middleware();
  }
});

// src/otel/AxiomWrappedLanguageModelV2.ts
var init_AxiomWrappedLanguageModelV2 = __esm({
  "src/otel/AxiomWrappedLanguageModelV2.ts"() {
    "use strict";
    init_cjs_shims();
    init_middleware();
  }
});

// src/otel/vercel.ts
var init_vercel = __esm({
  "src/otel/vercel.ts"() {
    "use strict";
    init_cjs_shims();
    init_AxiomWrappedLanguageModelV1();
    init_AxiomWrappedLanguageModelV2();
  }
});

// src/otel/index.ts
var init_otel = __esm({
  "src/otel/index.ts"() {
    "use strict";
    init_cjs_shims();
    init_withSpan();
    init_vercel();
    init_attributes();
  }
});

// src/app-scope.ts
var import_api8, import_zod5;
var init_app_scope = __esm({
  "src/app-scope.ts"() {
    "use strict";
    init_cjs_shims();
    init_global_flags();
    init_storage();
    init_validate_flags();
    init_dot_path();
    init_zod_internals();
    import_api8 = require("@opentelemetry/api");
    import_zod5 = require("zod");
    init_to_otel_attribute();
    init_otel();
  }
});

// src/evals/context/storage.ts
function getAxiomConfig() {
  return globalThis[AXIOM_CONFIG_SYMBOL];
}
function setAxiomConfig(config) {
  globalThis[AXIOM_CONFIG_SYMBOL] = config;
}
function getEvalContext() {
  const ctx = EVAL_CONTEXT.get();
  if (!ctx) {
    return {
      flags: {},
      facts: {},
      pickedFlags: void 0,
      outOfScopeFlags: void 0
    };
  }
  return {
    flags: ctx.flags,
    facts: ctx.facts,
    pickedFlags: ctx.pickedFlags,
    outOfScopeFlags: ctx.outOfScopeFlags,
    parent: ctx.parent,
    overrides: ctx.overrides,
    accessedFlagKeys: ctx.accessedFlagKeys
  };
}
function putOnSpan(kind, key, value) {
  const span = import_api9.trace.getActiveSpan();
  if (span?.isRecording()) {
    span.setAttributes({ [`${kind}.${key}`]: value });
  }
}
function withEvalContext(options = {}, fn) {
  const { initialFlags = {}, pickedFlags = [] } = options;
  return EVAL_CONTEXT.run(
    {
      flags: { ...initialFlags },
      facts: {},
      pickedFlags,
      outOfScopeFlags: [],
      accessedFlagKeys: []
    },
    fn
  );
}
var import_api9, CONFIG_SCOPE_SYMBOL, AXIOM_CONFIG_SYMBOL, EVAL_CONTEXT;
var init_storage = __esm({
  "src/evals/context/storage.ts"() {
    "use strict";
    init_cjs_shims();
    import_api9 = require("@opentelemetry/api");
    init_manager();
    init_app_scope();
    CONFIG_SCOPE_SYMBOL = Symbol.for("axiom.eval.configScope");
    AXIOM_CONFIG_SYMBOL = Symbol.for("axiom.eval.config");
    EVAL_CONTEXT = createAsyncHook("eval-context");
  }
});

// src/context.ts
function overrideFlags(partial) {
  const current = getEvalContext();
  if (!current) {
    if (process.env.NODE_ENV !== "test") {
      console.warn("overrideFlags called outside of evaluation context");
    }
    return;
  }
  const overlayContext = {
    ...current,
    flags: { ...current.flags, ...partial },
    // Merge for backwards compatibility
    parent: current,
    overrides: { ...partial }
  };
  const currentCtx = EVAL_CONTEXT.get();
  if (currentCtx) {
    Object.assign(currentCtx, overlayContext);
  }
  for (const [key, value] of Object.entries(partial)) {
    putOnSpan("flag", key, value);
  }
}
var init_context = __esm({
  "src/context.ts"() {
    "use strict";
    init_cjs_shims();
    init_storage();
  }
});

// src/cli/utils/eval-context-runner.ts
async function runEvalWithContext(overrides2, runFn) {
  setGlobalFlagOverrides(overrides2);
  return withEvalContext({ initialFlags: overrides2 }, async () => {
    if (Object.keys(overrides2).length > 0) {
      overrideFlags(overrides2);
    }
    return runFn();
  });
}
var init_eval_context_runner = __esm({
  "src/cli/utils/eval-context-runner.ts"() {
    "use strict";
    init_cjs_shims();
    init_context();
    init_storage();
    init_global_flags();
  }
});

// src/cli/utils/parse-flag-overrides.ts
function ensureNoSpaceSeparatedSyntax(flagName, value, nextToken, flagType) {
  if (value === void 0 && nextToken !== void 0) {
    if (flagType === "flag" && !nextToken.startsWith("-") && nextToken !== "true" && nextToken !== "false") {
      console.error(`\u274C Invalid syntax: --flag.${flagName} ${nextToken}`);
      console.error(`\u{1F4A1} Use: --flag.${flagName}=${nextToken}`);
      process.exit(1);
    } else if (flagType === "config" && !nextToken.startsWith("-")) {
      console.error(`\u274C Invalid syntax: --flags-config ${nextToken}`);
      console.error(`\u{1F4A1} Use: --flags-config=${nextToken}`);
      process.exit(1);
    }
  }
}
function collectFlagValidationErrors(overrides2, flagSchema) {
  if (!flagSchema || Object.keys(overrides2).length === 0) {
    return { success: true, errors: [] };
  }
  assertZodV4(flagSchema, "flagSchema");
  const schema = flagSchema;
  const errors = [];
  for (const dotPath of Object.keys(overrides2)) {
    const segments = parsePath(dotPath);
    if (!isValidPath(schema, segments)) {
      errors.push({ type: "invalid_path", path: dotPath });
    }
  }
  if (errors.length > 0) {
    return { success: false, errors };
  }
  const nestedObject = dotNotationToNested(overrides2);
  const deepPartialSchema = makeDeepPartial(schema);
  const result = deepPartialSchema.safeParse(nestedObject);
  if (!result.success) {
    errors.push({ type: "invalid_value", zodError: result.error });
  }
  return { success: errors.length === 0, errors };
}
function printFlagValidationErrorsAndExit(errors) {
  console.error("\u274C Invalid CLI flags:");
  for (const error of errors) {
    if (error.type === "invalid_path") {
      console.error(`  \u2022 flag '${error.path}': Invalid flag path`);
    } else {
      console.error(formatZodErrors(error.zodError));
      const examples = generateFlagExamples(error.zodError);
      if (examples.length > 0) {
        console.error("\n\u{1F4A1} Valid examples:");
        examples.forEach((example) => console.error(`  ${example}`));
      }
    }
  }
  process.exit(1);
}
function validateFlagOverrides(overrides2, flagSchema) {
  const result = collectFlagValidationErrors(overrides2, flagSchema);
  if (!result.success) {
    printFlagValidationErrorsAndExit(result.errors);
  }
}
function coerceValue(raw) {
  if (raw === "true") return true;
  if (raw === "false") return false;
  const num = Number(raw);
  if (!Number.isNaN(num) && raw.trim() === num.toString()) {
    return num;
  }
  try {
    return JSON.parse(raw);
  } catch {
    return raw;
  }
}
function loadConfigFile(path3) {
  const abs = (0, import_node_path.resolve)(process.cwd(), path3);
  try {
    const contents = (0, import_node_fs.readFileSync)(abs, "utf8");
    const parsed = JSON.parse(contents);
    if (typeof parsed !== "object" || Array.isArray(parsed) || parsed === null) {
      console.error(
        `\u274C Flags config must be a JSON object, got ${Array.isArray(parsed) ? "array" : typeof parsed}`
      );
      process.exit(1);
    }
    return parsed;
  } catch (err) {
    console.error(`\u274C Could not read or parse flags config "${path3}": ${err.message}`);
    process.exit(1);
  }
}
function extractOverrides(argv) {
  const cleanedArgv2 = [];
  const overrides2 = {};
  let configPath = null;
  let hasCliFlags = false;
  let configPathCount = 0;
  for (let i = 0; i < argv.length; i++) {
    const token = argv[i];
    const configMatch = token.match(CONFIG_RE);
    const flagMatch = token.match(FLAG_RE);
    if (configMatch) {
      configPathCount++;
      if (configPathCount > 1) {
        console.error("\u274C Only one --flags-config can be supplied.");
        process.exit(1);
      }
      const value = configMatch[1];
      const nextToken = argv.length > i + 1 ? argv[i + 1] : void 0;
      ensureNoSpaceSeparatedSyntax("flags-config", value, nextToken, "config");
      if (!value) {
        console.error("\u274C --flags-config requires a file path");
        console.error("\u{1F4A1} Use: --flags-config=path/to/config.json");
        process.exit(1);
      }
      configPath = value;
    } else if (flagMatch) {
      hasCliFlags = true;
      const key = flagMatch[1];
      const value = flagMatch[2];
      const nextToken = argv.length > i + 1 ? argv[i + 1] : void 0;
      ensureNoSpaceSeparatedSyntax(key, value, nextToken, "flag");
      const finalValue = value === void 0 ? "true" : value;
      overrides2[key] = coerceValue(finalValue);
    } else {
      cleanedArgv2.push(token);
    }
  }
  if (configPath && hasCliFlags) {
    console.error("\u274C Cannot use both --flags-config and --flag.* arguments together.");
    console.error("Choose one approach:");
    console.error("  \u2022 Config file: --flags-config=my-flags.json");
    console.error("  \u2022 CLI flags: --flag.temperature=0.9 --flag.model=gpt-4o");
    process.exit(1);
  }
  if (configPath) {
    const configOverrides = loadConfigFile(configPath);
    return { cleanedArgv: cleanedArgv2, overrides: configOverrides };
  }
  return { cleanedArgv: cleanedArgv2, overrides: overrides2 };
}
var import_zod6, import_node_fs, import_node_path, FLAG_RE, CONFIG_RE;
var init_parse_flag_overrides = __esm({
  "src/cli/utils/parse-flag-overrides.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod6 = require("zod");
    init_format_zod_errors();
    import_node_fs = require("fs");
    import_node_path = require("path");
    init_dot_path();
    init_deep_partial_schema();
    init_zod_internals();
    FLAG_RE = /^--flag\.([^=]+)(?:=(.*))?$/;
    CONFIG_RE = /^--flags-config(?:=(.*))?$/;
  }
});

// src/cli/utils/glob-utils.ts
function isGlob(str) {
  return /[*?[\]{}!]/.test(str);
}
var init_glob_utils = __esm({
  "src/cli/utils/glob-utils.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/util/errors.ts
function getCircularReplacer() {
  const seen = /* @__PURE__ */ new WeakSet();
  return (_k, v) => {
    if (typeof v === "object" && v !== null) {
      if (seen.has(v)) return "[Circular]";
      seen.add(v);
    }
    return v;
  };
}
function safeJson(x) {
  try {
    return JSON.stringify(x, getCircularReplacer());
  } catch {
    return String(x);
  }
}
function errorToString(err) {
  try {
    if (typeof err === "string") return err;
    if (err instanceof Error) {
      return err.stack ?? err.message;
    }
    if (typeof err === "object" && err !== null) {
      const msg = err.message;
      const json = safeJson(err);
      return msg ? `${msg} (${json})` : json;
    }
    return String(err);
  } catch {
    return "[unserializable error]";
  }
}
var AxiomCLIError;
var init_errors = __esm({
  "src/util/errors.ts"() {
    "use strict";
    init_cjs_shims();
    AxiomCLIError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AxiomCLIError";
      }
    };
  }
});

// src/cli/auth/types.ts
var init_types = __esm({
  "src/cli/auth/types.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/cli/auth/config.ts
function getConfigDir() {
  const platform = process.platform;
  const homeDir = import_os.default.homedir();
  const xdgConfigHome = process.env.XDG_CONFIG_HOME;
  if (xdgConfigHome) {
    return import_path.default.join(xdgConfigHome, CONFIG_DIR_NAME);
  }
  if (platform === "win32") {
    const appData = process.env.APPDATA;
    if (appData) {
      return import_path.default.join(appData, CONFIG_DIR_NAME);
    }
    return import_path.default.join(homeDir, "AppData", "Roaming", CONFIG_DIR_NAME);
  }
  return import_path.default.join(homeDir, ".config", CONFIG_DIR_NAME);
}
function getGlobalConfigPath() {
  return import_path.default.join(getConfigDir(), CONFIG_FILENAME);
}
async function loadGlobalConfig() {
  const configPath = getGlobalConfigPath();
  try {
    const content = await import_fs.promises.readFile(configPath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    if (error.code === "ENOENT") {
      return { profiles: {} };
    }
    throw error;
  }
}
async function saveGlobalConfig(config) {
  const configPath = getGlobalConfigPath();
  const configDir = import_path.default.dirname(configPath);
  const content = JSON.stringify(config, null, 2);
  await import_fs.promises.mkdir(configDir, { recursive: true, mode: 448 });
  await import_fs.promises.writeFile(configPath, content, "utf-8");
  await import_fs.promises.chmod(configPath, 384);
}
function getActiveProfile(config) {
  const profileName = config.active_profile;
  if (!profileName) return null;
  const profile = config.profiles[profileName];
  if (!profile) return null;
  return profile;
}
var import_fs, import_path, import_os, CONFIG_FILENAME, CONFIG_DIR_NAME;
var init_config = __esm({
  "src/cli/auth/config.ts"() {
    "use strict";
    init_cjs_shims();
    import_fs = require("fs");
    import_path = __toESM(require("path"), 1);
    import_os = __toESM(require("os"), 1);
    CONFIG_FILENAME = "config.json";
    CONFIG_DIR_NAME = "axiom";
  }
});

// src/cli/auth/oauth.ts
var import_crypto, OAUTH_CLIENT_ID, OAUTH_AUTH_PATH, OAUTH_TOKEN_PATH, OAuth;
var init_oauth = __esm({
  "src/cli/auth/oauth.ts"() {
    "use strict";
    init_cjs_shims();
    import_crypto = require("crypto");
    OAUTH_CLIENT_ID = "264d906a404efc209b027f6595e6b616";
    OAUTH_AUTH_PATH = "/oauth/authorize";
    OAUTH_TOKEN_PATH = "/oauth/token";
    OAuth = class {
      constructor(oauthBaseUrl) {
        this.oauthBaseUrl = oauthBaseUrl;
      }
      static generateCodeVerifier() {
        return (0, import_crypto.randomBytes)(32).toString("base64url");
      }
      static generateCodeChallenge(verifier) {
        return (0, import_crypto.createHash)("sha256").update(verifier).digest("base64url");
      }
      static generateState() {
        return (0, import_crypto.randomBytes)(16).toString("hex");
      }
      buildAuthUrl(params) {
        const url = new URL(OAUTH_AUTH_PATH, this.oauthBaseUrl);
        url.searchParams.set("client_id", OAUTH_CLIENT_ID);
        url.searchParams.set("redirect_uri", params.redirectUri);
        url.searchParams.set("response_type", "code");
        url.searchParams.set("state", params.state);
        url.searchParams.set("code_challenge", params.codeChallenge);
        url.searchParams.set("code_challenge_method", "S256");
        url.searchParams.set("scope", "*");
        return url.toString();
      }
      async exchangeCodeForToken(params) {
        const tokenUrl = new URL(OAUTH_TOKEN_PATH, this.oauthBaseUrl);
        const body = new URLSearchParams({
          grant_type: "authorization_code",
          client_id: OAUTH_CLIENT_ID,
          code: params.code,
          redirect_uri: params.redirectUri,
          code_verifier: params.codeVerifier
        });
        const response = await fetch(tokenUrl.toString(), {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: body.toString()
        });
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Token exchange failed: ${response.status} ${errorText}`);
        }
        const data = await response.json();
        return data.access_token;
      }
    };
  }
});

// src/cli/auth/api.ts
async function fetchOrganizations(token, apiBaseUrl) {
  const response = await fetch(`${apiBaseUrl}/v2/orgs`, {
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    throw new AxiomCLIError(
      `Failed to fetch organizations: ${response.status} ${response.statusText}`
    );
  }
  const data = await response.json();
  return data;
}
async function verifyToken(token, orgId, apiBaseUrl) {
  const response = await fetch(`${apiBaseUrl}/v2/user`, {
    headers: {
      Authorization: `Bearer ${token}`,
      "X-Axiom-Org-Id": orgId,
      "Content-Type": "application/json"
    }
  });
  return response.ok;
}
var init_api = __esm({
  "src/cli/auth/api.ts"() {
    "use strict";
    init_cjs_shims();
    init_errors();
  }
});

// src/cli/auth/callback-server.ts
function escapeHtml(text) {
  const map = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;",
    "`": "&#96;"
  };
  return text.replace(/[&<>"']/g, (m2) => map[m2] || m2);
}
function renderCallbackPage(error) {
  const errorClass = error ? ' class="error"' : "";
  const errorMessage = error ? escapeHtml(error) : "";
  return `<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Axiom</title>
    <link rel="icon" href="https://app.axiom.co/static/favicon.ico">
    <meta name="description" content="Axiom CLI">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        html,
        body,
        .root {
            width: 100%;
            height: 100%;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        body {
            color: #334155;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
            font-size: 14px;
            font-weight: 500;
            font-variant: tabular-nums;
            line-height: 1.5;
            background-color: #fff;
            font-feature-settings: "tnum";
            margin: 0;
        }
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin-top: 0;
            margin-bottom: .5em;
            font-weight: 500;
        }
        p {
            margin-top: 0;
            margin-bottom: 1em;
        }
        h2 {
            font-size: 16px;
            font-weight: 600;
        }
        .root {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .logo {
            width: 92px;
            float: left;
            position: absolute;
            top: 16px;
            left: 16px;
        }
        .center p {
            padding: 8px 0;
        }
        .error .center {
            color: #bf0e08;
        }
    </style>
</head>
<body${errorClass}>
    <div class="root">
        <a class="" target="_blank" rel="noopener noreferrer" href="https://axiom.co">
          ${SVG_LOGO}
        </svg>
        </a>
        <div class="center">
            ${error ? `<h2 id="msg">Login failed</h2>
            <p id="details">${errorMessage}</p>` : `<h2 id="msg">Login successful</h2>
            <p id="details">You can close this page and return to your CLI.</p>`}
        </div>
    </div>
    <script>
        window.history.replaceState({}, '', \`\${window.location.pathname}\`);
    </script>
</body>
</html>`;
}
async function startCallbackServer() {
  return new Promise((resolve3) => {
    const server = import_http.default.createServer();
    server.listen(0, "127.0.0.1", () => {
      const address = server.address();
      resolve3({
        server,
        port: address.port,
        url: `http://127.0.0.1:${address.port}`
      });
    });
  });
}
async function waitForCallback(server, expectedState) {
  return new Promise((resolve3, reject) => {
    const timeout = setTimeout(
      () => {
        server.close();
        reject(new Error("Authentication timeout after 5 minutes"));
      },
      5 * 60 * 1e3
    );
    server.on("request", (req, res) => {
      const url = new URL(req.url || "", `http://${req.headers.host}`);
      const code = url.searchParams.get("code");
      const state = url.searchParams.get("state");
      const error = url.searchParams.get("error");
      const errorDescription = url.searchParams.get("error_description");
      if (error) {
        const errorMsg = errorDescription || error;
        res.writeHead(400, { "Content-Type": "text/html" });
        res.end(renderCallbackPage(errorMsg));
        clearTimeout(timeout);
        server.close();
        reject(new Error(`OAuth error: ${errorMsg}`));
        return;
      }
      if (!code || !state) {
        res.writeHead(400, { "Content-Type": "text/html" });
        res.end(renderCallbackPage("Missing code or state parameter"));
        return;
      }
      if (state !== expectedState) {
        res.writeHead(400, { "Content-Type": "text/html" });
        res.end(renderCallbackPage("Invalid state parameter (CSRF protection)"));
        clearTimeout(timeout);
        server.close();
        reject(new Error("Invalid state parameter"));
        return;
      }
      res.writeHead(200, { "Content-Type": "text/html" });
      res.end(renderCallbackPage());
      clearTimeout(timeout);
      server.close();
      resolve3({ code });
    });
  });
}
var import_http, SVG_LOGO;
var init_callback_server = __esm({
  "src/cli/auth/callback-server.ts"() {
    "use strict";
    init_cjs_shims();
    import_http = __toESM(require("http"), 1);
    SVG_LOGO = `<svg width="124" height="24" viewBox="0 0 124 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="logo">
<path d="M42.9919 16.8116H36.3696L35.5537 19.1572C35.4209 19.539 34.9714 19.8513 34.5548 19.8513H30.9779C30.5614 19.8513 30.3459 19.5449 30.499 19.1703L36.9816 3.31644C37.1346 2.9419 37.6009 2.63546 38.0174 2.63546H41.3718C41.7883 2.63546 42.2541 2.94207 42.4067 3.3168L48.8634 19.17C49.016 19.5447 48.8 19.8513 48.3835 19.8513H44.8067C44.3901 19.8513 43.9406 19.539 43.8078 19.1572L42.9919 16.8116ZM41.8232 13.4223L39.6807 7.18148L37.5383 13.4223H41.8232ZM64.1105 19.8513C63.694 19.8513 63.1767 19.5694 62.9611 19.2247L59.9029 14.3369L56.8447 19.2247C56.6291 19.5694 56.1119 19.8513 55.6953 19.8513H51.3392C50.9227 19.8513 50.7754 19.5801 51.0119 19.2486L56.8978 11.0013L51.5315 3.24414C51.2999 2.90937 51.4513 2.63546 51.8679 2.63546H55.89C56.3066 2.63546 56.8268 2.91563 57.0461 3.25807L59.9029 7.71959L62.7343 3.25955C62.9522 2.9163 63.4713 2.63546 63.8879 2.63546H67.938C68.3545 2.63546 68.5048 2.90868 68.272 3.24261L62.8801 10.9743L68.7935 19.2489C69.0303 19.5802 68.8832 19.8513 68.4666 19.8513H64.1105ZM76.525 19.119C76.525 19.5218 76.1841 19.8513 75.7675 19.8513H72.5522C72.1356 19.8513 71.7947 19.5218 71.7947 19.119V3.36771C71.7947 2.96498 72.1356 2.63546 72.5522 2.63546H75.7675C76.1841 2.63546 76.525 2.96498 76.525 3.36771V19.119ZM79.3736 11.1896C79.3736 6.18625 83.2688 2.15134 89.2511 2.15134C95.2334 2.15134 99.1289 6.18625 99.1289 11.1896C99.1289 16.2199 95.2334 20.2548 89.2511 20.2548C83.2688 20.2548 79.3736 16.2199 79.3736 11.1896ZM94.2873 11.1896C94.2873 8.58038 92.3953 6.21307 89.2511 6.21307C86.1349 6.21307 84.2149 8.58038 84.2149 11.1896C84.2149 13.7989 86.1349 16.2199 89.2511 16.2199C92.3675 16.2199 94.2873 13.7989 94.2873 11.1896ZM119.318 19.8513C118.902 19.8513 118.517 19.5245 118.463 19.1251L117.225 9.89847L113.65 19.1652C113.505 19.5426 113.045 19.8513 112.628 19.8513H111.055C110.638 19.8513 110.179 19.5423 110.034 19.1645L106.457 9.81766L105.218 19.125C105.165 19.5245 104.781 19.8513 104.364 19.8513H101.344C100.927 19.8513 100.633 19.5249 100.69 19.1259L102.932 3.3609C102.988 2.96191 103.376 2.63546 103.792 2.63546H106.59C107.007 2.63546 107.469 2.94351 107.617 3.32002L111.827 14.041L116.064 3.31949C116.213 2.94327 116.676 2.63546 117.092 2.63546H119.89C120.307 2.63546 120.694 2.96191 120.751 3.3609L122.993 19.1259C123.05 19.5249 122.755 19.8513 122.339 19.8513H119.318ZM23.9616 15.6531L18.8054 6.97021C18.5689 6.57115 17.9863 6.24465 17.5106 6.24465H14.2915C13.5433 6.24465 13.2365 5.73171 13.6097 5.1048L15.375 2.13986C15.5151 1.90455 15.5148 1.61487 15.3743 1.37981C15.2337 1.14476 14.9741 1 14.6933 1H10.2025C9.72681 1 9.14291 1.32577 8.90491 1.72395L0.17865 16.3217C-0.0594434 16.7199 -0.0595348 17.3715 0.178285 17.7698L2.42362 21.5297C2.79777 22.1561 3.41129 22.1569 3.78699 21.5313L5.54143 18.6103C5.91722 17.9847 6.53065 17.9854 6.9048 18.6119L8.49538 21.2754C8.7332 21.6737 9.317 21.9995 9.79273 21.9995H20.1698C20.6455 21.9995 21.2293 21.6737 21.4672 21.2754L23.959 17.1028C24.1968 16.7045 24.198 16.0521 23.9616 15.6531ZM16.9981 15.2352C17.3699 15.8629 17.0619 16.3765 16.3136 16.3765H8.24192C7.49372 16.3765 7.1876 15.864 7.56175 15.2375L11.6007 8.47417C11.9748 7.84772 12.5869 7.84774 12.9611 8.47421L16.9981 15.2352Z" fill="#121224"/>
</svg>`;
  }
});

// src/cli/auth/global-auth.ts
function getAuthContext() {
  return authContext;
}
async function setupGlobalAuth() {
  const config = await loadGlobalConfig();
  const profile = getActiveProfile(config);
  if (profile) {
    authContext = {
      token: profile.token,
      url: profile.url,
      orgId: profile.org_id
    };
  }
  return authContext;
}
var authContext;
var init_global_auth = __esm({
  "src/cli/auth/global-auth.ts"() {
    "use strict";
    init_cjs_shims();
    init_config();
    authContext = null;
  }
});

// src/cli/auth/index.ts
var init_auth = __esm({
  "src/cli/auth/index.ts"() {
    "use strict";
    init_cjs_shims();
    init_types();
    init_config();
    init_oauth();
    init_api();
    init_callback_server();
    init_global_auth();
  }
});

// src/config/index.ts
function createPartialDefaults() {
  let token;
  let url;
  let orgId;
  try {
    const authContext2 = getAuthContext();
    if (authContext2) {
      token = authContext2.token;
      url = authContext2.url;
      orgId = authContext2.orgId;
    }
  } catch {
  }
  token = token || process.env.AXIOM_TOKEN;
  url = url || process.env.AXIOM_URL;
  orgId = orgId || process.env.AXIOM_ORG_ID;
  return {
    eval: {
      url: url || "https://api.axiom.co",
      orgId,
      token,
      dataset: process.env.AXIOM_DATASET,
      flagSchema: void 0,
      instrumentation: null,
      include: [...DEFAULT_EVAL_INCLUDE],
      exclude: [],
      timeoutMs: 6e4
    }
  };
}
function validateConfig(config) {
  const errors = [];
  const isDebug = process.env.AXIOM_DEBUG === "true";
  if (!isDebug) {
    if (!config.eval?.token) {
      errors.push(
        "eval.token is required (set in axiom.config.ts or AXIOM_TOKEN environment variable)"
      );
    }
    if (!config.eval?.dataset) {
      errors.push(
        "eval.dataset is required (set in axiom.config.ts or AXIOM_DATASET environment variable)"
      );
    }
    if (!config.eval?.url) {
      console.log(
        "eval.url was not specified. Defaulting to `https://api.axiom.co`. Please set it in axiom.config.ts or AXIOM_URL environment variable if you want to use a different endpoint."
      );
    }
  }
  const instrumentation = config.eval?.instrumentation;
  if (instrumentation !== null && instrumentation !== void 0 && typeof instrumentation !== "function") {
    errors.push(
      "eval.instrumentation must be a function returning OTEL setup information or null."
    );
  }
  if (errors.length > 0) {
    throw new AxiomCLIError(`Invalid Axiom configuration:
  - ${errors.join("\n  - ")}`);
  }
  return config;
}
var import_zod7, DEFAULT_EVAL_INCLUDE;
var init_config2 = __esm({
  "src/config/index.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod7 = require("zod");
    init_errors();
    init_auth();
    DEFAULT_EVAL_INCLUDE = ["**/*.eval.{ts,js,mts,mjs,cts,cjs}"];
  }
});

// src/config/loader.ts
function customMerger(target, source) {
  const merged = (0, import_defu.defu)(source, target);
  if (source?.eval && "include" in source.eval) {
    merged.eval.include = source.eval.include;
  }
  if (source?.eval && "flagSchema" in source.eval) {
    merged.eval.flagSchema = source.eval.flagSchema;
  }
  return merged;
}
async function loadConfig(cwd = process.cwd()) {
  try {
    const defaults = createPartialDefaults();
    const result = await (0, import_c12.loadConfig)({
      name: "axiom",
      cwd,
      // Support common config file extensions
      configFile: "axiom.config",
      // Don't use defaultConfig - we'll merge manually to control array behavior
      // Disable configs other than .ts/.js/.mts/.mjs/.cts/.cjs
      rcFile: false,
      globalRc: false,
      packageJson: false,
      giget: false
    });
    const mergedConfig = customMerger(defaults, result.config);
    const validatedConfig = validateConfig(mergedConfig);
    return {
      config: validatedConfig
    };
  } catch (error) {
    if (error instanceof AxiomCLIError) {
      throw error;
    }
    throw new AxiomCLIError(`Failed to load config file: ${errorToString(error)}`);
  }
}
var import_c12, import_defu;
var init_loader = __esm({
  "src/config/loader.ts"() {
    "use strict";
    init_cjs_shims();
    import_c12 = require("c12");
    import_defu = require("defu");
    init_config2();
    init_errors();
  }
});

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
function a(n) {
  return String(n);
}
function C(n = false) {
  let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p(n = false) {
  let e = C(n), i = (r2, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r2.substring(s2, o) + c, s2 = o + t.length, o = r2.indexOf(t, s2);
    while (~o);
    return l + r2.substring(s2);
  }, g = (r2, t, c = r2) => {
    let o = (l) => {
      let s2 = String(l), b = s2.indexOf(t, r2.length);
      return ~b ? r2 + i(s2, t, c, b) + t : r2 + s2 + t;
    };
    return o.open = r2, o.close = t, o;
  }, u2 = {
    isColorSupported: e
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t] of h)
    u2[r2] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a;
  return u2;
}
var f, h;
var init_chunk_BVHSVHOK = __esm({
  "../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js"() {
    "use strict";
    init_cjs_shims();
    f = {
      reset: [0, 0],
      bold: [1, 22, "\x1B[22m\x1B[1m"],
      dim: [2, 22, "\x1B[22m\x1B[2m"],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39],
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    };
    h = Object.entries(f);
    a.open = "";
    a.close = "";
  }
});

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
var import_tty, r, u;
var init_node = __esm({
  "../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js"() {
    "use strict";
    init_cjs_shims();
    init_chunk_BVHSVHOK();
    import_tty = require("tty");
    r = process.env.FORCE_TTY !== void 0 || (0, import_tty.isatty)(1);
    u = p(r);
  }
});

// src/evals/reporter.console-utils.ts
function formatPercentage(value) {
  if (!Number.isFinite(value)) {
    return "N/A";
  }
  return Number(value * 100).toFixed(2) + "%";
}
function formatDiff(current, baseline) {
  if (!Number.isFinite(current) || !Number.isFinite(baseline)) {
    return { text: "N/A", color: u.dim };
  }
  const diff = current - baseline;
  const diffText = (diff >= 0 ? "+" : "") + formatPercentage(diff);
  const color = diff > 0 ? u.green : diff < 0 ? u.red : u.dim;
  return { text: diffText, color };
}
function truncate(str, max) {
  return str.length > max ? str.slice(0, max) + "\u2026" : str;
}
function stringify(value) {
  try {
    if (typeof value === "string") return value;
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}
function getCaseFingerprint(input, expected) {
  const inputStr = typeof input === "string" ? input : JSON.stringify(input);
  const expectedStr = typeof expected === "string" ? expected : JSON.stringify(expected);
  return JSON.stringify({ input: inputStr, expected: expectedStr });
}
function printEvalNameAndFileName(testSuite, meta, logger = console.log) {
  const cwd = process.cwd();
  logger(
    " ",
    u.bgCyan(u.black(` ${testSuite.project.name} `)),
    u.bgBlue(u.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),
    u.dim(`(${testSuite.children.size} cases)`)
  );
  logger(" ", u.dim(testSuite.module.moduleId.replace(cwd, "")));
}
function printBaselineNameAndVersion(testMeta, logger = console.log) {
  if (testMeta.evaluation.baseline) {
    logger(
      " ",
      " baseline ",
      u.bgMagenta(
        u.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `)
      )
    );
  } else {
    logger(" ", u.bgWhite(u.blackBright(" baseline: ")), "none");
  }
  logger("");
}
function printRuntimeFlags(testMeta, logger = console.log) {
  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {
    const entries = Object.entries(testMeta.case.runtimeFlags);
    logger("   ", u.dim("runtime flags"));
    for (const [k, v] of entries) {
      switch (v.kind) {
        case "replaced": {
          const valText = truncate(stringify(v.value), 80);
          const defText = truncate(stringify(v.default), 80);
          logger("     ", `${k}: ${valText} (default: ${defText})`);
          break;
        }
        case "introduced": {
          const valText = truncate(stringify(v.value), 80);
          logger("     ", `${k}: ${valText} (no default)`);
          break;
        }
      }
    }
  }
}
function printTestCaseCountStartDuration(testSuite, startTime, duration, logger = console.log) {
  logger(" ");
  logger(" ", u.dim("Cases"), testSuite.children.size);
  logger(" ", u.dim("Start at"), new Date(startTime).toTimeString());
  logger(" ", u.dim("Duration"), `${duration}s`);
}
function printTestCaseSuccessOrFailed(testMeta, ok, logger = console.log) {
  const index = testMeta.case.index;
  if (ok) {
    logger(" ", u.yellow(` \u2714 case ${index}:`));
  } else {
    logger(" ", u.red(` \u2716 case ${index}: failed`));
    for (const e of testMeta.case.errors ?? []) {
      logger("", e.message);
    }
  }
}
function printTestCaseScores(testMeta, baselineCase, logger = console.log) {
  const scores = testMeta.case.scores;
  const keys = Object.keys(scores);
  if (keys.length === 0) {
    return;
  }
  const maxNameLength = Math.max(...keys.map((k) => k.length));
  keys.forEach((k) => {
    const scoreData = scores[k];
    const hasError = scoreData.metadata?.error;
    const v = scoreData.score ? scoreData.score : 0;
    const rawCurrent = hasError ? "N/A" : formatPercentage(v);
    const paddedCurrent = rawCurrent.padStart(7);
    const coloredCurrent = hasError ? u.dim(paddedCurrent) : u.magentaBright(paddedCurrent);
    const paddedName = k.padEnd(maxNameLength);
    if (baselineCase?.scores[k]) {
      const baselineScoreValue = baselineCase.scores[k].value;
      const rawBaseline = formatPercentage(baselineScoreValue);
      const paddedBaseline = rawBaseline.padStart(7);
      const coloredBaseline = u.blueBright(paddedBaseline);
      const { text: diffText, color: diffColor } = formatDiff(v, baselineScoreValue);
      const paddedDiff = diffText.padStart(8);
      logger(
        `    ${paddedName}  ${coloredBaseline} \u2192 ${coloredCurrent}  ${hasError ? u.dim("(scorer not run)") : u.dim("(") + diffColor(paddedDiff) + u.dim(")")}`
      );
    } else {
      logger(`    ${paddedName}  ${coloredCurrent} ${hasError ? u.dim("(scorer not run)") : ""}`);
    }
  });
}
function printOutOfScopeFlags(testMeta, logger = console.log) {
  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {
    const pickedFlagsText = testMeta.case.pickedFlags ? `(picked: ${testMeta.case.pickedFlags.map((f2) => `'${f2}'`).join(", ")})` : "(none)";
    logger("   ", u.yellow(`\u26A0 Out-of-scope flags: ${pickedFlagsText}`));
    testMeta.case.outOfScopeFlags.forEach((flag) => {
      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();
      logger("     ", `${flag.flagPath} (at ${timeStr})`);
      if (flag.stackTrace && flag.stackTrace.length > 0) {
        flag.stackTrace.forEach((frame, i) => {
          const prefix = i === flag.stackTrace.length - 1 ? " \u2514\u2500" : " \u251C\u2500";
          logger("     ", u.dim(`${prefix} ${frame}`));
        });
      }
    });
  }
}
function printCaseResult(test, baselineCasesByFingerprint, matchedIndices, logger = console.log) {
  const ok = test.ok();
  const testMeta = test.meta();
  if (!testMeta?.case) {
    return;
  }
  printTestCaseSuccessOrFailed(testMeta, ok, logger);
  const fingerprint = getCaseFingerprint(testMeta.case.input, testMeta.case.expected);
  const baselineCases = baselineCasesByFingerprint.get(fingerprint);
  const baselineCase = baselineCases?.shift();
  if (baselineCase) {
    matchedIndices.add(baselineCase.index);
  }
  printTestCaseScores(testMeta, baselineCase, logger);
  printRuntimeFlags(testMeta, logger);
  printOutOfScopeFlags(testMeta, logger);
}
function printOrphanedBaselineCases(baseline, matchedIndices, logger = console.log) {
  const orphanedCases = baseline.cases.filter((c) => !matchedIndices.has(c.index));
  if (orphanedCases.length === 0) {
    return;
  }
  logger("");
  logger(" ", u.yellow("Orphaned baseline cases:"));
  for (const orphanedCase of orphanedCases) {
    logger(
      " ",
      u.dim(
        `case ${orphanedCase.index}: ${truncate(orphanedCase.input, 50)} (score: ${truncate(
          JSON.stringify(orphanedCase.scores),
          50
        )})`
      )
    );
    const keys = Object.keys(orphanedCase.scores);
    if (keys.length > 0) {
      const maxNameLength = Math.max(...keys.map((k) => k.length));
      keys.forEach((k) => {
        const scoreData = orphanedCase.scores[k];
        const rawScore = formatPercentage(scoreData.value);
        const paddedName = k.padEnd(maxNameLength);
        const paddedScore = rawScore.padStart(7);
        logger(`    ${paddedName}  ${u.blueBright(paddedScore)}`);
      });
    }
  }
}
function printGlobalFlagOverrides(overrides2, defaults, logger = console.log) {
  if (Object.keys(overrides2).length === 0) {
    logger("");
    logger(u.dim("Flag overrides: (none)"));
    logger("");
    return;
  }
  logger("");
  logger("Flag overrides:");
  for (const [key, value] of Object.entries(overrides2)) {
    const defaultValue = defaults[key];
    const valueStr = JSON.stringify(value);
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : "none";
    logger(`  \u2022 ${key}: ${valueStr} ${u.dim(`(default: ${defaultStr})`)}`);
  }
  logger("");
}
function printSuiteBox({
  suite,
  scorerAverages,
  calculateBaselineScorerAverage: calculateBaselineScorerAverage2,
  flagDiff,
  logger = console.log
}) {
  const filename = suite.file.split("/").pop();
  logger("\u250C\u2500");
  logger(`\u2502  ${u.blue(suite.name)} ${u.gray(`(${filename})`)}`);
  logger("\u251C\u2500");
  const scorerNames = Object.keys(scorerAverages);
  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));
  const allCasesErrored = (scorerName) => {
    return suite.cases.every((caseData) => caseData.scores[scorerName]?.metadata?.error);
  };
  for (const scorerName of scorerNames) {
    const avg = scorerAverages[scorerName];
    const paddedName = scorerName.padEnd(maxNameLength);
    const hasAllErrors = allCasesErrored(scorerName);
    const baselineAvg = suite.baseline ? calculateBaselineScorerAverage2(suite.baseline, scorerName) : null;
    if (baselineAvg !== null) {
      const currentPercent = hasAllErrors ? u.dim("N/A") : formatPercentage(avg);
      const baselinePercent = formatPercentage(baselineAvg);
      const { text: diffText, color: diffColor } = formatDiff(avg, baselineAvg);
      const paddedBaseline = baselinePercent.padStart(7);
      const paddedCurrent = hasAllErrors ? currentPercent : currentPercent.padStart(7);
      const diffDisplay = hasAllErrors ? u.dim("all cases failed") : diffColor(diffText.padStart(8));
      logger(
        `\u2502  ${paddedName}  ${u.blueBright(paddedBaseline)} \u2192 ${hasAllErrors ? paddedCurrent : u.magentaBright(paddedCurrent)}  (${diffDisplay})`
      );
    } else {
      const currentPercent = hasAllErrors ? u.red("N/A (all cases failed)") : formatPercentage(avg);
      logger(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
    }
  }
  logger("\u251C\u2500");
  if (suite.baseline) {
    const baselineTimestamp = suite.baseline.runAt ? reporterDate(new Date(suite.baseline.runAt)) : "unknown time";
    logger(
      `\u2502  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${u.gray(`(${baselineTimestamp})`)}`
    );
  } else {
    logger(`\u2502  Baseline: ${u.gray("(none)")}`);
  }
  const hasConfigChanges = flagDiff.length > 0;
  logger("\u2502  Config changes:", hasConfigChanges ? "" : u.gray("(none)"));
  if (hasConfigChanges) {
    for (const { flag, current, baseline, default: defaultVal } of flagDiff) {
      logger(`\u2502   \u2022 ${flag}: ${current ?? "<not set>"}`);
      if (defaultVal !== void 0) {
        logger(`\u2502       ${u.gray(`default: ${defaultVal}`)}`);
      }
      if (suite.baseline) {
        logger(`\u2502       ${u.gray(`baseline: ${baseline ?? "<not set>"}`)}`);
      }
    }
  }
  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {
    const pickedFlagsText = suite.configFlags && suite.configFlags.length > 0 ? suite.configFlags.map((f2) => `'${f2}'`).join(", ") : "none";
    logger("\u2502");
    logger(`\u2502  ${u.yellow("\u26A0 Out-of-scope flags")} ${u.gray(`(picked: ${pickedFlagsText})`)}:`);
    for (const flag of suite.outOfScopeFlags) {
      const lastStackTraceFrame = flag.stackTrace[0];
      const lastStackTraceFnName = lastStackTraceFrame.split(" ").shift();
      const lastStackTraceFile = lastStackTraceFrame.split("/").pop()?.slice(0, -1);
      logger(
        `\u2502   \u2022 ${flag.flagPath} ${u.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`
      );
    }
  }
  logger("\u2514\u2500");
}
function calculateScorerAverages(suite) {
  const scorerTotals = {};
  for (const caseData of suite.cases) {
    for (const [scorerName, score] of Object.entries(caseData.scores)) {
      if (!scorerTotals[scorerName]) {
        scorerTotals[scorerName] = { sum: 0, count: 0 };
      }
      if (!score.metadata?.error) {
        scorerTotals[scorerName].sum += score.score || 0;
        scorerTotals[scorerName].count += 1;
      }
    }
  }
  const averages = {};
  for (const [scorerName, totals] of Object.entries(scorerTotals)) {
    averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;
  }
  return averages;
}
function calculateBaselineScorerAverage(baseline, scorerName) {
  const scores = [];
  for (const caseData of baseline.cases) {
    if (caseData.scores[scorerName]) {
      scores.push(caseData.scores[scorerName].value);
    }
  }
  if (scores.length === 0) return null;
  const sum = scores.reduce((acc, val) => acc + val, 0);
  return sum / scores.length;
}
function calculateFlagDiff(suite) {
  if (!suite.configFlags || suite.configFlags.length === 0) {
    return [];
  }
  const diffs = [];
  const currentConfig = suite.flagConfig || {};
  const baselineConfig = suite.baseline?.flagConfig || {};
  const defaultConfig = suite.defaultFlagConfig || {};
  const currentFlat = flattenObject(currentConfig);
  const baselineFlat = flattenObject(baselineConfig);
  const defaultFlat = flattenObject(defaultConfig);
  const allKeys = /* @__PURE__ */ new Set([
    ...Object.keys(currentFlat),
    ...Object.keys(baselineFlat),
    ...Object.keys(defaultFlat)
  ]);
  for (const key of allKeys) {
    const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));
    if (!isInScope) continue;
    const currentValue = currentFlat[key];
    const baselineValue = baselineFlat[key];
    const defaultValue = defaultFlat[key];
    const currentStr = currentValue !== void 0 ? JSON.stringify(currentValue) : void 0;
    const baselineStr = baselineValue !== void 0 ? JSON.stringify(baselineValue) : void 0;
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : void 0;
    const diffFromBaseline = suite.baseline && currentStr !== baselineStr;
    const diffFromDefault = currentStr !== defaultStr;
    if (diffFromBaseline || diffFromDefault) {
      diffs.push({
        flag: key,
        current: currentStr,
        baseline: suite.baseline ? baselineStr : void 0,
        default: defaultStr
      });
    }
  }
  return diffs;
}
function printFinalReport({
  suiteData,
  config,
  registrationStatus,
  isDebug,
  logger = console.log
}) {
  logger("");
  logger(u.bgBlue(u.white(" FINAL EVALUATION REPORT ")));
  logger("");
  for (const suite of suiteData) {
    const scorerAverages = calculateScorerAverages(suite);
    const flagDiff = calculateFlagDiff(suite);
    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff, logger });
    logger("");
  }
  const runId = suiteData[0]?.runId;
  const orgId = suiteData[0]?.orgId;
  const anyRegistered = registrationStatus.some((s2) => s2.registered);
  const anyFailed = registrationStatus.some((s2) => !s2.registered);
  if (anyRegistered && orgId && config?.consoleEndpointUrl) {
    if (suiteData.length === 1) {
      const suite = suiteData[0];
      const baselineParam = suite.baseline?.traceId ? `?baselineId=${suite.baseline.traceId}` : "";
      logger("View eval result:");
      logger(
        `${config.consoleEndpointUrl}/${orgId}/ai-engineering/evaluations/${suite.name}/${suite.version}${baselineParam}`
      );
    } else {
      logger("View full report:");
      logger(`${config.consoleEndpointUrl}/${orgId}/ai-engineering/evaluations?runId=${runId}`);
    }
  } else if (isDebug) {
    logger(u.dim("Results not uploaded to Axiom (debug mode)"));
  } else {
    logger("Results not available in Axiom UI (registration failed)");
  }
  if (anyFailed) {
    logger("");
    for (const status of registrationStatus) {
      if (!status.registered) {
        logger(u.yellow(`\u26A0\uFE0F  Warning: Failed to register "${status.name}" with Axiom`));
        if (status.error) {
          logger(u.dim(`   Error: ${status.error}`));
        }
        logger(u.dim(`   Results for this evaluation will not be available in the Axiom UI.`));
      }
    }
  }
}
var reporterDate;
var init_reporter_console_utils = __esm({
  "src/evals/reporter.console-utils.ts"() {
    "use strict";
    init_cjs_shims();
    init_node();
    init_dot_path();
    reporterDate = (d) => {
      const date = d.toISOString().slice(0, 10);
      const hours = d.getUTCHours().toString().padStart(2, "0");
      const minutes = d.getUTCMinutes().toString().padStart(2, "0");
      return `${date}, ${hours}:${minutes} UTC`;
    };
  }
});

// src/config/resolver.ts
function resolveAxiomConnection(config, consoleUrlOverride) {
  const consoleEndpointUrl = consoleUrlOverride ?? buildConsoleUrl(config.eval.url);
  return {
    url: config.eval.url,
    consoleEndpointUrl,
    token: config.eval.token,
    dataset: config.eval.dataset,
    orgId: config.eval.orgId
  };
}
var buildConsoleUrl;
var init_resolver = __esm({
  "src/config/resolver.ts"() {
    "use strict";
    init_cjs_shims();
    buildConsoleUrl = (urlString) => {
      const url = new URL(urlString);
      return `${url.protocol}//app.${url.host.split("api.").at(-1)}`;
    };
  }
});

// src/evals/reporter.ts
var AxiomReporter;
var init_reporter = __esm({
  "src/evals/reporter.ts"() {
    "use strict";
    init_cjs_shims();
    init_storage();
    init_reporter_console_utils();
    init_resolver();
    init_eval_command();
    init_dot_path();
    AxiomReporter = class {
      constructor() {
        __publicField(this, "startTime", 0);
        __publicField(this, "start", 0);
        __publicField(this, "_endOfRunConfigEnd");
        __publicField(this, "_suiteData", []);
        __publicField(this, "_printedFlagOverrides", false);
        __publicField(this, "_config");
      }
      onTestRunStart() {
        this.start = performance.now();
        this.startTime = (/* @__PURE__ */ new Date()).getTime();
        const config = getAxiomConfig();
        if (config) {
          this._config = resolveAxiomConnection(config, getConsoleUrl());
        }
      }
      async onTestSuiteReady(_testSuite) {
        const meta = _testSuite.meta();
        if (_testSuite.state() === "skipped" || !meta?.evaluation) {
          return;
        }
        if (!this._printedFlagOverrides) {
          const defaultsFromConfigEnd = meta.evaluation.configEnd?.flags ?? {};
          const overridesFromConfigEnd = meta.evaluation.configEnd?.overrides ?? {};
          if (Object.keys(overridesFromConfigEnd).length > 0) {
            printGlobalFlagOverrides(overridesFromConfigEnd, defaultsFromConfigEnd);
          }
          this._printedFlagOverrides = true;
        }
        if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
          this._endOfRunConfigEnd = meta.evaluation.configEnd;
        }
      }
      onTestCaseReady(test) {
        const meta = test.meta();
        if (!meta.case) return;
      }
      async onTestSuiteResult(testSuite) {
        const meta = testSuite.meta();
        if (testSuite.state() === "skipped" || !meta?.evaluation) {
          return;
        }
        if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
          this._endOfRunConfigEnd = meta.evaluation.configEnd;
        }
        const durationSeconds = Number((performance.now() - this.start) / 1e3).toFixed(2);
        const cases = [];
        for (const test of testSuite.children) {
          if (test.type !== "test") continue;
          const testMeta = test.meta();
          if (!testMeta?.case) continue;
          cases.push({
            index: testMeta.case.index,
            scores: testMeta.case.scores,
            outOfScopeFlags: testMeta.case.outOfScopeFlags,
            errors: testMeta.case.errors,
            runtimeFlags: testMeta.case.runtimeFlags
          });
        }
        const cwd = process.cwd();
        const relativePath = testSuite.module.moduleId.replace(cwd, "").replace(/^\//, "");
        let suiteBaseline = meta.evaluation.baseline;
        let flagConfig = meta.evaluation.flagConfig;
        if (meta.evaluation.configEnd) {
          const defaults = meta.evaluation.configEnd.flags ?? {};
          const overrides2 = meta.evaluation.configEnd.overrides ?? {};
          const defaultsFlat = flattenObject(defaults);
          const overridesFlat = flattenObject(overrides2);
          flagConfig = dotNotationToNested({ ...defaultsFlat, ...overridesFlat });
        }
        const defaultFlagConfig = meta.evaluation.configEnd?.flags;
        this._suiteData.push({
          version: meta.evaluation.version,
          name: meta.evaluation.name,
          file: relativePath,
          duration: durationSeconds + "s",
          baseline: suiteBaseline || null,
          configFlags: meta.evaluation.configFlags,
          flagConfig,
          defaultFlagConfig,
          runId: meta.evaluation.runId,
          orgId: meta.evaluation.orgId,
          cases,
          outOfScopeFlags: meta.evaluation.outOfScopeFlags,
          registrationStatus: meta.evaluation.registrationStatus
        });
        printEvalNameAndFileName(testSuite, meta);
        printBaselineNameAndVersion(meta);
        printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);
        const matchedBaselineIndices = /* @__PURE__ */ new Set();
        const baselineCasesByFingerprint = /* @__PURE__ */ new Map();
        if (suiteBaseline) {
          for (const c of suiteBaseline.cases) {
            const fp = getCaseFingerprint(c.input, c.expected);
            const cases2 = baselineCasesByFingerprint.get(fp) || [];
            cases2.push(c);
            baselineCasesByFingerprint.set(fp, cases2);
          }
        }
        for (const test of testSuite.children) {
          if (test.type !== "test") continue;
          printCaseResult(test, baselineCasesByFingerprint, matchedBaselineIndices);
        }
        if (suiteBaseline) {
          printOrphanedBaselineCases(suiteBaseline, matchedBaselineIndices);
        }
        console.log("");
      }
      async onTestRunEnd(_testModules, _errors, _reason) {
        const shouldClear = !process.env.CI && process.stdout.isTTY !== false;
        if (shouldClear) {
          process.stdout.write("\x1B[2J\x1B[0f");
        }
        const registrationStatus = this._suiteData.map((suite) => ({
          name: suite.name,
          registered: suite.registrationStatus?.status === "success",
          error: suite.registrationStatus?.status === "failed" ? suite.registrationStatus.error : void 0
        }));
        const isDebug = process.env.AXIOM_DEBUG === "true";
        printFinalReport({
          suiteData: this._suiteData,
          config: this._config,
          registrationStatus,
          isDebug
        });
      }
    };
  }
});

// src/evals/instrument.ts
async function resolveInstrumentationHook(config) {
  if (config.eval.instrumentation) {
    return config.eval.instrumentation;
  }
  try {
    const { config: loadedConfig } = await loadConfig(process.cwd());
    return loadedConfig.eval.instrumentation ?? null;
  } catch (error) {
    throw new AxiomCLIError(
      `Failed to reload instrumentation from config: ${errorToString(error)}`
    );
  }
}
async function runInstrumentationHook(hook, options) {
  try {
    return await hook(options);
  } catch (error) {
    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);
  }
}
function setupEvalProvider(connection) {
  const headers = {
    "X-Axiom-Dataset": connection.dataset,
    ...connection.orgId ? { "X-AXIOM-ORG-ID": connection.orgId } : {}
  };
  if (connection.token) {
    headers.Authorization = `Bearer ${connection.token}`;
  }
  const collectorOptions = {
    url: `${connection.url}/v1/traces`,
    headers,
    concurrencyLimit: 10
  };
  const exporter = new import_exporter_trace_otlp_http.OTLPTraceExporter(collectorOptions);
  const processor = new import_sdk_trace_node.BatchSpanProcessor(exporter, {
    maxQueueSize: 2048,
    maxExportBatchSize: 512,
    scheduledDelayMillis: 5e3,
    exportTimeoutMillis: 3e4
  });
  axiomProvider = new import_sdk_trace_node.NodeTracerProvider({
    resource: (0, import_resources.resourceFromAttributes)({
      ["service.name"]: "axiom",
      ["service.version"]: "0.37.0"
    }),
    spanProcessors: [processor]
  });
  axiomTracer = axiomProvider.getTracer("axiom", "0.37.0");
}
async function initInstrumentation(config) {
  if (initialized) {
    return;
  }
  if (initializationPromise) {
    await initializationPromise;
    return;
  }
  initializationPromise = (async () => {
    if (!config.enabled) {
      axiomTracer = import_api10.trace.getTracer("axiom", "0.37.0");
      initialized = true;
      return;
    }
    const connection = resolveAxiomConnection(config.config);
    const hook = await resolveInstrumentationHook(config.config);
    let hookResult = void 0;
    if (hook) {
      config.config.eval.instrumentation = hook;
      hookResult = await runInstrumentationHook(hook, {
        dataset: connection.dataset,
        token: connection.token,
        url: connection.url,
        orgId: connection.orgId
      });
      userProvider = hookResult?.provider ?? userProvider;
    }
    setupEvalProvider(connection);
    if (!hook) {
      axiomProvider?.register();
      if (axiomTracer) {
        initAxiomAI({ tracer: axiomTracer });
      }
    }
    initialized = true;
  })();
  try {
    await initializationPromise;
  } finally {
    initializationPromise = null;
  }
}
var import_sdk_trace_node, import_resources, import_exporter_trace_otlp_http, import_api10, axiomProvider, axiomTracer, userProvider, initializationPromise, initialized, flush;
var init_instrument = __esm({
  "src/evals/instrument.ts"() {
    "use strict";
    init_cjs_shims();
    import_sdk_trace_node = require("@opentelemetry/sdk-trace-node");
    import_resources = require("@opentelemetry/resources");
    import_exporter_trace_otlp_http = require("@opentelemetry/exporter-trace-otlp-http");
    import_api10 = require("@opentelemetry/api");
    init_initAxiomAI();
    init_resolver();
    init_errors();
    init_loader();
    initializationPromise = null;
    initialized = false;
    flush = async () => {
      if (initializationPromise) {
        await initializationPromise;
      }
      const tasks = [];
      if (axiomProvider) {
        tasks.push(axiomProvider.forceFlush());
      }
      const candidateProviders = /* @__PURE__ */ new Set();
      if (userProvider) {
        candidateProviders.add(userProvider);
      }
      const globalProvider = import_api10.trace.getTracerProvider();
      if (globalProvider) {
        candidateProviders.add(globalProvider);
      }
      for (const provider of candidateProviders) {
        const flushFn = provider.forceFlush;
        if (typeof flushFn === "function") {
          tasks.push(
            flushFn.call(provider).catch((error) => {
              console.warn("[AxiomAI] Failed to flush tracer provider:", errorToString(error));
            })
          );
        }
      }
      if (tasks.length > 0) {
        await Promise.all(tasks);
      }
    };
  }
});

// src/evals/run-vitest.ts
var run_vitest_exports = {};
__export(run_vitest_exports, {
  runVitest: () => runVitest
});
var import_node_path2, import_node_fs2, import_node_os, import_node_path3, import_vite_tsconfig_paths, import_node, printCollectedEvals, runVitest;
var init_run_vitest = __esm({
  "src/evals/run-vitest.ts"() {
    "use strict";
    init_cjs_shims();
    init_node();
    import_node_path2 = require("path");
    import_node_fs2 = require("fs");
    import_node_os = require("os");
    import_node_path3 = __toESM(require("path"), 1);
    import_vite_tsconfig_paths = __toESM(require("vite-tsconfig-paths"), 1);
    import_node = require("vitest/node");
    init_reporter();
    init_instrument();
    init_storage();
    printCollectedEvals = (result, rootDir) => {
      if (!result.testModules || result.testModules.length === 0) {
        console.log(u.yellow("\nNo evaluations found\n"));
        return;
      }
      console.log(u.bold("\nFound evaluations:\n"));
      let totalEvals = 0;
      let totalCases = 0;
      for (const module2 of result.testModules) {
        const relativePath = import_node_path3.default.relative(rootDir, module2.moduleId);
        for (const suite of module2.children.suites()) {
          totalEvals++;
          const caseCount = suite.children.size;
          totalCases += caseCount;
          console.log(u.green(`\u2713 ${suite.name} (${caseCount} cases)`));
          console.log(u.dim(`  ${relativePath}`));
          console.log("");
        }
      }
      console.log(u.bold(`Total: ${totalEvals} evaluations, ${totalCases} test cases
`));
    };
    runVitest = async (dir, opts) => {
      setAxiomConfig(opts.config);
      await initInstrumentation({
        enabled: !opts.debug && !opts.list,
        config: opts.config
      });
      const providedConfig = {
        ...opts.config,
        eval: {
          ...opts.config.eval,
          // These can't be serialized, so we need to remove them
          instrumentation: null,
          flagSchema: null
        }
      };
      if (opts.debug) {
        console.log(u.bgWhite(u.blackBright(" Debug mode enabled ")));
      }
      const tmpDir = (0, import_node_path2.join)((0, import_node_os.tmpdir)(), "axiom-eval", opts.runId);
      (0, import_node_fs2.mkdirSync)(tmpDir, { recursive: true });
      const nameRegistryFile = (0, import_node_path2.join)(tmpDir, "names.jsonl");
      const abortFile = (0, import_node_path2.join)(tmpDir, "abort.txt");
      (0, import_node_fs2.writeFileSync)(nameRegistryFile, "", "utf8");
      if ((0, import_node_fs2.existsSync)(abortFile)) {
        (0, import_node_fs2.unlinkSync)(abortFile);
      }
      process.env.AXIOM_NAME_REGISTRY_FILE = nameRegistryFile;
      process.env.AXIOM_ABORT_FILE = abortFile;
      if (opts.list) {
        console.log(u.bgWhite(u.blackBright(" List mode ")));
      }
      const vi = await (0, import_node.createVitest)(
        "test",
        {
          root: dir ? dir : process.cwd(),
          mode: "test",
          include: opts.include,
          exclude: opts.exclude,
          testNamePattern: opts.testNamePattern,
          reporters: ["verbose", new AxiomReporter()],
          environment: "node",
          browser: void 0,
          watch: opts.watch,
          setupFiles: [],
          // ignore user vitest.config.ts etc
          name: "axiom:eval",
          printConsoleTrace: true,
          silent: false,
          disableConsoleIntercept: true,
          testTimeout: opts.config?.eval?.timeoutMs || 6e4,
          globals: true,
          runner: (0, import_node_path2.resolve)(__dirname, "evals", "custom-runner.js"),
          provide: {
            baseline: opts.baseline,
            debug: opts.debug,
            list: opts.list,
            overrides: opts.overrides,
            axiomConfig: providedConfig,
            runId: opts.runId,
            consoleUrl: opts.consoleUrl
          }
        },
        {
          plugins: [(0, import_vite_tsconfig_paths.default)({ root: dir || process.cwd() })]
        }
      );
      if (opts.list) {
        const result = await vi.collect();
        printCollectedEvals(result, dir || process.cwd());
        await vi.close();
        process.exit(0);
      }
      await vi.start();
      if ((0, import_node_fs2.existsSync)(abortFile)) {
        const message = (0, import_node_fs2.readFileSync)(abortFile, "utf8");
        console.error("\n" + message);
        await vi.close();
        process.exit(1);
      }
      const dispose = (0, import_node.registerConsoleShortcuts)(vi, process.stdin, process.stdout);
      if (!vi.shouldKeepServer()) {
        dispose();
        await flush();
        await vi.close();
        process.exit(0);
      }
      await flush();
    };
  }
});

// src/cli/commands/eval.command.ts
function getConsoleUrl() {
  return consoleUrl;
}
function getDefaultToken(value) {
  if (typeof value === "string") {
    return value;
  }
  const authContext2 = getAuthContext();
  return authContext2?.token || process.env.AXIOM_TOKEN;
}
function getDefaultUrl(value) {
  if (typeof value === "string") {
    return value;
  }
  const authContext2 = getAuthContext();
  return authContext2?.url || process.env.AXIOM_URL || "https://api.axiom.co";
}
function getDefaultOrgId(value) {
  if (typeof value === "string") {
    return value;
  }
  const authContext2 = getAuthContext();
  return authContext2?.orgId ?? process.env.AXIOM_ORG_ID;
}
var import_commander, import_nanoid, import_node_fs3, createRunId, consoleUrl, loadEvalCommand;
var init_eval_command = __esm({
  "src/cli/commands/eval.command.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander = require("commander");
    import_nanoid = require("nanoid");
    import_node_fs3 = require("fs");
    init_eval_context_runner();
    init_parse_flag_overrides();
    init_glob_utils();
    init_loader();
    init_errors();
    init_global_auth();
    init_node();
    createRunId = (0, import_nanoid.customAlphabet)("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 10);
    loadEvalCommand = (program2, flagOverrides = {}) => {
      return program2.addCommand(
        new import_commander.Command("eval").description("run evals locally").addArgument(
          new import_commander.Argument("[target]", "file, directory, glob pattern, or eval name").default(
            ".",
            "any *.eval.ts file in current directory"
          )
        ).option("-w, --watch true", "keep server running and watch for changes", false).option("-t, --token <TOKEN>", "axiom token", getDefaultToken).option("-d, --dataset <DATASET>", "axiom dataset name", process.env.AXIOM_DATASET).option("-u, --url <AXIOM URL>", "axiom url", getDefaultUrl).option("-o, --org-id <ORG ID>", "axiom organization id", getDefaultOrgId).option("-b, --baseline <BASELINE ID>", "id of baseline evaluation to compare against").option("--debug", "run locally without any network operations", false).option("--list", "list evaluations and test cases without running them", false).addOption(new import_commander.Option("-c, --console-url <URL>", "console url override").hideHelp()).action(async (target, options) => {
          try {
            if (options.debug) {
              process.env.AXIOM_DEBUG = "true";
            }
            let include = [];
            let exclude;
            let testNamePattern;
            const isGlobPattern = isGlob(target);
            const { config: loadedConfig } = await loadConfig(".");
            validateFlagOverrides(flagOverrides, loadedConfig.eval.flagSchema);
            const config = {
              ...loadedConfig,
              eval: {
                ...loadedConfig.eval,
                ...options.token && { token: options.token },
                ...options.url && { url: options.url },
                ...options.dataset && { dataset: options.dataset },
                ...options.orgId && { orgId: options.orgId }
              }
            };
            if (isGlobPattern) {
              include = [target];
            } else {
              try {
                const stat = (0, import_node_fs3.lstatSync)(target);
                if (stat.isDirectory()) {
                  include = config?.eval?.include || [];
                } else {
                  include = [target];
                }
              } catch {
                testNamePattern = new RegExp(target, "i");
                include = config?.eval?.include || [];
              }
            }
            exclude = config?.eval?.exclude;
            if (!config?.eval?.instrumentation) {
              console.warn(
                u.yellow(
                  "\u26A0 App instrumentation (`eval.instrumentation` in `axiom.config.ts`) not configured. Using default provider."
                )
              );
              console.log("");
            }
            const runId = createRunId();
            consoleUrl = options.consoleUrl;
            let runVitestModule;
            try {
              runVitestModule = await Promise.resolve().then(() => (init_run_vitest(), run_vitest_exports));
            } catch (err) {
              if (err && typeof err === "object" && "code" in err && (err.code === "ERR_MODULE_NOT_FOUND" || err.code === "MODULE_NOT_FOUND")) {
                throw new AxiomCLIError("Failed to load vitest.");
              }
              throw err;
            }
            const { runVitest: runVitest2 } = runVitestModule;
            await runEvalWithContext(flagOverrides, async () => {
              return runVitest2(".", {
                watch: options.watch,
                baseline: options.baseline,
                include,
                exclude,
                testNamePattern,
                debug: options.debug,
                list: options.list,
                overrides: flagOverrides,
                config,
                runId,
                consoleUrl: options.consoleUrl
              });
            });
          } catch (error) {
            if (error instanceof AxiomCLIError) {
              console.error(`
\u274C ${error.message}
`);
              process.exit(1);
            }
            throw error;
          }
        })
      );
    };
  }
});

// src/bin.ts
var bin_exports = {};
__export(bin_exports, {
  program: () => program
});
module.exports = __toCommonJS(bin_exports);
init_cjs_shims();
var import_commander3 = require("commander");
init_eval_command();

// src/cli/commands/auth.command.ts
init_cjs_shims();

// src/cli/commands/auth-login.command.ts
init_cjs_shims();
init_oauth();
init_callback_server();
init_config();
init_api();
init_errors();
var BASE_HOSTNAME = "axiom.co";
var getApiUrl = (hostname) => {
  return `https://api.${hostname}`;
};
var getOauthUrl = (hostname) => {
  return `https://login.${hostname}`;
};
async function promptSelect(message, choices) {
  console.log(`
${message}`);
  choices.forEach((choice, index) => {
    console.log(`  ${index + 1}. ${choice.name}`);
  });
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve3) => {
    const askQuestion = () => {
      rl.question(`
Select (1-${choices.length}): `, (answer) => {
        const index = parseInt(answer.trim(), 10) - 1;
        if (index >= 0 && index < choices.length) {
          rl.close();
          resolve3(choices[index].value);
        } else {
          console.log("Invalid selection. Please try again.");
          askQuestion();
        }
      });
    };
    askQuestion();
  });
}
async function promptInput(message, defaultValue) {
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve3) => {
    const prompt = defaultValue ? `${message} (${defaultValue}): ` : `${message}: `;
    rl.question(prompt, (answer) => {
      rl.close();
      resolve3(answer.trim() || defaultValue || "");
    });
  });
}
async function openBrowser(url) {
  const { default: open } = await import("open");
  await open(url);
}
async function loginCommand(hostname) {
  try {
    console.log("\u{1F510} Starting authentication flow...\n");
    const codeVerifier = OAuth.generateCodeVerifier();
    const codeChallenge = OAuth.generateCodeChallenge(codeVerifier);
    const state = OAuth.generateState();
    const oauth = new OAuth(getOauthUrl(hostname));
    const { server, url: redirectUri } = await startCallbackServer();
    console.log(`\u2713 Started local callback server on ${redirectUri}
`);
    const authUrl = oauth.buildAuthUrl({
      redirectUri,
      state,
      codeChallenge
    });
    console.log("Opening browser for authentication...");
    console.log(`If the browser doesn't open, visit: ${authUrl}
`);
    try {
      await openBrowser(authUrl);
    } catch {
      console.log("Could not open browser automatically.\n");
    }
    console.log("Waiting for authentication...");
    const { code } = await waitForCallback(server, state);
    console.log("\u2713 Authentication successful, exchanging code for token...\n");
    const accessToken = await oauth.exchangeCodeForToken({
      code,
      redirectUri,
      codeVerifier
    });
    console.log("\u2713 Token received, fetching organizations...\n");
    const organizations = await fetchOrganizations(accessToken, getApiUrl(hostname));
    if (organizations.length === 0) {
      throw new AxiomCLIError("No organizations found for this account");
    }
    let selectedOrgId;
    if (organizations.length === 1) {
      selectedOrgId = organizations[0].id;
      console.log(`\u2713 Using organization: ${organizations[0].name}
`);
    } else {
      selectedOrgId = await promptSelect(
        "Select an organization:",
        organizations.map((org) => ({
          name: `${org.name} (${org.id})`,
          value: org.id
        }))
      );
    }
    const selectedOrg = organizations.find((org) => org.id === selectedOrgId);
    const defaultAlias = selectedOrg.slug || selectedOrg.name.toLowerCase().replace(/\s+/g, "-");
    const alias = await promptInput("Enter profile alias", defaultAlias);
    console.log("\n\u2713 Verifying credentials...\n");
    const isValid = await verifyToken(accessToken, selectedOrgId, getApiUrl(hostname));
    if (!isValid) {
      throw new AxiomCLIError("Token verification failed");
    }
    const config = await loadGlobalConfig();
    config.active_profile = alias;
    config.profiles[alias] = {
      url: getApiUrl(hostname),
      token: accessToken,
      org_id: selectedOrgId
    };
    await saveGlobalConfig(config);
    console.log(`\u2713 Successfully logged in as ${alias}`);
    console.log(`\u2713 Configuration saved to ${getGlobalConfigPath()}
`);
  } catch (error) {
    if (error instanceof AxiomCLIError) {
      throw error;
    }
    throw new AxiomCLIError(`Login failed: ${error.message}`);
  }
}
function loadAuthLoginCommand(auth, root) {
  [auth, root].forEach((program2) => {
    program2.command("login").description("Authenticate with Axiom").option("--hostname <hostname>", "Axiom hostname (default: axiom.co)").action(async (options) => {
      try {
        await loginCommand(options.hostname ?? BASE_HOSTNAME);
      } catch (error) {
        if (error instanceof AxiomCLIError) {
          console.error(`
\u274C Error: ${error.message}
`);
        } else {
          console.error(`
\u274C Unexpected error: ${error.message}
`);
        }
        process.exit(1);
      }
    });
  });
}

// src/cli/commands/auth-logout.command.ts
init_cjs_shims();
init_config();
init_errors();
async function logoutCommand(alias) {
  const config = await loadGlobalConfig();
  const profileToRemove = alias || config.active_profile;
  if (!profileToRemove) {
    throw new AxiomCLIError("No active profile. Use --alias to specify which profile to remove.");
  }
  if (!config.profiles[profileToRemove]) {
    throw new AxiomCLIError(`Profile "${profileToRemove}" not found`);
  }
  delete config.profiles[profileToRemove];
  if (config.active_profile === profileToRemove) {
    const remainingProfiles = Object.keys(config.profiles);
    config.active_profile = remainingProfiles.length > 0 ? remainingProfiles[0] : void 0;
  }
  await saveGlobalConfig(config);
  console.log(`\u2713 Logged out from ${profileToRemove}`);
  if (config.active_profile) {
    console.log(`\u2713 Active profile is now: ${config.active_profile}`);
  } else {
    console.log('No active profiles remaining. Run "axiom auth login" to authenticate.');
  }
}
function loadAuthLogoutCommand(auth, root) {
  [auth, root].forEach((program2) => {
    program2.command("logout").description("Remove authentication credentials").option("-a, --alias <alias>", "Profile alias to remove").action(async (options) => {
      try {
        await logoutCommand(options.alias);
      } catch (error) {
        if (error instanceof AxiomCLIError) {
          console.error(`
\u274C Error: ${error.message}
`);
        } else {
          console.error(`
\u274C Unexpected error: ${error.message}
`);
        }
        process.exit(1);
      }
    });
  });
}

// src/cli/commands/auth-status.command.ts
init_cjs_shims();
init_config();
init_api();
init_errors();
async function statusCommand() {
  const config = await loadGlobalConfig();
  if (Object.keys(config.profiles).length === 0) {
    console.log("No authenticated profiles found.");
    console.log('Run "axiom auth login" to authenticate.');
    return;
  }
  console.log("\nAuthentication Status:\n");
  for (const [alias, profile] of Object.entries(config.profiles)) {
    const isActive = config.active_profile === alias;
    const marker = isActive ? "\u2192" : " ";
    try {
      const isValid = await verifyToken(profile.token, profile.org_id, profile.url);
      const status = isValid ? "\u2713" : "\u2717";
      const statusText = isValid ? "Valid" : "Invalid";
      console.log(`${marker} ${status} ${alias}`);
      console.log(`    URL: ${profile.url}`);
      console.log(`    Org ID: ${profile.org_id}`);
      console.log(`    Status: ${statusText}`);
      if (isActive) {
        console.log(`    (Active)`);
      }
      console.log();
    } catch (error) {
      console.log(`${marker} \u2717 ${alias}`);
      console.log(`    URL: ${profile.url}`);
      console.log(`    Org ID: ${profile.org_id}`);
      console.log(`    Status: Error - ${error.message}`);
      if (isActive) {
        console.log(`    (Active)`);
      }
      console.log();
    }
  }
  const activeProfile = getActiveProfile(config);
  if (process.env.AXIOM_TOKEN) {
    console.log("Note: Using AXIOM_TOKEN environment variable (overrides config file)\n");
  } else if (activeProfile && config.active_profile) {
    console.log(`Active profile: ${config.active_profile}
`);
  }
}
function loadAuthStatusCommand(auth, program2) {
  [auth, program2].forEach((program3) => {
    program3.command("status").description("Check authentication status for all profiles").action(async () => {
      try {
        await statusCommand();
      } catch (error) {
        if (error instanceof AxiomCLIError) {
          console.error(`
\u274C Error: ${error.message}
`);
        } else {
          console.error(`
\u274C Unexpected error: ${error.message}
`);
        }
        process.exit(1);
      }
    });
  });
}

// src/cli/commands/auth-switch.command.ts
init_cjs_shims();
init_config();
init_errors();
async function promptSelect2(message, choices) {
  console.log(`
${message}`);
  choices.forEach((choice, index) => {
    console.log(`  ${index + 1}. ${choice.name}`);
  });
  const readline = await import("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve3) => {
    const askQuestion = () => {
      rl.question(`
Select (1-${choices.length}): `, (answer) => {
        const index = parseInt(answer.trim(), 10) - 1;
        if (index >= 0 && index < choices.length) {
          rl.close();
          resolve3(choices[index].value);
        } else {
          console.log("Invalid selection. Please try again.");
          askQuestion();
        }
      });
    };
    askQuestion();
  });
}
async function switchCommand(alias) {
  const config = await loadGlobalConfig();
  if (Object.keys(config.profiles).length === 0) {
    throw new AxiomCLIError(
      'No authenticated profiles found. Run "axiom auth login" to authenticate.'
    );
  }
  let selectedAlias;
  if (alias) {
    if (!config.profiles[alias]) {
      throw new AxiomCLIError(`Profile "${alias}" not found`);
    }
    selectedAlias = alias;
  } else {
    const profiles = Object.entries(config.profiles).map(([alias2, profile]) => ({
      name: `${alias2} (${profile.url})`,
      value: alias2
    }));
    if (profiles.length === 1) {
      selectedAlias = profiles[0].value;
      console.log(`\u2713 Using profile: ${selectedAlias}
`);
    } else {
      selectedAlias = await promptSelect2("Select a profile to switch to:", profiles);
    }
  }
  if (config.active_profile === selectedAlias) {
    console.log(`\u2713 Profile "${selectedAlias}" is already active
`);
    return;
  }
  config.active_profile = selectedAlias;
  await saveGlobalConfig(config);
  console.log(`\u2713 Switched to profile: ${selectedAlias}
`);
}
function loadAuthSwitchCommand(auth, root) {
  [auth, root].forEach((program2) => {
    program2.command("switch").description("Switch to a different profile").argument("[alias]", "Profile alias to switch to").action(async (alias) => {
      try {
        await switchCommand(alias);
      } catch (error) {
        if (error instanceof AxiomCLIError) {
          console.error(`
\u274C Error: ${error.message}
`);
        } else {
          console.error(`
\u274C Unexpected error: ${error.message}
`);
        }
        process.exit(1);
      }
    });
  });
}

// src/cli/commands/auth.command.ts
function loadAuthCommand(program2) {
  const auth = program2.command("auth").description("Manage authentication with Axiom");
  loadAuthLoginCommand(auth, program2);
  loadAuthLogoutCommand(auth, program2);
  loadAuthStatusCommand(auth, program2);
  loadAuthSwitchCommand(auth, program2);
}

// src/bin.ts
init_parse_flag_overrides();
init_global_auth();
var import_env = __toESM(require("@next/env"), 1);

// src/cli/commands/version.command.ts
init_cjs_shims();
var import_commander2 = require("commander");
var loadVersionCommand = (program2) => {
  return program2.addCommand(
    new import_commander2.Command("version").description("cli version").action(() => {
      console.log("0.37.0");
    })
  );
};

// src/bin.ts
var { loadEnvConfig } = import_env.default;
loadEnvConfig(process.cwd());
var { cleanedArgv, overrides } = extractOverrides(process.argv.slice(2));
var program = new import_commander3.Command();
program.name("axiom").description("Axiom's CLI to manage your objects and run evals").version("0.37.0");
program.hook("preAction", async (_, actionCommand) => {
  const commandName = actionCommand.name();
  const parentCommand = actionCommand.parent;
  const parentName = parentCommand?.name();
  if (commandName === "auth" || parentName === "auth" || commandName === "version") {
    return;
  }
  try {
    await setupGlobalAuth();
  } catch (error) {
    if (error instanceof Error) {
      console.error(`
\u274C ${error.message}
`);
    } else {
      console.error(`
\u274C Unexpected error: ${String(error)}
`);
    }
    process.exit(1);
  }
});
loadAuthCommand(program);
loadEvalCommand(program, overrides);
loadVersionCommand(program);
program.parse(["node", "axiom", ...cleanedArgv]);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  program
});
//# sourceMappingURL=bin.cjs.map
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.6.1_postcss@8.5.6_tsx@4.20.4_typescript@5.9.2/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl, importMetaUrl;
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.6.1_postcss@8.5.6_tsx@4.20.4_typescript@5.9.2/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
    getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
    importMetaUrl = /* @__PURE__ */ getImportMetaUrl();
  }
});

// src/evals/context/manager.ts
function getGlobalContextManager() {
  return globalThis[CONTEXT_MANAGER_SYMBOL];
}
function setGlobalContextManager(manager) {
  globalThis[CONTEXT_MANAGER_SYMBOL] = manager;
}
function getContextManager() {
  const existing = getGlobalContextManager();
  if (existing) return existing;
  let manager;
  if (isNodeJS) {
    try {
      let AsyncLocalStorage;
      const req = (0, import_node_module.createRequire)(importMetaUrl);
      try {
        AsyncLocalStorage = req("node:async_hooks").AsyncLocalStorage;
      } catch {
        AsyncLocalStorage = req("async_hooks").AsyncLocalStorage;
      }
      manager = new AsyncLocalStorage();
    } catch (error) {
      console.warn("AsyncLocalStorage not available, using fallback context manager:", error);
      manager = createFallbackManager();
    }
  } else {
    console.warn("AsyncLocalStorage not available, using fallback context manager");
    manager = createFallbackManager();
  }
  setGlobalContextManager(manager);
  return manager;
}
function createFallbackManager() {
  let currentContext = null;
  return {
    getStore: () => currentContext,
    run: (value, fn) => {
      const prev = currentContext;
      currentContext = value;
      try {
        return fn();
      } finally {
        currentContext = prev;
      }
    }
  };
}
function createAsyncHook(_name) {
  return {
    get() {
      const manager = getContextManager();
      if (manager.getStore) {
        return manager.getStore();
      }
      return void 0;
    },
    run(value, fn) {
      const manager = getContextManager();
      return manager.run(value, fn);
    }
  };
}
var import_node_module, CONTEXT_MANAGER_SYMBOL, isNodeJS;
var init_manager = __esm({
  "src/evals/context/manager.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_module = require("module");
    CONTEXT_MANAGER_SYMBOL = Symbol.for("axiom.context_manager");
    isNodeJS = typeof process !== "undefined" && !!process.versions?.node;
  }
});

// src/evals/context/global-flags.ts
function getRoot() {
  return globalThis[GLOBAL_OVERRIDES_SYMBOL] ?? {};
}
function setRoot(val) {
  globalThis[GLOBAL_OVERRIDES_SYMBOL] = val;
}
function setGlobalFlagOverrides(overrides) {
  setRoot(overrides);
}
function getGlobalFlagOverrides() {
  return getRoot();
}
var GLOBAL_OVERRIDES_SYMBOL;
var init_global_flags = __esm({
  "src/evals/context/global-flags.ts"() {
    "use strict";
    init_cjs_shims();
    GLOBAL_OVERRIDES_SYMBOL = Symbol.for("axiom.global_flag_overrides");
  }
});

// src/cli/utils/format-zod-errors.ts
var import_zod;
var init_format_zod_errors = __esm({
  "src/cli/utils/format-zod-errors.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod = require("zod");
  }
});

// src/util/zod-internals.ts
var init_zod_internals = __esm({
  "src/util/zod-internals.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/util/dot-path.ts
function parsePath(path) {
  return path.split(".");
}
function dotNotationToNested(dotNotationObject) {
  const result = {};
  for (const [dotPath, value] of Object.entries(dotNotationObject)) {
    const segments = parsePath(dotPath);
    let current = result;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === segments.length - 1) {
        current[segment] = value;
      } else {
        if (!(segment in current) || typeof current[segment] !== "object") {
          current[segment] = {};
        }
        current = current[segment];
      }
    }
  }
  return result;
}
function flattenObject(obj, prefix = "") {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value, newKey));
    } else {
      result[newKey] = value;
    }
  }
  return result;
}
var import_zod2;
var init_dot_path = __esm({
  "src/util/dot-path.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod2 = require("zod");
    init_zod_internals();
  }
});

// src/util/deep-partial-schema.ts
var import_zod3;
var init_deep_partial_schema = __esm({
  "src/util/deep-partial-schema.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod3 = require("zod");
    init_zod_internals();
  }
});

// src/validate-flags.ts
var import_zod4;
var init_validate_flags = __esm({
  "src/validate-flags.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod4 = require("zod");
    init_global_flags();
    init_format_zod_errors();
    init_dot_path();
    init_deep_partial_schema();
    init_zod_internals();
  }
});

// src/otel/utils/to-otel-attribute.ts
var import_api;
var init_to_otel_attribute = __esm({
  "src/otel/utils/to-otel-attribute.ts"() {
    "use strict";
    init_cjs_shims();
    import_api = require("@opentelemetry/api");
  }
});

// src/otel/withSpanBaggageKey.ts
var init_withSpanBaggageKey = __esm({
  "src/otel/withSpanBaggageKey.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/semconv/eval_proposal.ts
var ATTR_EVAL_ID, ATTR_EVAL_NAME, ATTR_EVAL_VERSION, ATTR_EVAL_TYPE, ATTR_EVAL_TAGS, ATTR_EVAL_BASELINE_ID, ATTR_EVAL_BASELINE_NAME, ATTR_EVAL_BASELINE_VERSION, ATTR_EVAL_METADATA, ATTR_EVAL_CAPABILITY_NAME, ATTR_EVAL_STEP_NAME, ATTR_EVAL_COLLECTION_ID, ATTR_EVAL_COLLECTION_SIZE, ATTR_EVAL_COLLECTION_NAME, ATTR_EVAL_CONFIG_FLAGS, ATTR_EVAL_CASE_INDEX, ATTR_EVAL_CASE_INPUT, ATTR_EVAL_CASE_OUTPUT, ATTR_EVAL_CASE_EXPECTED, ATTR_EVAL_CASE_SCORES, ATTR_EVAL_CASE_METADATA, ATTR_EVAL_TASK_OUTPUT, ATTR_EVAL_TASK_NAME, ATTR_EVAL_TASK_TYPE, ATTR_EVAL_RUN_ID, ATTR_EVAL_SCORE_NAME, ATTR_EVAL_SCORE_VALUE, ATTR_EVAL_SCORE_THRESHOLD, ATTR_EVAL_SCORE_PASSED, ATTR_EVAL_SCORE_IS_BOOLEAN, ATTR_EVAL_SCORE_METADATA, ATTR_EVAL_USER_NAME, ATTR_EVAL_USER_EMAIL;
var init_eval_proposal = __esm({
  "src/otel/semconv/eval_proposal.ts"() {
    "use strict";
    init_cjs_shims();
    ATTR_EVAL_ID = "eval.id";
    ATTR_EVAL_NAME = "eval.name";
    ATTR_EVAL_VERSION = "eval.version";
    ATTR_EVAL_TYPE = "eval.type";
    ATTR_EVAL_TAGS = "eval.tags";
    ATTR_EVAL_BASELINE_ID = "eval.baseline.id";
    ATTR_EVAL_BASELINE_NAME = "eval.baseline.name";
    ATTR_EVAL_BASELINE_VERSION = "eval.baseline.version";
    ATTR_EVAL_METADATA = "eval.metadata";
    ATTR_EVAL_CAPABILITY_NAME = "eval.capability.name";
    ATTR_EVAL_STEP_NAME = "eval.step.name";
    ATTR_EVAL_COLLECTION_ID = "eval.collection.id";
    ATTR_EVAL_COLLECTION_SIZE = "eval.collection.size";
    ATTR_EVAL_COLLECTION_NAME = "eval.collection.name";
    ATTR_EVAL_CONFIG_FLAGS = "eval.config.flags";
    ATTR_EVAL_CASE_INDEX = "eval.case.index";
    ATTR_EVAL_CASE_INPUT = "eval.case.input";
    ATTR_EVAL_CASE_OUTPUT = "eval.case.output";
    ATTR_EVAL_CASE_EXPECTED = "eval.case.expected";
    ATTR_EVAL_CASE_SCORES = "eval.case.scores";
    ATTR_EVAL_CASE_METADATA = "eval.case.metadata";
    ATTR_EVAL_TASK_OUTPUT = "eval.task.output";
    ATTR_EVAL_TASK_NAME = "eval.task.name";
    ATTR_EVAL_TASK_TYPE = "eval.task.type";
    ATTR_EVAL_RUN_ID = "eval.run.id";
    ATTR_EVAL_SCORE_NAME = "eval.score.name";
    ATTR_EVAL_SCORE_VALUE = "eval.score.value";
    ATTR_EVAL_SCORE_THRESHOLD = "eval.score.threshold";
    ATTR_EVAL_SCORE_PASSED = "eval.score.passed";
    ATTR_EVAL_SCORE_IS_BOOLEAN = "eval.score.is_boolean";
    ATTR_EVAL_SCORE_METADATA = "eval.score.metadata";
    ATTR_EVAL_USER_NAME = "eval.user.name";
    ATTR_EVAL_USER_EMAIL = "eval.user.email";
  }
});

// src/otel/semconv/attributes.ts
var import_semantic_conventions, import_incubating, ATTR_AXIOM_GEN_AI_SCHEMA_URL, ATTR_AXIOM_GEN_AI_SDK_NAME, ATTR_AXIOM_GEN_AI_SDK_VERSION, ATTR_GEN_AI_CAPABILITY_NAME, ATTR_GEN_AI_STEP_NAME, ATTR_GEN_AI_TOOL_ARGUMENTS, ATTR_GEN_AI_TOOL_MESSAGE, GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI, GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS, GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM, GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA, GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS, GEN_AI_PROVIDER_NAME_VALUE_FAL, GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS, GEN_AI_PROVIDER_NAME_VALUE_GLADIA, GEN_AI_PROVIDER_NAME_VALUE_HUME, GEN_AI_PROVIDER_NAME_VALUE_LMNT, GEN_AI_PROVIDER_NAME_VALUE_LUMA, GEN_AI_PROVIDER_NAME_VALUE_REPLICATE, GEN_AI_PROVIDER_NAME_VALUE_REVAI, GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI, GEN_AI_PROVIDER_NAME_VALUE_VERCEL, Attr;
var init_attributes = __esm({
  "src/otel/semconv/attributes.ts"() {
    "use strict";
    init_cjs_shims();
    import_semantic_conventions = require("@opentelemetry/semantic-conventions");
    init_eval_proposal();
    import_incubating = require("@opentelemetry/semantic-conventions/incubating");
    ATTR_AXIOM_GEN_AI_SCHEMA_URL = "axiom.gen_ai.schema_url";
    ATTR_AXIOM_GEN_AI_SDK_NAME = "axiom.gen_ai.sdk.name";
    ATTR_AXIOM_GEN_AI_SDK_VERSION = "axiom.gen_ai.sdk.version";
    ATTR_GEN_AI_CAPABILITY_NAME = "gen_ai.capability.name";
    ATTR_GEN_AI_STEP_NAME = "gen_ai.step.name";
    ATTR_GEN_AI_TOOL_ARGUMENTS = "gen_ai.tool.arguments";
    ATTR_GEN_AI_TOOL_MESSAGE = "gen_ai.tool.message";
    GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI = "assemblyai";
    GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS = "cerebras";
    GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM = "deepgram";
    GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA = "deepinfra";
    GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS = "elevenlabs";
    GEN_AI_PROVIDER_NAME_VALUE_FAL = "fal";
    GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS = "fireworks";
    GEN_AI_PROVIDER_NAME_VALUE_GLADIA = "gladia";
    GEN_AI_PROVIDER_NAME_VALUE_HUME = "hume";
    GEN_AI_PROVIDER_NAME_VALUE_LMNT = "lmnt";
    GEN_AI_PROVIDER_NAME_VALUE_LUMA = "luma";
    GEN_AI_PROVIDER_NAME_VALUE_REPLICATE = "replicate";
    GEN_AI_PROVIDER_NAME_VALUE_REVAI = "revai";
    GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI = "togetherai";
    GEN_AI_PROVIDER_NAME_VALUE_VERCEL = "vercel";
    Attr = {
      __EXPERIMENTAL_Flag: (flagName) => `flag.${flagName}`,
      __EXPERIMENTAL_Fact: (factName) => `fact.${factName}`,
      Axiom: {
        GenAI: {
          SchemaURL: ATTR_AXIOM_GEN_AI_SCHEMA_URL,
          SDK: {
            Name: ATTR_AXIOM_GEN_AI_SDK_NAME,
            Version: ATTR_AXIOM_GEN_AI_SDK_VERSION
          }
        }
      },
      GenAI: {
        PromptMetadata: {
          ID: "axiom.gen_ai.prompt.id",
          Name: "axiom.gen_ai.prompt.name",
          Slug: "axiom.gen_ai.prompt.slug",
          Version: "axiom.gen_ai.prompt.version"
        },
        /**
         * These two are used to identify the span
         */
        Capability: {
          Name: ATTR_GEN_AI_CAPABILITY_NAME
        },
        Step: {
          Name: ATTR_GEN_AI_STEP_NAME
        },
        Provider: {
          Name: import_incubating.ATTR_GEN_AI_PROVIDER_NAME,
          Name_Values: {
            Anthropic: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_ANTHROPIC,
            AssemblyAI: GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI,
            AWSBedrock: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_AWS_BEDROCK,
            AzureAIInference: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_INFERENCE,
            AzureAIOpenAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_OPENAI,
            Cerebras: GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS,
            Cohere: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_COHERE,
            Deepgram: GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM,
            DeepInfra: GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA,
            Deepseek: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_DEEPSEEK,
            ElevenLabs: GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS,
            Fal: GEN_AI_PROVIDER_NAME_VALUE_FAL,
            Fireworks: GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS,
            GCPGemini: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GCP_GEMINI,
            GCPGenAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GCP_GEN_AI,
            GCPVertexAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GCP_VERTEX_AI,
            Gladia: GEN_AI_PROVIDER_NAME_VALUE_GLADIA,
            Groq: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GROQ,
            Hume: GEN_AI_PROVIDER_NAME_VALUE_HUME,
            IBMWatsonxAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_IBM_WATSONX_AI,
            Lmnt: GEN_AI_PROVIDER_NAME_VALUE_LMNT,
            Luma: GEN_AI_PROVIDER_NAME_VALUE_LUMA,
            MistralAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_MISTRAL_AI,
            OpenAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_OPENAI,
            Perplexity: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_PERPLEXITY,
            Replicate: GEN_AI_PROVIDER_NAME_VALUE_REPLICATE,
            RevAI: GEN_AI_PROVIDER_NAME_VALUE_REVAI,
            TogetherAI: GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI,
            Vercel: GEN_AI_PROVIDER_NAME_VALUE_VERCEL,
            XAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_X_AI
          }
        },
        /**
         * Regular attributes
         */
        Agent: {
          Description: import_incubating.ATTR_GEN_AI_AGENT_DESCRIPTION,
          // not yet used by axiom-ai
          ID: import_incubating.ATTR_GEN_AI_AGENT_ID,
          // not yet used by axiom-ai
          Name: import_incubating.ATTR_GEN_AI_AGENT_NAME
          // not yet used by axiom-ai
        },
        Conversation: {
          ID: import_incubating.ATTR_GEN_AI_CONVERSATION_ID
          // not yet used by axiom-ai, anyway probably needs to be provided by user
        },
        Input: {
          Messages: import_incubating.ATTR_GEN_AI_INPUT_MESSAGES
        },
        Operation: {
          Name: import_incubating.ATTR_GEN_AI_OPERATION_NAME,
          Name_Values: {
            /**
             * Note that "text_completion" is deprecated in favor of "chat" for both OpenAI and Anthropic
             */
            Chat: import_incubating.GEN_AI_OPERATION_NAME_VALUE_CHAT,
            CreateAgent: import_incubating.GEN_AI_OPERATION_NAME_VALUE_CREATE_AGENT,
            Embeddings: import_incubating.GEN_AI_OPERATION_NAME_VALUE_EMBEDDINGS,
            ExecuteTool: import_incubating.GEN_AI_OPERATION_NAME_VALUE_EXECUTE_TOOL,
            GenerateContent: import_incubating.GEN_AI_OPERATION_NAME_VALUE_GENERATE_CONTENT,
            InvokeAgent: import_incubating.GEN_AI_OPERATION_NAME_VALUE_INVOKE_AGENT
          }
        },
        Output: {
          Messages: import_incubating.ATTR_GEN_AI_OUTPUT_MESSAGES,
          Type: import_incubating.ATTR_GEN_AI_OUTPUT_TYPE,
          Type_Values: {
            Text: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_TEXT,
            Json: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_JSON,
            Image: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_IMAGE,
            Speech: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_SPEECH
          }
        },
        /**
         * The provider that is hosting the model, eg AWS Bedrock
         * There doesn't seem to be a semconv for this
         */
        Request: {
          ChoiceCount: import_incubating.ATTR_GEN_AI_REQUEST_CHOICE_COUNT,
          // not yet used by axiom-ai
          EncodingFormats: import_incubating.ATTR_GEN_AI_REQUEST_ENCODING_FORMATS,
          // not yet used by axiom-ai
          FrequencyPenalty: import_incubating.ATTR_GEN_AI_REQUEST_FREQUENCY_PENALTY,
          MaxTokens: import_incubating.ATTR_GEN_AI_REQUEST_MAX_TOKENS,
          /**
           * The model you asked for
           */
          Model: import_incubating.ATTR_GEN_AI_REQUEST_MODEL,
          PresencePenalty: import_incubating.ATTR_GEN_AI_REQUEST_PRESENCE_PENALTY,
          Seed: import_incubating.ATTR_GEN_AI_REQUEST_SEED,
          StopSequences: import_incubating.ATTR_GEN_AI_REQUEST_STOP_SEQUENCES,
          Temperature: import_incubating.ATTR_GEN_AI_REQUEST_TEMPERATURE,
          TopK: import_incubating.ATTR_GEN_AI_REQUEST_TOP_K,
          TopP: import_incubating.ATTR_GEN_AI_REQUEST_TOP_P
        },
        Response: {
          FinishReasons: import_incubating.ATTR_GEN_AI_RESPONSE_FINISH_REASONS,
          ID: import_incubating.ATTR_GEN_AI_RESPONSE_ID,
          /**
           * The model that was actually used (might be different bc routing) - only ever get this from the response, otherwise omit
           */
          Model: import_incubating.ATTR_GEN_AI_RESPONSE_MODEL
          // somehow not landing on the span for google models? check up on this...
        },
        Tool: {
          CallID: import_incubating.ATTR_GEN_AI_TOOL_CALL_ID,
          Description: import_incubating.ATTR_GEN_AI_TOOL_DESCRIPTION,
          Name: import_incubating.ATTR_GEN_AI_TOOL_NAME,
          Type: import_incubating.ATTR_GEN_AI_TOOL_TYPE,
          /**
           * Note, OTel Semantic Convention suggest only putting tool inputs/outputs on the parent chat span
           * But we at least want to give users THE OPTION to put them on the tool spans themselves as well
           * Because it enables a lot of things with querying
           * @see https://github.com/open-telemetry/semantic-conventions/releases/tag/v1.37.0
           */
          Arguments: ATTR_GEN_AI_TOOL_ARGUMENTS,
          /**
           * Note, OTel Semantic Convention suggest only putting tool inputs/outputs on the parent chat span
           * But we at least want to give users THE OPTION to put them on the tool spans themselves as well
           * Because it enables a lot of things with querying
           * @see https://github.com/open-telemetry/semantic-conventions/releases/tag/v1.37.0
           */
          Message: ATTR_GEN_AI_TOOL_MESSAGE
        },
        Usage: {
          InputTokens: import_incubating.ATTR_GEN_AI_USAGE_INPUT_TOKENS,
          OutputTokens: import_incubating.ATTR_GEN_AI_USAGE_OUTPUT_TOKENS
        }
      },
      Eval: {
        ID: ATTR_EVAL_ID,
        Name: ATTR_EVAL_NAME,
        Version: ATTR_EVAL_VERSION,
        Type: ATTR_EVAL_TYPE,
        Baseline: {
          ID: ATTR_EVAL_BASELINE_ID,
          Name: ATTR_EVAL_BASELINE_NAME,
          Version: ATTR_EVAL_BASELINE_VERSION
        },
        Capability: {
          Name: ATTR_EVAL_CAPABILITY_NAME
        },
        Step: {
          Name: ATTR_EVAL_STEP_NAME
        },
        Tags: ATTR_EVAL_TAGS,
        Metadata: ATTR_EVAL_METADATA,
        Collection: {
          ID: ATTR_EVAL_COLLECTION_ID,
          Name: ATTR_EVAL_COLLECTION_NAME,
          Size: ATTR_EVAL_COLLECTION_SIZE
        },
        Config: {
          Flags: ATTR_EVAL_CONFIG_FLAGS
        },
        Run: {
          ID: ATTR_EVAL_RUN_ID
        },
        Case: {
          Index: ATTR_EVAL_CASE_INDEX,
          Input: ATTR_EVAL_CASE_INPUT,
          Output: ATTR_EVAL_CASE_OUTPUT,
          Expected: ATTR_EVAL_CASE_EXPECTED,
          Scores: ATTR_EVAL_CASE_SCORES,
          Metadata: ATTR_EVAL_CASE_METADATA
        },
        Task: {
          Output: ATTR_EVAL_TASK_OUTPUT,
          Name: ATTR_EVAL_TASK_NAME,
          Type: ATTR_EVAL_TASK_TYPE
        },
        Score: {
          Name: ATTR_EVAL_SCORE_NAME,
          Value: ATTR_EVAL_SCORE_VALUE,
          Threshold: ATTR_EVAL_SCORE_THRESHOLD,
          Passed: ATTR_EVAL_SCORE_PASSED,
          IsBoolean: ATTR_EVAL_SCORE_IS_BOOLEAN,
          Metadata: ATTR_EVAL_SCORE_METADATA
        },
        User: {
          Name: ATTR_EVAL_USER_NAME,
          Email: ATTR_EVAL_USER_EMAIL
        }
      },
      Error: {
        Type: import_semantic_conventions.ATTR_ERROR_TYPE,
        Message: import_incubating.ATTR_ERROR_MESSAGE
      },
      HTTP: {
        Response: {
          StatusCode: import_semantic_conventions.ATTR_HTTP_RESPONSE_STATUS_CODE
        }
      }
    };
  }
});

// src/schema.ts
var SCHEMA_VERSION, SCHEMA_BASE_URL, SCHEMA_URL;
var init_schema = __esm({
  "src/schema.ts"() {
    "use strict";
    init_cjs_shims();
    SCHEMA_VERSION = "0.0.2";
    SCHEMA_BASE_URL = "https://axiom.co/ai/schemas/";
    SCHEMA_URL = `${SCHEMA_BASE_URL}${SCHEMA_VERSION}`;
  }
});

// src/otel/startActiveSpan.ts
var import_api2;
var init_startActiveSpan = __esm({
  "src/otel/startActiveSpan.ts"() {
    "use strict";
    init_cjs_shims();
    import_api2 = require("@opentelemetry/api");
  }
});

// package.json
var package_default;
var init_package = __esm({
  "package.json"() {
    package_default = {
      name: "axiom",
      version: "0.37.0",
      type: "module",
      author: "Axiom, Inc.",
      contributors: [
        "Islam Shehata <islam@axiom.co>",
        "Chris Ehrlich <chris@axiom.co>",
        "Gabriel de Andrade <gabriel@axiom.co>"
      ],
      scripts: {
        dev: "tsup --watch",
        build: "tsup && chmod +x dist/bin.js",
        format: "prettier --write .",
        "format:check": "prettier --check .",
        lint: "eslint './**/*.{js,ts}'",
        typecheck: "tsc --noEmit",
        test: "vitest run",
        "test:watch": "vitest --watch",
        publint: "npx publint"
      },
      types: "./dist/index.d.ts",
      main: "./dist/index.cjs",
      module: "./dist/index.js",
      bin: {
        axiom: "./dist/bin.js"
      },
      exports: {
        "./ai": {
          import: {
            types: "./dist/index.d.ts",
            default: "./dist/index.js"
          },
          require: {
            types: "./dist/index.d.cts",
            default: "./dist/index.cjs"
          }
        },
        "./ai/evals": {
          import: {
            types: "./dist/evals.d.ts",
            default: "./dist/evals.js"
          },
          require: {
            types: "./dist/evals.d.cts",
            default: "./dist/evals.cjs"
          }
        },
        "./ai/config": {
          import: {
            types: "./dist/config.d.ts",
            default: "./dist/config.js"
          },
          require: {
            types: "./dist/config.d.cts",
            default: "./dist/config.cjs"
          }
        },
        "./ai/feedback": {
          import: {
            types: "./dist/feedback.d.ts",
            default: "./dist/feedback.js"
          },
          require: {
            types: "./dist/feedback.d.cts",
            default: "./dist/feedback.cjs"
          }
        }
      },
      keywords: [
        "axiom",
        "logging",
        "ai",
        "otel",
        "opentelemetry"
      ],
      repository: {
        type: "git",
        url: "git+https://github.com/axiomhq/ai.git",
        directory: "packages/ai"
      },
      license: "MIT",
      dependencies: {
        "@next/env": "^15.4.2",
        "@opentelemetry/auto-instrumentations-node": "^0.60.1",
        "@opentelemetry/context-async-hooks": "^2.0.1",
        "@opentelemetry/exporter-trace-otlp-http": "^0.202.0",
        "@opentelemetry/resources": "^2.0.1",
        "@opentelemetry/sdk-trace-node": "^2.0.1",
        "@opentelemetry/semantic-conventions": "^1.37.0",
        "@sinclair/typebox": "^0.34.37",
        c12: "^2.0.4",
        commander: "^14.0.0",
        defu: "^6.1.4",
        handlebars: "^4.7.8",
        nanoid: "^5.1.5",
        open: "^10.1.0",
        "vite-tsconfig-paths": "^5.1.4",
        vitest: "^4.0.0"
      },
      peerDependencies: {
        "@opentelemetry/api": "^1.9.0",
        zod: "^3.25.0 || ^4.0.0"
      },
      devDependencies: {
        "@ai-sdk/anthropicv1": "npm:@ai-sdk/anthropic@^1.2.12",
        "@ai-sdk/anthropicv2": "npm:@ai-sdk/anthropic@^2.0.44",
        "@ai-sdk/openaiv1": "npm:@ai-sdk/openai@^1.3.24",
        "@ai-sdk/openaiv2": "npm:@ai-sdk/openai@^2.0.67",
        "@ai-sdk/providerv1": "npm:@ai-sdk/provider@^1.1.3",
        "@ai-sdk/providerv2": "npm:@ai-sdk/provider@^2.0.0",
        "@opentelemetry/api": "^1.9.0",
        "@opentelemetry/core": "^2.0.1",
        "@opentelemetry/sdk-trace-base": "^2.0.1",
        "@opentelemetry/sdk-trace-node": "^2.0.1",
        "@repo/eslint-config": "workspace:*",
        "@types/node": "^22.15.29",
        "@vitest/coverage-v8": "^4.0.0",
        aiv4: "npm:ai@^4.3.19",
        aiv5: "npm:ai@^5.0.93",
        esbuild: "^0.25.8",
        eslint: "catalog:",
        msw: "^2.12.2",
        prettier: "catalog:",
        tinyrainbow: "^2.0.0",
        tsup: "catalog:",
        typescript: "catalog:",
        vitest: "catalog:",
        zod: "catalog:"
      },
      files: [
        "dist"
      ],
      packageManager: "pnpm@10.16.1"
    };
  }
});

// src/otel/utils/redaction.ts
var import_api3, AXIOM_AI_REDACTION_KEY;
var init_redaction = __esm({
  "src/otel/utils/redaction.ts"() {
    "use strict";
    init_cjs_shims();
    import_api3 = require("@opentelemetry/api");
    init_withSpanBaggageKey();
    AXIOM_AI_REDACTION_KEY = Symbol.for("__axiom_ai_redaction__");
  }
});

// src/otel/initAxiomAI.ts
function extractTracerScope(tracer) {
  const tracerAny = tracer;
  const name = tracerAny._instrumentationScope?.name || tracerAny.instrumentationLibrary?.name || package_default.name;
  const version = tracerAny._instrumentationScope?.version || tracerAny.instrumentationLibrary?.version || package_default.version;
  return { name, version };
}
function initAxiomAI(config) {
  const newScope = extractTracerScope(config.tracer);
  const existingScope = globalThis[AXIOM_AI_SCOPE_KEY];
  if (existingScope && existingScope.name === newScope.name && existingScope.version === newScope.version) {
    return;
  }
  if (existingScope) {
    console.warn(
      `[AxiomAI] initAxiomAI() called multiple times with different scopes. Previous: ${existingScope.name}@${existingScope.version}, New: ${newScope.name}@${newScope.version}`
    );
  }
  globalThis[AXIOM_AI_SCOPE_KEY] = newScope;
  if (config.redactionPolicy) {
    globalThis[AXIOM_AI_REDACTION_KEY] = config.redactionPolicy;
  }
}
var import_api4, AXIOM_AI_SCOPE_KEY;
var init_initAxiomAI = __esm({
  "src/otel/initAxiomAI.ts"() {
    "use strict";
    init_cjs_shims();
    import_api4 = require("@opentelemetry/api");
    init_package();
    init_redaction();
    AXIOM_AI_SCOPE_KEY = Symbol.for("__axiom_ai_scope__");
  }
});

// src/otel/utils/wrapperUtils.ts
var import_api5;
var init_wrapperUtils = __esm({
  "src/otel/utils/wrapperUtils.ts"() {
    "use strict";
    init_cjs_shims();
    import_api5 = require("@opentelemetry/api");
    init_attributes();
    init_schema();
    init_withSpanBaggageKey();
    init_startActiveSpan();
    init_initAxiomAI();
  }
});

// src/util/name-validation-runtime.ts
var init_name_validation_runtime = __esm({
  "src/util/name-validation-runtime.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/withSpan.ts
var import_api6;
var init_withSpan = __esm({
  "src/otel/withSpan.ts"() {
    "use strict";
    init_cjs_shims();
    import_api6 = require("@opentelemetry/api");
    init_withSpanBaggageKey();
    init_wrapperUtils();
    init_name_validation_runtime();
  }
});

// src/otel/utils/contentSanitizer.ts
var init_contentSanitizer = __esm({
  "src/otel/utils/contentSanitizer.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/completionUtils.ts
var init_completionUtils = __esm({
  "src/otel/completionUtils.ts"() {
    "use strict";
    init_cjs_shims();
    init_contentSanitizer();
  }
});

// src/util/promptUtils.ts
var init_promptUtils = __esm({
  "src/util/promptUtils.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/utils/normalized.ts
var init_normalized = __esm({
  "src/otel/utils/normalized.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/util/currentUnixTime.ts
var init_currentUnixTime = __esm({
  "src/util/currentUnixTime.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/otel/streaming/aggregators.ts
var init_aggregators = __esm({
  "src/otel/streaming/aggregators.ts"() {
    "use strict";
    init_cjs_shims();
    init_currentUnixTime();
  }
});

// src/otel/middleware.ts
var import_api7;
var init_middleware = __esm({
  "src/otel/middleware.ts"() {
    "use strict";
    init_cjs_shims();
    import_api7 = require("@opentelemetry/api");
    init_attributes();
    init_completionUtils();
    init_promptUtils();
    init_contentSanitizer();
    init_wrapperUtils();
    init_normalized();
    init_aggregators();
    init_redaction();
  }
});

// src/otel/AxiomWrappedLanguageModelV1.ts
var init_AxiomWrappedLanguageModelV1 = __esm({
  "src/otel/AxiomWrappedLanguageModelV1.ts"() {
    "use strict";
    init_cjs_shims();
    init_middleware();
  }
});

// src/otel/AxiomWrappedLanguageModelV2.ts
var init_AxiomWrappedLanguageModelV2 = __esm({
  "src/otel/AxiomWrappedLanguageModelV2.ts"() {
    "use strict";
    init_cjs_shims();
    init_middleware();
  }
});

// src/otel/vercel.ts
var init_vercel = __esm({
  "src/otel/vercel.ts"() {
    "use strict";
    init_cjs_shims();
    init_AxiomWrappedLanguageModelV1();
    init_AxiomWrappedLanguageModelV2();
  }
});

// src/otel/index.ts
var init_otel = __esm({
  "src/otel/index.ts"() {
    "use strict";
    init_cjs_shims();
    init_withSpan();
    init_vercel();
    init_attributes();
  }
});

// src/app-scope.ts
var import_api8, import_zod5;
var init_app_scope = __esm({
  "src/app-scope.ts"() {
    "use strict";
    init_cjs_shims();
    init_global_flags();
    init_storage();
    init_validate_flags();
    init_dot_path();
    init_zod_internals();
    import_api8 = require("@opentelemetry/api");
    import_zod5 = require("zod");
    init_to_otel_attribute();
    init_otel();
  }
});

// src/evals/context/storage.ts
function getGlobalConfigScope() {
  return globalThis[CONFIG_SCOPE_SYMBOL];
}
function getAxiomConfig() {
  return globalThis[AXIOM_CONFIG_SYMBOL];
}
function getEvalContext() {
  const ctx = EVAL_CONTEXT.get();
  if (!ctx) {
    return {
      flags: {},
      facts: {},
      pickedFlags: void 0,
      outOfScopeFlags: void 0
    };
  }
  return {
    flags: ctx.flags,
    facts: ctx.facts,
    pickedFlags: ctx.pickedFlags,
    outOfScopeFlags: ctx.outOfScopeFlags,
    parent: ctx.parent,
    overrides: ctx.overrides,
    accessedFlagKeys: ctx.accessedFlagKeys
  };
}
function withEvalContext(options = {}, fn) {
  const { initialFlags = {}, pickedFlags = [] } = options;
  return EVAL_CONTEXT.run(
    {
      flags: { ...initialFlags },
      facts: {},
      pickedFlags,
      outOfScopeFlags: [],
      accessedFlagKeys: []
    },
    fn
  );
}
function getConfigScope() {
  const current = EVAL_CONTEXT.get();
  return current?.configScope ?? getGlobalConfigScope();
}
var import_api9, CONFIG_SCOPE_SYMBOL, AXIOM_CONFIG_SYMBOL, EVAL_CONTEXT;
var init_storage = __esm({
  "src/evals/context/storage.ts"() {
    "use strict";
    init_cjs_shims();
    import_api9 = require("@opentelemetry/api");
    init_manager();
    init_app_scope();
    CONFIG_SCOPE_SYMBOL = Symbol.for("axiom.eval.configScope");
    AXIOM_CONFIG_SYMBOL = Symbol.for("axiom.eval.config");
    EVAL_CONTEXT = createAsyncHook("eval-context");
  }
});

// src/config/resolver.ts
function resolveAxiomConnection(config, consoleUrlOverride) {
  const consoleEndpointUrl = consoleUrlOverride ?? buildConsoleUrl(config.eval.url);
  return {
    url: config.eval.url,
    consoleEndpointUrl,
    token: config.eval.token,
    dataset: config.eval.dataset,
    orgId: config.eval.orgId
  };
}
var buildConsoleUrl;
var init_resolver = __esm({
  "src/config/resolver.ts"() {
    "use strict";
    init_cjs_shims();
    buildConsoleUrl = (urlString) => {
      const url = new URL(urlString);
      return `${url.protocol}//app.${url.host.split("api.").at(-1)}`;
    };
  }
});

// src/util/errors.ts
function getCircularReplacer() {
  const seen = /* @__PURE__ */ new WeakSet();
  return (_k, v) => {
    if (typeof v === "object" && v !== null) {
      if (seen.has(v)) return "[Circular]";
      seen.add(v);
    }
    return v;
  };
}
function safeJson(x) {
  try {
    return JSON.stringify(x, getCircularReplacer());
  } catch {
    return String(x);
  }
}
function errorToString(err) {
  try {
    if (typeof err === "string") return err;
    if (err instanceof Error) {
      return err.stack ?? err.message;
    }
    if (typeof err === "object" && err !== null) {
      const msg = err.message;
      const json = safeJson(err);
      return msg ? `${msg} (${json})` : json;
    }
    return String(err);
  } catch {
    return "[unserializable error]";
  }
}
var AxiomCLIError;
var init_errors = __esm({
  "src/util/errors.ts"() {
    "use strict";
    init_cjs_shims();
    AxiomCLIError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AxiomCLIError";
      }
    };
  }
});

// src/cli/auth/types.ts
var init_types = __esm({
  "src/cli/auth/types.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/cli/auth/config.ts
var init_config = __esm({
  "src/cli/auth/config.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/cli/auth/oauth.ts
var init_oauth = __esm({
  "src/cli/auth/oauth.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/cli/auth/api.ts
var init_api = __esm({
  "src/cli/auth/api.ts"() {
    "use strict";
    init_cjs_shims();
    init_errors();
  }
});

// src/cli/auth/callback-server.ts
var init_callback_server = __esm({
  "src/cli/auth/callback-server.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/cli/auth/global-auth.ts
function getAuthContext() {
  return authContext;
}
var authContext;
var init_global_auth = __esm({
  "src/cli/auth/global-auth.ts"() {
    "use strict";
    init_cjs_shims();
    init_config();
    authContext = null;
  }
});

// src/cli/auth/index.ts
var init_auth = __esm({
  "src/cli/auth/index.ts"() {
    "use strict";
    init_cjs_shims();
    init_types();
    init_config();
    init_oauth();
    init_api();
    init_callback_server();
    init_global_auth();
  }
});

// src/config/index.ts
function createPartialDefaults() {
  let token;
  let url;
  let orgId;
  try {
    const authContext2 = getAuthContext();
    if (authContext2) {
      token = authContext2.token;
      url = authContext2.url;
      orgId = authContext2.orgId;
    }
  } catch {
  }
  token = token || process.env.AXIOM_TOKEN;
  url = url || process.env.AXIOM_URL;
  orgId = orgId || process.env.AXIOM_ORG_ID;
  return {
    eval: {
      url: url || "https://api.axiom.co",
      orgId,
      token,
      dataset: process.env.AXIOM_DATASET,
      flagSchema: void 0,
      instrumentation: null,
      include: [...DEFAULT_EVAL_INCLUDE],
      exclude: [],
      timeoutMs: 6e4
    }
  };
}
function validateConfig(config) {
  const errors = [];
  const isDebug = process.env.AXIOM_DEBUG === "true";
  if (!isDebug) {
    if (!config.eval?.token) {
      errors.push(
        "eval.token is required (set in axiom.config.ts or AXIOM_TOKEN environment variable)"
      );
    }
    if (!config.eval?.dataset) {
      errors.push(
        "eval.dataset is required (set in axiom.config.ts or AXIOM_DATASET environment variable)"
      );
    }
    if (!config.eval?.url) {
      console.log(
        "eval.url was not specified. Defaulting to `https://api.axiom.co`. Please set it in axiom.config.ts or AXIOM_URL environment variable if you want to use a different endpoint."
      );
    }
  }
  const instrumentation = config.eval?.instrumentation;
  if (instrumentation !== null && instrumentation !== void 0 && typeof instrumentation !== "function") {
    errors.push(
      "eval.instrumentation must be a function returning OTEL setup information or null."
    );
  }
  if (errors.length > 0) {
    throw new AxiomCLIError(`Invalid Axiom configuration:
  - ${errors.join("\n  - ")}`);
  }
  return config;
}
var import_zod6, DEFAULT_EVAL_INCLUDE;
var init_config2 = __esm({
  "src/config/index.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod6 = require("zod");
    init_errors();
    init_auth();
    DEFAULT_EVAL_INCLUDE = ["**/*.eval.{ts,js,mts,mjs,cts,cjs}"];
  }
});

// src/config/loader.ts
function customMerger(target, source) {
  const merged = (0, import_defu.defu)(source, target);
  if (source?.eval && "include" in source.eval) {
    merged.eval.include = source.eval.include;
  }
  if (source?.eval && "flagSchema" in source.eval) {
    merged.eval.flagSchema = source.eval.flagSchema;
  }
  return merged;
}
async function loadConfig(cwd = process.cwd()) {
  try {
    const defaults = createPartialDefaults();
    const result = await (0, import_c12.loadConfig)({
      name: "axiom",
      cwd,
      // Support common config file extensions
      configFile: "axiom.config",
      // Don't use defaultConfig - we'll merge manually to control array behavior
      // Disable configs other than .ts/.js/.mts/.mjs/.cts/.cjs
      rcFile: false,
      globalRc: false,
      packageJson: false,
      giget: false
    });
    const mergedConfig = customMerger(defaults, result.config);
    const validatedConfig = validateConfig(mergedConfig);
    return {
      config: validatedConfig
    };
  } catch (error) {
    if (error instanceof AxiomCLIError) {
      throw error;
    }
    throw new AxiomCLIError(`Failed to load config file: ${errorToString(error)}`);
  }
}
var import_c12, import_defu;
var init_loader = __esm({
  "src/config/loader.ts"() {
    "use strict";
    init_cjs_shims();
    import_c12 = require("c12");
    import_defu = require("defu");
    init_config2();
    init_errors();
  }
});

// src/evals/instrument.ts
async function resolveInstrumentationHook(config) {
  if (config.eval.instrumentation) {
    return config.eval.instrumentation;
  }
  try {
    const { config: loadedConfig } = await loadConfig(process.cwd());
    return loadedConfig.eval.instrumentation ?? null;
  } catch (error) {
    throw new AxiomCLIError(
      `Failed to reload instrumentation from config: ${errorToString(error)}`
    );
  }
}
async function runInstrumentationHook(hook, options) {
  try {
    return await hook(options);
  } catch (error) {
    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);
  }
}
function setupEvalProvider(connection) {
  const headers = {
    "X-Axiom-Dataset": connection.dataset,
    ...connection.orgId ? { "X-AXIOM-ORG-ID": connection.orgId } : {}
  };
  if (connection.token) {
    headers.Authorization = `Bearer ${connection.token}`;
  }
  const collectorOptions = {
    url: `${connection.url}/v1/traces`,
    headers,
    concurrencyLimit: 10
  };
  const exporter = new import_exporter_trace_otlp_http.OTLPTraceExporter(collectorOptions);
  const processor = new import_sdk_trace_node.BatchSpanProcessor(exporter, {
    maxQueueSize: 2048,
    maxExportBatchSize: 512,
    scheduledDelayMillis: 5e3,
    exportTimeoutMillis: 3e4
  });
  axiomProvider = new import_sdk_trace_node.NodeTracerProvider({
    resource: (0, import_resources.resourceFromAttributes)({
      ["service.name"]: "axiom",
      ["service.version"]: "0.37.0"
    }),
    spanProcessors: [processor]
  });
  axiomTracer = axiomProvider.getTracer("axiom", "0.37.0");
}
async function initInstrumentation(config) {
  if (initialized) {
    return;
  }
  if (initializationPromise) {
    await initializationPromise;
    return;
  }
  initializationPromise = (async () => {
    if (!config.enabled) {
      axiomTracer = import_api10.trace.getTracer("axiom", "0.37.0");
      initialized = true;
      return;
    }
    const connection = resolveAxiomConnection(config.config);
    const hook = await resolveInstrumentationHook(config.config);
    let hookResult = void 0;
    if (hook) {
      config.config.eval.instrumentation = hook;
      hookResult = await runInstrumentationHook(hook, {
        dataset: connection.dataset,
        token: connection.token,
        url: connection.url,
        orgId: connection.orgId
      });
      userProvider = hookResult?.provider ?? userProvider;
    }
    setupEvalProvider(connection);
    if (!hook) {
      axiomProvider?.register();
      if (axiomTracer) {
        initAxiomAI({ tracer: axiomTracer });
      }
    }
    initialized = true;
  })();
  try {
    await initializationPromise;
  } finally {
    initializationPromise = null;
  }
}
async function ensureInstrumentationInitialized(config, options = {}) {
  if (initialized) {
    return;
  }
  const enabled = options.enabled ?? true;
  await initInstrumentation({ enabled, config });
}
var import_sdk_trace_node, import_resources, import_exporter_trace_otlp_http, import_api10, axiomProvider, axiomTracer, userProvider, initializationPromise, initialized, flush, getEvalTracer, startSpan, startActiveSpan;
var init_instrument = __esm({
  "src/evals/instrument.ts"() {
    "use strict";
    init_cjs_shims();
    import_sdk_trace_node = require("@opentelemetry/sdk-trace-node");
    import_resources = require("@opentelemetry/resources");
    import_exporter_trace_otlp_http = require("@opentelemetry/exporter-trace-otlp-http");
    import_api10 = require("@opentelemetry/api");
    init_initAxiomAI();
    init_resolver();
    init_errors();
    init_loader();
    initializationPromise = null;
    initialized = false;
    flush = async () => {
      if (initializationPromise) {
        await initializationPromise;
      }
      const tasks = [];
      if (axiomProvider) {
        tasks.push(axiomProvider.forceFlush());
      }
      const candidateProviders = /* @__PURE__ */ new Set();
      if (userProvider) {
        candidateProviders.add(userProvider);
      }
      const globalProvider = import_api10.trace.getTracerProvider();
      if (globalProvider) {
        candidateProviders.add(globalProvider);
      }
      for (const provider of candidateProviders) {
        const flushFn = provider.forceFlush;
        if (typeof flushFn === "function") {
          tasks.push(
            flushFn.call(provider).catch((error) => {
              console.warn("[AxiomAI] Failed to flush tracer provider:", errorToString(error));
            })
          );
        }
      }
      if (tasks.length > 0) {
        await Promise.all(tasks);
      }
    };
    getEvalTracer = () => {
      if (!axiomTracer) {
        throw new Error(
          "Eval tracer not initialized. Ensure ensureInstrumentationInitialized() was awaited before starting spans."
        );
      }
      return axiomTracer;
    };
    startSpan = (name, opts, context6) => {
      if (!initialized || !axiomTracer) {
        throw new Error(
          "Instrumentation not initialized. This is likely a bug - instrumentation should be initialized before startSpan is called."
        );
      }
      return getEvalTracer().startSpan(name, opts, context6);
    };
    startActiveSpan = async (name, options, fn, parentContext) => {
      const span = startSpan(name, options, parentContext);
      return import_api10.context.with(import_api10.trace.setSpan(import_api10.context.active(), span), async () => {
        try {
          const result = await fn(span);
          span.setStatus({ code: import_api10.SpanStatusCode.OK });
          return result;
        } catch (error) {
          span.recordException(error);
          span.setStatus({
            code: import_api10.SpanStatusCode.ERROR,
            message: error instanceof Error ? error.message : String(error)
          });
          throw error;
        } finally {
          span.end();
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
function a(n) {
  return String(n);
}
function C(n = false) {
  let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p(n = false) {
  let e = C(n), i = (r2, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r2.substring(s2, o) + c, s2 = o + t.length, o = r2.indexOf(t, s2);
    while (~o);
    return l + r2.substring(s2);
  }, g = (r2, t, c = r2) => {
    let o = (l) => {
      let s2 = String(l), b = s2.indexOf(t, r2.length);
      return ~b ? r2 + i(s2, t, c, b) + t : r2 + s2 + t;
    };
    return o.open = r2, o.close = t, o;
  }, u2 = {
    isColorSupported: e
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t] of h)
    u2[r2] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a;
  return u2;
}
var f, h;
var init_chunk_BVHSVHOK = __esm({
  "../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js"() {
    "use strict";
    init_cjs_shims();
    f = {
      reset: [0, 0],
      bold: [1, 22, "\x1B[22m\x1B[1m"],
      dim: [2, 22, "\x1B[22m\x1B[2m"],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39],
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    };
    h = Object.entries(f);
    a.open = "";
    a.close = "";
  }
});

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
var import_tty, r, u;
var init_node = __esm({
  "../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js"() {
    "use strict";
    init_cjs_shims();
    init_chunk_BVHSVHOK();
    import_tty = require("tty");
    r = process.env.FORCE_TTY !== void 0 || (0, import_tty.isatty)(1);
    u = p(r);
  }
});

// src/evals/reporter.console-utils.ts
function formatPercentage(value) {
  if (!Number.isFinite(value)) {
    return "N/A";
  }
  return Number(value * 100).toFixed(2) + "%";
}
function formatDiff(current, baseline) {
  if (!Number.isFinite(current) || !Number.isFinite(baseline)) {
    return { text: "N/A", color: u.dim };
  }
  const diff = current - baseline;
  const diffText = (diff >= 0 ? "+" : "") + formatPercentage(diff);
  const color = diff > 0 ? u.green : diff < 0 ? u.red : u.dim;
  return { text: diffText, color };
}
function truncate(str, max) {
  return str.length > max ? str.slice(0, max) + "\u2026" : str;
}
function stringify(value) {
  try {
    if (typeof value === "string") return value;
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}
function getCaseFingerprint(input, expected) {
  const inputStr = typeof input === "string" ? input : JSON.stringify(input);
  const expectedStr = typeof expected === "string" ? expected : JSON.stringify(expected);
  return JSON.stringify({ input: inputStr, expected: expectedStr });
}
function printEvalNameAndFileName(testSuite, meta, logger = console.log) {
  const cwd = process.cwd();
  logger(
    " ",
    u.bgCyan(u.black(` ${testSuite.project.name} `)),
    u.bgBlue(u.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),
    u.dim(`(${testSuite.children.size} cases)`)
  );
  logger(" ", u.dim(testSuite.module.moduleId.replace(cwd, "")));
}
function printBaselineNameAndVersion(testMeta, logger = console.log) {
  if (testMeta.evaluation.baseline) {
    logger(
      " ",
      " baseline ",
      u.bgMagenta(
        u.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `)
      )
    );
  } else {
    logger(" ", u.bgWhite(u.blackBright(" baseline: ")), "none");
  }
  logger("");
}
function printRuntimeFlags(testMeta, logger = console.log) {
  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {
    const entries = Object.entries(testMeta.case.runtimeFlags);
    logger("   ", u.dim("runtime flags"));
    for (const [k, v] of entries) {
      switch (v.kind) {
        case "replaced": {
          const valText = truncate(stringify(v.value), 80);
          const defText = truncate(stringify(v.default), 80);
          logger("     ", `${k}: ${valText} (default: ${defText})`);
          break;
        }
        case "introduced": {
          const valText = truncate(stringify(v.value), 80);
          logger("     ", `${k}: ${valText} (no default)`);
          break;
        }
      }
    }
  }
}
function printTestCaseCountStartDuration(testSuite, startTime, duration, logger = console.log) {
  logger(" ");
  logger(" ", u.dim("Cases"), testSuite.children.size);
  logger(" ", u.dim("Start at"), new Date(startTime).toTimeString());
  logger(" ", u.dim("Duration"), `${duration}s`);
}
function printTestCaseSuccessOrFailed(testMeta, ok, logger = console.log) {
  const index = testMeta.case.index;
  if (ok) {
    logger(" ", u.yellow(` \u2714 case ${index}:`));
  } else {
    logger(" ", u.red(` \u2716 case ${index}: failed`));
    for (const e of testMeta.case.errors ?? []) {
      logger("", e.message);
    }
  }
}
function printTestCaseScores(testMeta, baselineCase, logger = console.log) {
  const scores = testMeta.case.scores;
  const keys = Object.keys(scores);
  if (keys.length === 0) {
    return;
  }
  const maxNameLength = Math.max(...keys.map((k) => k.length));
  keys.forEach((k) => {
    const scoreData = scores[k];
    const hasError = scoreData.metadata?.error;
    const v = scoreData.score ? scoreData.score : 0;
    const rawCurrent = hasError ? "N/A" : formatPercentage(v);
    const paddedCurrent = rawCurrent.padStart(7);
    const coloredCurrent = hasError ? u.dim(paddedCurrent) : u.magentaBright(paddedCurrent);
    const paddedName = k.padEnd(maxNameLength);
    if (baselineCase?.scores[k]) {
      const baselineScoreValue = baselineCase.scores[k].value;
      const rawBaseline = formatPercentage(baselineScoreValue);
      const paddedBaseline = rawBaseline.padStart(7);
      const coloredBaseline = u.blueBright(paddedBaseline);
      const { text: diffText, color: diffColor } = formatDiff(v, baselineScoreValue);
      const paddedDiff = diffText.padStart(8);
      logger(
        `    ${paddedName}  ${coloredBaseline} \u2192 ${coloredCurrent}  ${hasError ? u.dim("(scorer not run)") : u.dim("(") + diffColor(paddedDiff) + u.dim(")")}`
      );
    } else {
      logger(`    ${paddedName}  ${coloredCurrent} ${hasError ? u.dim("(scorer not run)") : ""}`);
    }
  });
}
function printOutOfScopeFlags(testMeta, logger = console.log) {
  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {
    const pickedFlagsText = testMeta.case.pickedFlags ? `(picked: ${testMeta.case.pickedFlags.map((f2) => `'${f2}'`).join(", ")})` : "(none)";
    logger("   ", u.yellow(`\u26A0 Out-of-scope flags: ${pickedFlagsText}`));
    testMeta.case.outOfScopeFlags.forEach((flag) => {
      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();
      logger("     ", `${flag.flagPath} (at ${timeStr})`);
      if (flag.stackTrace && flag.stackTrace.length > 0) {
        flag.stackTrace.forEach((frame, i) => {
          const prefix = i === flag.stackTrace.length - 1 ? " \u2514\u2500" : " \u251C\u2500";
          logger("     ", u.dim(`${prefix} ${frame}`));
        });
      }
    });
  }
}
function printCaseResult(test, baselineCasesByFingerprint, matchedIndices, logger = console.log) {
  const ok = test.ok();
  const testMeta = test.meta();
  if (!testMeta?.case) {
    return;
  }
  printTestCaseSuccessOrFailed(testMeta, ok, logger);
  const fingerprint = getCaseFingerprint(testMeta.case.input, testMeta.case.expected);
  const baselineCases = baselineCasesByFingerprint.get(fingerprint);
  const baselineCase = baselineCases?.shift();
  if (baselineCase) {
    matchedIndices.add(baselineCase.index);
  }
  printTestCaseScores(testMeta, baselineCase, logger);
  printRuntimeFlags(testMeta, logger);
  printOutOfScopeFlags(testMeta, logger);
}
function printOrphanedBaselineCases(baseline, matchedIndices, logger = console.log) {
  const orphanedCases = baseline.cases.filter((c) => !matchedIndices.has(c.index));
  if (orphanedCases.length === 0) {
    return;
  }
  logger("");
  logger(" ", u.yellow("Orphaned baseline cases:"));
  for (const orphanedCase of orphanedCases) {
    logger(
      " ",
      u.dim(
        `case ${orphanedCase.index}: ${truncate(orphanedCase.input, 50)} (score: ${truncate(
          JSON.stringify(orphanedCase.scores),
          50
        )})`
      )
    );
    const keys = Object.keys(orphanedCase.scores);
    if (keys.length > 0) {
      const maxNameLength = Math.max(...keys.map((k) => k.length));
      keys.forEach((k) => {
        const scoreData = orphanedCase.scores[k];
        const rawScore = formatPercentage(scoreData.value);
        const paddedName = k.padEnd(maxNameLength);
        const paddedScore = rawScore.padStart(7);
        logger(`    ${paddedName}  ${u.blueBright(paddedScore)}`);
      });
    }
  }
}
function printGlobalFlagOverrides(overrides, defaults, logger = console.log) {
  if (Object.keys(overrides).length === 0) {
    logger("");
    logger(u.dim("Flag overrides: (none)"));
    logger("");
    return;
  }
  logger("");
  logger("Flag overrides:");
  for (const [key, value] of Object.entries(overrides)) {
    const defaultValue = defaults[key];
    const valueStr = JSON.stringify(value);
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : "none";
    logger(`  \u2022 ${key}: ${valueStr} ${u.dim(`(default: ${defaultStr})`)}`);
  }
  logger("");
}
function printSuiteBox({
  suite,
  scorerAverages,
  calculateBaselineScorerAverage: calculateBaselineScorerAverage2,
  flagDiff,
  logger = console.log
}) {
  const filename = suite.file.split("/").pop();
  logger("\u250C\u2500");
  logger(`\u2502  ${u.blue(suite.name)} ${u.gray(`(${filename})`)}`);
  logger("\u251C\u2500");
  const scorerNames = Object.keys(scorerAverages);
  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));
  const allCasesErrored = (scorerName) => {
    return suite.cases.every((caseData) => caseData.scores[scorerName]?.metadata?.error);
  };
  for (const scorerName of scorerNames) {
    const avg = scorerAverages[scorerName];
    const paddedName = scorerName.padEnd(maxNameLength);
    const hasAllErrors = allCasesErrored(scorerName);
    const baselineAvg = suite.baseline ? calculateBaselineScorerAverage2(suite.baseline, scorerName) : null;
    if (baselineAvg !== null) {
      const currentPercent = hasAllErrors ? u.dim("N/A") : formatPercentage(avg);
      const baselinePercent = formatPercentage(baselineAvg);
      const { text: diffText, color: diffColor } = formatDiff(avg, baselineAvg);
      const paddedBaseline = baselinePercent.padStart(7);
      const paddedCurrent = hasAllErrors ? currentPercent : currentPercent.padStart(7);
      const diffDisplay = hasAllErrors ? u.dim("all cases failed") : diffColor(diffText.padStart(8));
      logger(
        `\u2502  ${paddedName}  ${u.blueBright(paddedBaseline)} \u2192 ${hasAllErrors ? paddedCurrent : u.magentaBright(paddedCurrent)}  (${diffDisplay})`
      );
    } else {
      const currentPercent = hasAllErrors ? u.red("N/A (all cases failed)") : formatPercentage(avg);
      logger(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
    }
  }
  logger("\u251C\u2500");
  if (suite.baseline) {
    const baselineTimestamp = suite.baseline.runAt ? reporterDate(new Date(suite.baseline.runAt)) : "unknown time";
    logger(
      `\u2502  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${u.gray(`(${baselineTimestamp})`)}`
    );
  } else {
    logger(`\u2502  Baseline: ${u.gray("(none)")}`);
  }
  const hasConfigChanges = flagDiff.length > 0;
  logger("\u2502  Config changes:", hasConfigChanges ? "" : u.gray("(none)"));
  if (hasConfigChanges) {
    for (const { flag, current, baseline, default: defaultVal } of flagDiff) {
      logger(`\u2502   \u2022 ${flag}: ${current ?? "<not set>"}`);
      if (defaultVal !== void 0) {
        logger(`\u2502       ${u.gray(`default: ${defaultVal}`)}`);
      }
      if (suite.baseline) {
        logger(`\u2502       ${u.gray(`baseline: ${baseline ?? "<not set>"}`)}`);
      }
    }
  }
  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {
    const pickedFlagsText = suite.configFlags && suite.configFlags.length > 0 ? suite.configFlags.map((f2) => `'${f2}'`).join(", ") : "none";
    logger("\u2502");
    logger(`\u2502  ${u.yellow("\u26A0 Out-of-scope flags")} ${u.gray(`(picked: ${pickedFlagsText})`)}:`);
    for (const flag of suite.outOfScopeFlags) {
      const lastStackTraceFrame = flag.stackTrace[0];
      const lastStackTraceFnName = lastStackTraceFrame.split(" ").shift();
      const lastStackTraceFile = lastStackTraceFrame.split("/").pop()?.slice(0, -1);
      logger(
        `\u2502   \u2022 ${flag.flagPath} ${u.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`
      );
    }
  }
  logger("\u2514\u2500");
}
function calculateScorerAverages(suite) {
  const scorerTotals = {};
  for (const caseData of suite.cases) {
    for (const [scorerName, score] of Object.entries(caseData.scores)) {
      if (!scorerTotals[scorerName]) {
        scorerTotals[scorerName] = { sum: 0, count: 0 };
      }
      if (!score.metadata?.error) {
        scorerTotals[scorerName].sum += score.score || 0;
        scorerTotals[scorerName].count += 1;
      }
    }
  }
  const averages = {};
  for (const [scorerName, totals] of Object.entries(scorerTotals)) {
    averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;
  }
  return averages;
}
function calculateBaselineScorerAverage(baseline, scorerName) {
  const scores = [];
  for (const caseData of baseline.cases) {
    if (caseData.scores[scorerName]) {
      scores.push(caseData.scores[scorerName].value);
    }
  }
  if (scores.length === 0) return null;
  const sum = scores.reduce((acc, val) => acc + val, 0);
  return sum / scores.length;
}
function calculateFlagDiff(suite) {
  if (!suite.configFlags || suite.configFlags.length === 0) {
    return [];
  }
  const diffs = [];
  const currentConfig = suite.flagConfig || {};
  const baselineConfig = suite.baseline?.flagConfig || {};
  const defaultConfig = suite.defaultFlagConfig || {};
  const currentFlat = flattenObject(currentConfig);
  const baselineFlat = flattenObject(baselineConfig);
  const defaultFlat = flattenObject(defaultConfig);
  const allKeys = /* @__PURE__ */ new Set([
    ...Object.keys(currentFlat),
    ...Object.keys(baselineFlat),
    ...Object.keys(defaultFlat)
  ]);
  for (const key of allKeys) {
    const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));
    if (!isInScope) continue;
    const currentValue = currentFlat[key];
    const baselineValue = baselineFlat[key];
    const defaultValue = defaultFlat[key];
    const currentStr = currentValue !== void 0 ? JSON.stringify(currentValue) : void 0;
    const baselineStr = baselineValue !== void 0 ? JSON.stringify(baselineValue) : void 0;
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : void 0;
    const diffFromBaseline = suite.baseline && currentStr !== baselineStr;
    const diffFromDefault = currentStr !== defaultStr;
    if (diffFromBaseline || diffFromDefault) {
      diffs.push({
        flag: key,
        current: currentStr,
        baseline: suite.baseline ? baselineStr : void 0,
        default: defaultStr
      });
    }
  }
  return diffs;
}
function printFinalReport({
  suiteData,
  config,
  registrationStatus,
  isDebug,
  logger = console.log
}) {
  logger("");
  logger(u.bgBlue(u.white(" FINAL EVALUATION REPORT ")));
  logger("");
  for (const suite of suiteData) {
    const scorerAverages = calculateScorerAverages(suite);
    const flagDiff = calculateFlagDiff(suite);
    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff, logger });
    logger("");
  }
  const runId = suiteData[0]?.runId;
  const orgId = suiteData[0]?.orgId;
  const anyRegistered = registrationStatus.some((s2) => s2.registered);
  const anyFailed = registrationStatus.some((s2) => !s2.registered);
  if (anyRegistered && orgId && config?.consoleEndpointUrl) {
    if (suiteData.length === 1) {
      const suite = suiteData[0];
      const baselineParam = suite.baseline?.traceId ? `?baselineId=${suite.baseline.traceId}` : "";
      logger("View eval result:");
      logger(
        `${config.consoleEndpointUrl}/${orgId}/ai-engineering/evaluations/${suite.name}/${suite.version}${baselineParam}`
      );
    } else {
      logger("View full report:");
      logger(`${config.consoleEndpointUrl}/${orgId}/ai-engineering/evaluations?runId=${runId}`);
    }
  } else if (isDebug) {
    logger(u.dim("Results not uploaded to Axiom (debug mode)"));
  } else {
    logger("Results not available in Axiom UI (registration failed)");
  }
  if (anyFailed) {
    logger("");
    for (const status of registrationStatus) {
      if (!status.registered) {
        logger(u.yellow(`\u26A0\uFE0F  Warning: Failed to register "${status.name}" with Axiom`));
        if (status.error) {
          logger(u.dim(`   Error: ${status.error}`));
        }
        logger(u.dim(`   Results for this evaluation will not be available in the Axiom UI.`));
      }
    }
  }
}
var reporterDate;
var init_reporter_console_utils = __esm({
  "src/evals/reporter.console-utils.ts"() {
    "use strict";
    init_cjs_shims();
    init_node();
    init_dot_path();
    reporterDate = (d) => {
      const date = d.toISOString().slice(0, 10);
      const hours = d.getUTCHours().toString().padStart(2, "0");
      const minutes = d.getUTCMinutes().toString().padStart(2, "0");
      return `${date}, ${hours}:${minutes} UTC`;
    };
  }
});

// src/context.ts
var init_context = __esm({
  "src/context.ts"() {
    "use strict";
    init_cjs_shims();
    init_storage();
  }
});

// src/cli/utils/eval-context-runner.ts
var init_eval_context_runner = __esm({
  "src/cli/utils/eval-context-runner.ts"() {
    "use strict";
    init_cjs_shims();
    init_context();
    init_storage();
    init_global_flags();
  }
});

// src/cli/utils/parse-flag-overrides.ts
var import_zod7, import_node_fs2, import_node_path;
var init_parse_flag_overrides = __esm({
  "src/cli/utils/parse-flag-overrides.ts"() {
    "use strict";
    init_cjs_shims();
    import_zod7 = require("zod");
    init_format_zod_errors();
    import_node_fs2 = require("fs");
    import_node_path = require("path");
    init_dot_path();
    init_deep_partial_schema();
    init_zod_internals();
  }
});

// src/cli/utils/glob-utils.ts
var init_glob_utils = __esm({
  "src/cli/utils/glob-utils.ts"() {
    "use strict";
    init_cjs_shims();
  }
});

// src/cli/commands/eval.command.ts
function getConsoleUrl() {
  return consoleUrl;
}
var import_commander, import_nanoid2, import_node_fs3, createRunId, consoleUrl;
var init_eval_command = __esm({
  "src/cli/commands/eval.command.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander = require("commander");
    import_nanoid2 = require("nanoid");
    import_node_fs3 = require("fs");
    init_eval_context_runner();
    init_parse_flag_overrides();
    init_glob_utils();
    init_loader();
    init_errors();
    init_global_auth();
    init_node();
    createRunId = (0, import_nanoid2.customAlphabet)("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 10);
  }
});

// src/evals/reporter.ts
var AxiomReporter;
var init_reporter = __esm({
  "src/evals/reporter.ts"() {
    "use strict";
    init_cjs_shims();
    init_storage();
    init_reporter_console_utils();
    init_resolver();
    init_eval_command();
    init_dot_path();
    AxiomReporter = class {
      constructor() {
        __publicField(this, "startTime", 0);
        __publicField(this, "start", 0);
        __publicField(this, "_endOfRunConfigEnd");
        __publicField(this, "_suiteData", []);
        __publicField(this, "_printedFlagOverrides", false);
        __publicField(this, "_config");
      }
      onTestRunStart() {
        this.start = performance.now();
        this.startTime = (/* @__PURE__ */ new Date()).getTime();
        const config = getAxiomConfig();
        if (config) {
          this._config = resolveAxiomConnection(config, getConsoleUrl());
        }
      }
      async onTestSuiteReady(_testSuite) {
        const meta = _testSuite.meta();
        if (_testSuite.state() === "skipped" || !meta?.evaluation) {
          return;
        }
        if (!this._printedFlagOverrides) {
          const defaultsFromConfigEnd = meta.evaluation.configEnd?.flags ?? {};
          const overridesFromConfigEnd = meta.evaluation.configEnd?.overrides ?? {};
          if (Object.keys(overridesFromConfigEnd).length > 0) {
            printGlobalFlagOverrides(overridesFromConfigEnd, defaultsFromConfigEnd);
          }
          this._printedFlagOverrides = true;
        }
        if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
          this._endOfRunConfigEnd = meta.evaluation.configEnd;
        }
      }
      onTestCaseReady(test) {
        const meta = test.meta();
        if (!meta.case) return;
      }
      async onTestSuiteResult(testSuite) {
        const meta = testSuite.meta();
        if (testSuite.state() === "skipped" || !meta?.evaluation) {
          return;
        }
        if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
          this._endOfRunConfigEnd = meta.evaluation.configEnd;
        }
        const durationSeconds = Number((performance.now() - this.start) / 1e3).toFixed(2);
        const cases = [];
        for (const test of testSuite.children) {
          if (test.type !== "test") continue;
          const testMeta = test.meta();
          if (!testMeta?.case) continue;
          cases.push({
            index: testMeta.case.index,
            scores: testMeta.case.scores,
            outOfScopeFlags: testMeta.case.outOfScopeFlags,
            errors: testMeta.case.errors,
            runtimeFlags: testMeta.case.runtimeFlags
          });
        }
        const cwd = process.cwd();
        const relativePath = testSuite.module.moduleId.replace(cwd, "").replace(/^\//, "");
        let suiteBaseline = meta.evaluation.baseline;
        let flagConfig = meta.evaluation.flagConfig;
        if (meta.evaluation.configEnd) {
          const defaults = meta.evaluation.configEnd.flags ?? {};
          const overrides = meta.evaluation.configEnd.overrides ?? {};
          const defaultsFlat = flattenObject(defaults);
          const overridesFlat = flattenObject(overrides);
          flagConfig = dotNotationToNested({ ...defaultsFlat, ...overridesFlat });
        }
        const defaultFlagConfig = meta.evaluation.configEnd?.flags;
        this._suiteData.push({
          version: meta.evaluation.version,
          name: meta.evaluation.name,
          file: relativePath,
          duration: durationSeconds + "s",
          baseline: suiteBaseline || null,
          configFlags: meta.evaluation.configFlags,
          flagConfig,
          defaultFlagConfig,
          runId: meta.evaluation.runId,
          orgId: meta.evaluation.orgId,
          cases,
          outOfScopeFlags: meta.evaluation.outOfScopeFlags,
          registrationStatus: meta.evaluation.registrationStatus
        });
        printEvalNameAndFileName(testSuite, meta);
        printBaselineNameAndVersion(meta);
        printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);
        const matchedBaselineIndices = /* @__PURE__ */ new Set();
        const baselineCasesByFingerprint = /* @__PURE__ */ new Map();
        if (suiteBaseline) {
          for (const c of suiteBaseline.cases) {
            const fp = getCaseFingerprint(c.input, c.expected);
            const cases2 = baselineCasesByFingerprint.get(fp) || [];
            cases2.push(c);
            baselineCasesByFingerprint.set(fp, cases2);
          }
        }
        for (const test of testSuite.children) {
          if (test.type !== "test") continue;
          printCaseResult(test, baselineCasesByFingerprint, matchedBaselineIndices);
        }
        if (suiteBaseline) {
          printOrphanedBaselineCases(suiteBaseline, matchedBaselineIndices);
        }
        console.log("");
      }
      async onTestRunEnd(_testModules, _errors, _reason) {
        const shouldClear = !process.env.CI && process.stdout.isTTY !== false;
        if (shouldClear) {
          process.stdout.write("\x1B[2J\x1B[0f");
        }
        const registrationStatus = this._suiteData.map((suite) => ({
          name: suite.name,
          registered: suite.registrationStatus?.status === "success",
          error: suite.registrationStatus?.status === "failed" ? suite.registrationStatus.error : void 0
        }));
        const isDebug = process.env.AXIOM_DEBUG === "true";
        printFinalReport({
          suiteData: this._suiteData,
          config: this._config,
          registrationStatus,
          isDebug
        });
      }
    };
  }
});

// src/evals.ts
var evals_exports = {};
__export(evals_exports, {
  AxiomReporter: () => AxiomReporter,
  Eval: () => Eval,
  Scorer: () => createScorer
});
module.exports = __toCommonJS(evals_exports);
init_cjs_shims();

// src/evals/eval.ts
init_cjs_shims();
var import_vitest = require("vitest");
var import_api11 = require("@opentelemetry/api");
var import_nanoid = require("nanoid");
init_storage();
init_attributes();
init_instrument();

// src/evals/git-info.ts
init_cjs_shims();
var import_node_child_process = require("child_process");
function getGitUserInfo() {
  try {
    const name = (0, import_node_child_process.execSync)("git config --get user.name").toString().trim();
    const email = (0, import_node_child_process.execSync)("git config --get user.email").toString().trim();
    return { name, email };
  } catch {
    return null;
  }
}

// src/evals/eval.service.ts
init_cjs_shims();

// src/utils/fetcher.ts
init_cjs_shims();
var createFetcher = ({
  baseUrl,
  token,
  orgId
}) => {
  return (path, options) => fetch(new URL(path, baseUrl).toString(), {
    ...options,
    headers: {
      ...options.headers,
      "content-type": "application/json",
      authorization: `Bearer ${token}`,
      ...orgId ? { "X-AXIOM-ORG-ID": orgId } : {}
    }
  });
};

// src/evals/eval.service.ts
init_resolver();
init_otel();
init_errors();

// src/util/traces.ts
init_cjs_shims();
function getCustomOrRegularAttribute(obj, accessKey) {
  if (typeof obj !== "object" || obj === null) {
    return void 0;
  }
  const keyParts = accessKey.split(".");
  const custom = obj.custom;
  if (custom && typeof custom === "object" && custom !== null && accessKey in custom) {
    return custom[accessKey];
  }
  let current = obj;
  for (const part of keyParts) {
    if (typeof current !== "object" || current === null) {
      return void 0;
    }
    current = current[part];
  }
  return current;
}
function getCustomOrRegularString(obj, key) {
  const value = getCustomOrRegularAttribute(obj, key);
  return typeof value === "string" ? value : void 0;
}
function getCustomOrRegularNumber(obj, key) {
  const value = getCustomOrRegularAttribute(obj, key);
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const parsed = Number(value);
    return Number.isNaN(parsed) ? void 0 : parsed;
  }
  return void 0;
}

// src/evals/eval.service.ts
var EvaluationApiClient = class {
  constructor(config, consoleUrl2) {
    __publicField(this, "fetcher");
    const { consoleEndpointUrl, token, orgId } = resolveAxiomConnection(config, consoleUrl2);
    this.fetcher = createFetcher({ baseUrl: consoleEndpointUrl, token: token ?? "", orgId });
  }
  async createEvaluation(evaluation) {
    const resp = await this.fetcher(`/api/v3/evaluations`, {
      method: "POST",
      body: JSON.stringify(evaluation)
    });
    if (!resp.ok) {
      throw new AxiomCLIError(`Failed to create evaluation: ${resp.statusText}`);
    }
    return resp.json();
  }
  async updateEvaluation(evaluation) {
    const resp = await this.fetcher(`/api/v3/evaluations/${evaluation.id}`, {
      method: "PATCH",
      body: JSON.stringify(evaluation)
    });
    if (!resp.ok) {
      throw new AxiomCLIError(`Failed to update evaluation: ${resp.statusText}`);
    }
    return resp.json();
  }
};
var findEvaluationCases = async (evalId, config) => {
  const { dataset, url, token, orgId } = resolveAxiomConnection(config);
  const apl = `['${dataset}'] | where trace_id == "${evalId}" | order by _time`;
  const headers = new Headers({
    Authorization: `Bearer ${token}`,
    "Content-Type": "application/json",
    ...orgId ? { "X-AXIOM-ORG-ID": orgId } : {}
  });
  const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {
    headers,
    method: "POST",
    body: JSON.stringify({ apl })
  });
  const payload = await resp.json();
  if (!resp.ok) {
    throw new Error(`Failed to query evaluation cases: ${payload.message || resp.statusText}`);
  }
  return payload.matches.length ? buildSpanTree(payload.matches) : null;
};
var mapSpanToEval = (span) => {
  const flagConfigRaw = getCustomOrRegularAttribute(span.data.attributes, Attr.Eval.Config.Flags);
  const tagsRaw = getCustomOrRegularAttribute(span.data.attributes, Attr.Eval.Tags);
  const evaluation = {
    id: getCustomOrRegularString(span.data.attributes, Attr.Eval.ID),
    name: getCustomOrRegularString(span.data.attributes, Attr.Eval.Name),
    type: getCustomOrRegularString(span.data.attributes, Attr.Eval.Type),
    version: getCustomOrRegularString(span.data.attributes, Attr.Eval.Version),
    collection: {
      name: getCustomOrRegularString(span.data.attributes, Attr.Eval.Collection.Name),
      size: getCustomOrRegularNumber(span.data.attributes, Attr.Eval.Collection.Size)
    },
    baseline: {
      id: getCustomOrRegularString(span.data.attributes, Attr.Eval.Baseline.ID),
      name: getCustomOrRegularString(span.data.attributes, Attr.Eval.Baseline.Name)
    },
    duration: span.data.duration,
    status: span.data.status.code,
    traceId: span.data.trace_id,
    runAt: span._time,
    tags: tagsRaw ? typeof tagsRaw === "string" ? JSON.parse(tagsRaw) : tagsRaw : [],
    user: {
      name: getCustomOrRegularString(span.data.attributes, Attr.Eval.User.Name),
      email: getCustomOrRegularString(span.data.attributes, Attr.Eval.User.Email)
    },
    cases: [],
    flagConfig: flagConfigRaw ? typeof flagConfigRaw === "string" ? JSON.parse(flagConfigRaw) : flagConfigRaw : void 0
  };
  return evaluation;
};
var mapSpanToCase = (item) => {
  const data = item.data;
  const d = data.duration;
  let duration = "-";
  if (d.endsWith("s")) {
    duration = `${Number(d.replace("s", "")).toFixed(2)}s`;
  } else {
    duration = d;
  }
  const scores = getCustomOrRegularAttribute(data.attributes, Attr.Eval.Case.Scores);
  const caseData = {
    index: getCustomOrRegularNumber(data.attributes, Attr.Eval.Case.Index),
    input: getCustomOrRegularString(data.attributes, Attr.Eval.Case.Input),
    output: getCustomOrRegularString(data.attributes, Attr.Eval.Case.Output),
    expected: getCustomOrRegularString(data.attributes, Attr.Eval.Case.Expected),
    duration,
    status: data.status.code,
    scores: scores ? typeof scores === "string" ? JSON.parse(scores) : scores : {},
    // undefined would be more honest, but this lets us do like `baseline.scores[name]` without crashing
    runAt: item._time,
    spanId: data.span_id,
    traceId: data.trace_id
  };
  return caseData;
};
var buildSpanTree = (spans) => {
  if (!spans.length) {
    return null;
  }
  const evalSpan = spans.find((span) => span.data.attributes.gen_ai.operation.name === "eval");
  if (!evalSpan) {
    return null;
  }
  const rootSpan = mapSpanToEval(evalSpan);
  const caseSpans = spans.filter((span) => span.data.name.startsWith("case"));
  for (const caseSpan of caseSpans) {
    const caseData = mapSpanToCase(caseSpan);
    const taskSpans = spans.filter(
      (span) => span.data.name.startsWith("task") && span.data.parent_span_id === caseSpan.data.span_id
    );
    if (taskSpans.length > 0) {
      const taskSpan = taskSpans[0];
      const chatSpans = spans.filter(
        (span) => span.data.name.startsWith("chat") && span.data.parent_span_id === taskSpan.data.span_id
      );
      const chatData = chatSpans.map((chatSpan) => ({
        operation: getCustomOrRegularString(chatSpan.data.attributes, "operation") ?? "",
        capability: getCustomOrRegularString(chatSpan.data.attributes, "capability") ?? "",
        step: getCustomOrRegularString(chatSpan.data.attributes, "step") ?? "",
        request: {
          max_token: getCustomOrRegularString(chatSpan.data.attributes, "request.max_token") ?? "",
          model: getCustomOrRegularString(chatSpan.data.attributes, "request.model") ?? "",
          temperature: getCustomOrRegularNumber(chatSpan.data.attributes, "request.temperature") ?? 0
        },
        response: {
          finish_reasons: getCustomOrRegularString(chatSpan.data.attributes, "response.finish_reasons") ?? ""
        },
        usage: {
          input_tokens: getCustomOrRegularNumber(chatSpan.data.attributes, "usage.input_tokens") ?? 0,
          output_tokens: getCustomOrRegularNumber(chatSpan.data.attributes, "usage.output_tokens") ?? 0
        }
      }));
      const taskData = {
        name: taskSpan.data.name,
        output: getCustomOrRegularString(taskSpan.data.attributes, "output") || "",
        trial: getCustomOrRegularNumber(taskSpan.data.attributes, "trial") || 0,
        type: getCustomOrRegularString(taskSpan.data.attributes, "type") || "",
        error: getCustomOrRegularString(taskSpan.data.attributes, "error") || "",
        chat: chatData[0] || {
          operation: "",
          capability: "",
          step: "",
          request: { max_token: "", model: "", temperature: 0 },
          response: { finish_reasons: "" },
          usage: { input_tokens: 0, output_tokens: 0 }
        }
      };
      caseData.task = taskData;
    }
    const scoreSpans = spans.filter(
      (span) => span.data.attributes.gen_ai.operation.name === "eval.score" && span.data.parent_span_id === caseSpan.data.span_id
    );
    if (scoreSpans.length > 0) {
      caseData.scores = {};
      scoreSpans.forEach((score) => {
        const name = getCustomOrRegularString(score.data.attributes, Attr.Eval.Score.Name) ?? "";
        const value = getCustomOrRegularNumber(score.data.attributes, Attr.Eval.Score.Value) ?? 0;
        const metadataRaw = getCustomOrRegularString(
          score.data.attributes,
          Attr.Eval.Score.Metadata
        );
        let metadata = {};
        try {
          metadata = metadataRaw ? JSON.parse(metadataRaw) : {};
        } catch {
        }
        caseData.scores[name] = {
          name,
          value,
          metadata: {
            error: score.data.attributes.error,
            ...metadata
          }
        };
      });
    }
    rootSpan.cases.push(caseData);
  }
  rootSpan.cases.sort((a2, b) => a2.index - b.index);
  return rootSpan;
};

// src/evals/eval.ts
init_global_flags();

// src/util/deep-equal.ts
init_cjs_shims();
function deepEqual(data, other) {
  if (data === other) {
    return true;
  }
  if (Object.is(data, other)) {
    return true;
  }
  if (typeof data !== "object" || typeof other !== "object") {
    return false;
  }
  if (data === null || other === null) {
    return false;
  }
  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {
    return false;
  }
  if (Array.isArray(data)) {
    return isDeepEqualArrays(data, other);
  }
  if (data instanceof Map) {
    return isDeepEqualMaps(data, other);
  }
  if (data instanceof Set) {
    return isDeepEqualSets(data, other);
  }
  if (data instanceof Date) {
    return data.getTime() === other.getTime();
  }
  if (data instanceof RegExp) {
    return data.toString() === other.toString();
  }
  if (Object.keys(data).length !== Object.keys(other).length) {
    return false;
  }
  for (const [key, value] of Object.entries(data)) {
    if (!(key in other)) {
      return false;
    }
    if (!deepEqual(
      value,
      // @ts-expect-error [ts7053] - We already checked that `other` has `key`
      other[key]
    )) {
      return false;
    }
  }
  return true;
}
function isDeepEqualArrays(data, other) {
  if (data.length !== other.length) {
    return false;
  }
  for (const [index, item] of data.entries()) {
    if (!deepEqual(item, other[index])) {
      return false;
    }
  }
  return true;
}
function isDeepEqualMaps(data, other) {
  if (data.size !== other.size) {
    return false;
  }
  for (const [key, value] of data.entries()) {
    if (!other.has(key)) {
      return false;
    }
    if (!deepEqual(value, other.get(key))) {
      return false;
    }
  }
  return true;
}
function isDeepEqualSets(data, other) {
  if (data.size !== other.size) {
    return false;
  }
  const otherCopy = [...other];
  for (const dataItem of data) {
    let isFound = false;
    for (const [index, otherItem] of otherCopy.entries()) {
      if (deepEqual(dataItem, otherItem)) {
        isFound = true;
        otherCopy.splice(index, 1);
        break;
      }
    }
    if (!isFound) {
      return false;
    }
  }
  return true;
}

// src/evals/eval.ts
init_dot_path();
init_errors();

// src/evals/name-validation-runtime.ts
init_cjs_shims();
init_errors();
var import_node_fs = require("fs");
init_name_validation_runtime();
function recordName(kind, name) {
  const registryFile = process.env.AXIOM_NAME_REGISTRY_FILE;
  if (registryFile) {
    try {
      (0, import_node_fs.appendFileSync)(registryFile, JSON.stringify({ kind, name }) + "\n", "utf8");
    } catch {
    }
  }
}

// src/evals/eval.ts
var createVersionId = (0, import_nanoid.customAlphabet)("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 10);
function Eval(name, params) {
  recordName("eval", name);
  recordName("capability", params.capability);
  if (params.step) {
    recordName("step", params.step);
  }
  if (params.scorers) {
    for (const scorer of params.scorers) {
      const scorerName = getScorerName(scorer, "");
      recordName("scorer", scorerName);
    }
  }
  registerEval(name, params).catch(console.error);
}
function captureFlagConfig(configFlags) {
  if (!configFlags || configFlags.length === 0) {
    return {};
  }
  const scope = getConfigScope();
  const allDefaults = scope?.getAllDefaultFlags?.() ?? {};
  const overrides = getGlobalFlagOverrides();
  const merged = { ...allDefaults, ...overrides };
  const filtered = {};
  for (const [key, value] of Object.entries(merged)) {
    const isInScope = configFlags.some((pattern) => key.startsWith(pattern));
    if (isInScope) {
      filtered[key] = value;
    }
  }
  return dotNotationToNested(filtered);
}
var getScorerName = (scorer, fallback = "unknown") => {
  return scorer.name || fallback;
};
async function registerEval(evalName, opts) {
  opts.data;
  const collectionPromise = typeof opts.data === "function" ? opts.data() : opts.data;
  const user = getGitUserInfo();
  const baselineId = (0, import_vitest.inject)("baseline");
  const isDebug = (0, import_vitest.inject)("debug");
  const isList = (0, import_vitest.inject)("list");
  const injectedOverrides = (0, import_vitest.inject)("overrides");
  const axiomConfig = (0, import_vitest.inject)("axiomConfig");
  const runId = (0, import_vitest.inject)("runId");
  const consoleUrl2 = (0, import_vitest.inject)("consoleUrl");
  if (!axiomConfig) {
    throw new AxiomCLIError("Axiom config not found");
  }
  const timeoutMs = opts.timeout ?? axiomConfig?.eval.timeoutMs;
  const instrumentationReady = ensureInstrumentationInitialized(axiomConfig, {
    enabled: !isDebug && !isList
  });
  const result = await (0, import_vitest.describe)(
    evalName,
    async () => {
      const collection = await collectionPromise;
      const evaluationApiClient = new EvaluationApiClient(axiomConfig, consoleUrl2);
      const evalVersion = createVersionId();
      let evalId = "";
      let suiteStart;
      let suiteSpan;
      let suiteContext;
      let instrumentationError = void 0;
      let baseline = void 0;
      const allOutOfScopeFlags = [];
      let finalConfigSnapshot;
      (0, import_vitest.beforeAll)(async (suite) => {
        if (injectedOverrides && Object.keys(injectedOverrides).length > 0) {
          try {
            setGlobalFlagOverrides(injectedOverrides);
          } catch {
          }
        }
        suite.meta.evaluation = {
          id: evalId,
          name: evalName,
          version: evalVersion,
          runId,
          orgId: void 0,
          baseline: baseline ?? void 0,
          configFlags: opts.configFlags
        };
        try {
          await instrumentationReady;
        } catch (error) {
          instrumentationError = error;
        }
        suiteSpan = startSpan(`eval ${evalName}-${evalVersion}`, {
          attributes: {
            [Attr.GenAI.Operation.Name]: "eval",
            [Attr.Eval.Name]: evalName,
            [Attr.Eval.Version]: evalVersion,
            [Attr.Eval.Type]: "regression",
            // TODO: where to get experiment type value from?
            [Attr.Eval.Tags]: [],
            [Attr.Eval.Collection.ID]: "custom",
            // TODO: where to get collection split value from?
            [Attr.Eval.Collection.Name]: "custom",
            // TODO: where to get collection name from?
            [Attr.Eval.Collection.Size]: collection.length,
            // capability
            [Attr.Eval.Capability.Name]: opts.capability,
            [Attr.Eval.Step.Name]: opts.step ?? void 0,
            // metadata
            [Attr.Eval.Metadata]: JSON.stringify(opts.metadata),
            // run
            [Attr.Eval.Run.ID]: runId,
            // user info
            [Attr.Eval.User.Name]: user?.name,
            [Attr.Eval.User.Email]: user?.email
          }
        });
        evalId = suiteSpan.spanContext().traceId;
        suite.meta.evaluation.id = evalId;
        suiteSpan.setAttribute(Attr.Eval.ID, evalId);
        suiteContext = import_api11.trace.setSpan(import_api11.context.active(), suiteSpan);
        const flagConfig = captureFlagConfig(opts.configFlags);
        suite.meta.evaluation.flagConfig = flagConfig;
        const flagConfigJson = JSON.stringify(flagConfig);
        suiteSpan.setAttribute(Attr.Eval.Config.Flags, flagConfigJson);
        let createEvalResponse;
        if (!isDebug && !isList) {
          createEvalResponse = await evaluationApiClient.createEvaluation({
            id: evalId,
            name: evalName,
            capability: opts.capability,
            step: opts.step,
            dataset: axiomConfig.eval.dataset,
            version: evalVersion,
            baselineId: baselineId ?? void 0,
            runId,
            totalCases: collection.length,
            config: { overrides: injectedOverrides },
            configTimeoutMs: timeoutMs,
            metadata: opts.metadata,
            status: "running"
          });
        }
        const orgId = createEvalResponse?.data?.orgId;
        const resolvedBaselineId = createEvalResponse?.data?.baselineId;
        try {
          if (!isDebug && !isList && !!resolvedBaselineId) {
            baseline = await findEvaluationCases(resolvedBaselineId, axiomConfig);
          }
        } catch (error) {
          console.error(`Failed to load baseline: ${errorToString(error)}`);
          instrumentationError = instrumentationError || error;
        }
        if (baseline) {
          suiteSpan.setAttribute(Attr.Eval.Baseline.ID, baseline.id);
          suiteSpan.setAttribute(Attr.Eval.Baseline.Name, baseline.name);
          suiteSpan.setAttribute(Attr.Eval.Baseline.Version, baseline.version);
        }
        suite.meta.evaluation = {
          id: evalId,
          name: evalName,
          version: evalVersion,
          runId,
          orgId: orgId ?? void 0,
          baseline: baseline ?? void 0,
          configFlags: opts.configFlags,
          registrationStatus: instrumentationError ? {
            status: "failed",
            error: errorToString(instrumentationError)
          } : { status: "success" }
        };
        suiteStart = performance.now();
      });
      (0, import_vitest.afterAll)(async (suite) => {
        if (instrumentationError) {
          throw instrumentationError;
        }
        const tags = ["offline"];
        suiteSpan?.setAttribute(Attr.Eval.Tags, JSON.stringify(tags));
        const flagSummary = /* @__PURE__ */ new Map();
        for (const flag of allOutOfScopeFlags) {
          if (flagSummary.has(flag.flagPath)) {
            const existing = flagSummary.get(flag.flagPath);
            existing.count++;
            existing.firstAccessedAt = Math.min(existing.firstAccessedAt, flag.accessedAt);
            existing.lastAccessedAt = Math.max(existing.lastAccessedAt, flag.accessedAt);
          } else {
            flagSummary.set(flag.flagPath, {
              flagPath: flag.flagPath,
              count: 1,
              firstAccessedAt: flag.accessedAt,
              lastAccessedAt: flag.accessedAt,
              stackTrace: flag.stackTrace
            });
          }
        }
        if (suite.meta.evaluation && suiteSpan) {
          suite.meta.evaluation.outOfScopeFlags = Array.from(flagSummary.entries()).map(
            ([_flagPath, stats]) => stats
          );
          const allDefaults = getConfigScope()?.getAllDefaultFlags();
          const pickedFlags = finalConfigSnapshot?.pickedFlags;
          const overrides = injectedOverrides ?? getGlobalFlagOverrides();
          suite.meta.evaluation.configEnd = {
            flags: allDefaults,
            pickedFlags,
            overrides
          };
        }
        suiteSpan?.setStatus({ code: import_api11.SpanStatusCode.OK });
        suiteSpan?.end();
        try {
          await flush();
        } catch (flushError) {
          if (suite.meta.evaluation) {
            suite.meta.evaluation.registrationStatus = {
              status: "failed",
              error: errorToString(flushError)
            };
          }
        }
        const durationMs = Math.round(performance.now() - suiteStart);
        const successCases = suite.tasks.filter(
          (task) => task.meta.case.status === "success"
        ).length;
        const erroredCases = suite.tasks.filter(
          (task) => task.meta.case.status === "fail" || task.meta.case.status === "pending"
        ).length;
        if (!isDebug && !isList) {
          await evaluationApiClient.updateEvaluation({
            id: evalId,
            status: "completed",
            totalCases: collection.length,
            successCases,
            erroredCases,
            durationMs
          });
        }
      });
      await import_vitest.it.concurrent.for(
        collection.map((d, index) => ({ ...d, index }))
      )("case", async (data, { task }) => {
        const start = performance.now();
        if (!suiteContext) {
          throw new Error(
            "[Axiom AI] Suite context not initialized. This is likely a bug \u2013 instrumentation should complete before tests run."
          );
        }
        let outOfScopeFlags = [];
        await startActiveSpan(
          `case ${data.index}`,
          {
            attributes: {
              [Attr.GenAI.Operation.Name]: "eval.case",
              [Attr.Eval.ID]: evalId,
              [Attr.Eval.Name]: evalName,
              [Attr.Eval.Version]: evalVersion,
              [Attr.Eval.Case.Index]: data.index,
              [Attr.Eval.Case.Input]: typeof data.input === "string" ? data.input : JSON.stringify(data.input),
              [Attr.Eval.Case.Expected]: typeof data.expected === "string" ? data.expected : JSON.stringify(data.expected),
              [Attr.Eval.Case.Metadata]: data.metadata ? JSON.stringify(data.metadata) : void 0,
              // user info
              [Attr.Eval.User.Name]: user?.name,
              [Attr.Eval.User.Email]: user?.email
            }
          },
          async (caseSpan) => {
            const caseContext = import_api11.trace.setSpan(import_api11.context.active(), caseSpan);
            try {
              const result2 = await runTask(
                caseContext,
                {
                  id: evalId,
                  version: evalVersion,
                  name: evalName
                },
                {
                  index: data.index,
                  input: data.input,
                  expected: data.expected,
                  scorers: opts.scorers,
                  task: opts.task,
                  metadata: opts.metadata,
                  configFlags: opts.configFlags,
                  capability: opts.capability,
                  step: opts.step
                }
              );
              const { output, duration } = result2;
              outOfScopeFlags = result2.outOfScopeFlags;
              finalConfigSnapshot = {
                flags: result2.finalFlags || {},
                pickedFlags: opts.configFlags,
                overrides: result2.overrides
              };
              const scoreList = await Promise.all(
                opts.scorers.map(async (scorer) => {
                  const scorerName = getScorerName(scorer);
                  return startActiveSpan(
                    `score ${scorerName}`,
                    {
                      attributes: {
                        [Attr.GenAI.Operation.Name]: "eval.score",
                        [Attr.Eval.ID]: evalId,
                        [Attr.Eval.Name]: evalName,
                        [Attr.Eval.Version]: evalVersion
                      }
                    },
                    async (scorerSpan) => {
                      const scorerStart = performance.now();
                      try {
                        const result3 = await scorer({
                          input: data.input,
                          output,
                          expected: data.expected
                        });
                        const duration2 = Math.round(performance.now() - scorerStart);
                        const scoreValue = result3.score;
                        const metadata = Object.assign(
                          { duration: duration2, startedAt: scorerStart },
                          result3.metadata
                        );
                        scorerSpan.setAttributes({
                          [Attr.Eval.Score.Name]: scorerName,
                          [Attr.Eval.Score.Value]: scoreValue,
                          [Attr.Eval.Score.Metadata]: JSON.stringify(metadata)
                        });
                        if (metadata.error) {
                          const msg = errorToString(metadata.error);
                          scorerSpan.setStatus({
                            code: import_api11.SpanStatusCode.ERROR,
                            message: msg
                          });
                        }
                        return {
                          name: scorerName,
                          score: scoreValue,
                          metadata: Object.assign(
                            { duration: duration2, startedAt: scorerStart },
                            result3.metadata
                          )
                        };
                      } catch (error) {
                        const scorerDuration = Math.round(performance.now() - scorerStart);
                        console.error(`ERROR: scorer ${scorerName} failed. Cause: 
`, error);
                        const msg = errorToString(error);
                        const metadata = {
                          duration: scorerDuration,
                          startedAt: scorerStart,
                          error: msg
                        };
                        scorerSpan.setAttributes({
                          [Attr.Eval.Score.Name]: scorerName,
                          [Attr.Eval.Score.Value]: void 0,
                          [Attr.Eval.Score.Metadata]: JSON.stringify(metadata)
                        });
                        scorerSpan.setStatus({
                          code: import_api11.SpanStatusCode.ERROR,
                          message: msg
                        });
                        return {
                          name: scorerName,
                          score: null,
                          metadata
                        };
                      } finally {
                        scorerSpan.end();
                      }
                    },
                    caseContext
                  );
                })
              );
              const scores = Object.fromEntries(scoreList.map((s2) => [s2.name, s2]));
              caseSpan.setAttributes({
                [Attr.Eval.Case.Output]: typeof output === "string" ? output : JSON.stringify(output),
                [Attr.Eval.Case.Scores]: JSON.stringify(scores ? scores : {})
              });
              task.meta.case = {
                index: data.index,
                name: evalName,
                expected: data.expected,
                input: data.input,
                output,
                metadata: data.metadata,
                scores,
                status: "success",
                errors: [],
                duration,
                startedAt: start,
                outOfScopeFlags,
                pickedFlags: opts.configFlags
              };
              allOutOfScopeFlags.push(...outOfScopeFlags);
            } catch (e) {
              console.log(e);
              const error = e;
              const ctx = getEvalContext();
              outOfScopeFlags = ctx.outOfScopeFlags || [];
              const failedScores = {};
              for (const scorer of opts.scorers) {
                failedScores[scorer.name] = {
                  name: scorer.name,
                  score: 0,
                  metadata: {
                    duration: 0,
                    startedAt: start,
                    error: error.message
                  }
                };
              }
              task.meta.case = {
                name: evalName,
                index: data.index,
                expected: data.expected,
                input: data.input,
                output: String(e),
                metadata: data.metadata,
                scores: failedScores,
                status: "fail",
                errors: [error],
                startedAt: start,
                duration: Math.round(performance.now() - start),
                outOfScopeFlags,
                pickedFlags: opts.configFlags
              };
              allOutOfScopeFlags.push(...outOfScopeFlags);
              throw e;
            } finally {
              try {
                const accessedFlags = finalConfigSnapshot?.flags || {};
                const accessed = Object.keys(accessedFlags);
                const allDefaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};
                const runtimeFlags = {};
                for (const key of accessed) {
                  const value = accessedFlags[key];
                  if (key in allDefaults) {
                    const replaced = !deepEqual(value, allDefaults[key]);
                    if (replaced) {
                      runtimeFlags[key] = { kind: "replaced", value, default: allDefaults[key] };
                    }
                  } else {
                    runtimeFlags[key] = { kind: "introduced", value };
                  }
                }
                if (!isDebug && Object.keys(runtimeFlags).length > 0) {
                  const serialized = JSON.stringify(runtimeFlags);
                  caseSpan.setAttribute("eval.case.config.runtime_flags", serialized);
                }
                if (task.meta.case) {
                  task.meta.case.runtimeFlags = runtimeFlags;
                }
              } catch {
              }
            }
          },
          suiteContext
        );
      });
    },
    timeoutMs
  );
  return result;
}
var joinArrayOfUnknownResults = (results) => {
  if (results.length === 0) {
    return "";
  }
  if (results.every((r2) => typeof r2 === "string")) {
    return results.join("");
  }
  return results[results.length - 1];
};
var executeTask = async (task, input, expected) => {
  const taskResultOrStream = await task({ input, expected });
  if (typeof taskResultOrStream === "object" && taskResultOrStream && Symbol.asyncIterator in taskResultOrStream) {
    const chunks = [];
    for await (const chunk of taskResultOrStream) {
      chunks.push(chunk);
    }
    return joinArrayOfUnknownResults(chunks);
  }
  return taskResultOrStream;
};
var runTask = async (caseContext, evaluation, opts) => {
  const taskName = opts.task.name ?? "anonymous";
  return startActiveSpan(
    `task`,
    {
      attributes: {
        [Attr.GenAI.Operation.Name]: "eval.task",
        [Attr.Eval.Task.Name]: taskName,
        [Attr.Eval.Task.Type]: "llm_completion",
        // TODO: How to determine task type?
        [Attr.Eval.ID]: evaluation.id,
        [Attr.Eval.Name]: evaluation.name,
        [Attr.Eval.Version]: evaluation.version
      }
    },
    async (taskSpan) => {
      const { output, duration, outOfScopeFlags, finalFlags, overrides } = await withEvalContext(
        { pickedFlags: opts.configFlags },
        async () => {
          const start = performance.now();
          const output2 = await executeTask(opts.task, opts.input, opts.expected);
          const duration2 = Math.round(performance.now() - start);
          taskSpan.setAttributes({
            [Attr.Eval.Task.Output]: JSON.stringify(output2)
          });
          const ctx = getEvalContext();
          const outOfScopeFlags2 = ctx.outOfScopeFlags || [];
          return {
            output: output2,
            duration: duration2,
            outOfScopeFlags: outOfScopeFlags2,
            finalFlags: ctx.flags || {},
            overrides: ctx.overrides
          };
        }
      );
      return {
        output,
        duration,
        outOfScopeFlags,
        finalFlags,
        overrides
      };
    },
    caseContext
  );
};

// src/evals.ts
init_reporter();

// src/evals/scorers.ts
init_cjs_shims();

// src/evals/scorer.factory.ts
init_cjs_shims();
init_attributes();
function createScorer(name, fn) {
  const normalizeScore = (res) => {
    if (typeof res === "number") {
      return { score: res };
    }
    if (typeof res === "boolean") {
      return {
        score: res ? 1 : 0,
        metadata: {
          [Attr.Eval.Score.IsBoolean]: true
        }
      };
    }
    return res;
  };
  const scorer = (args) => {
    const res = fn(args);
    if (res instanceof Promise) {
      return res.then(normalizeScore);
    }
    return normalizeScore(res);
  };
  Object.defineProperty(scorer, "name", {
    value: name,
    configurable: true,
    enumerable: true
  });
  return scorer;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AxiomReporter,
  Eval,
  Scorer
});
//# sourceMappingURL=evals.cjs.map